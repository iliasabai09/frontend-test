{
  "profile": "1C Developer",
  "specialization": "1C Developer",
  "file_name": "OB_1C_30",
  "levels": {
    "junior": {
      "themes": [
        {
          "theme": "Язык запросов 1С - чтение и использование готовых запросов для выборки данных в обработках",
          "competency": "Базовая теория 1С программирования",
          "questions": [
            {
              "question": "Почему в запросах 1С используется виртуальная таблица остатков вместо прямого обращения к регистру накопления?",
              "correct_answer": "Виртуальная таблица автоматически рассчитывает итоговые остатки на указанную дату, избавляя от ручного суммирования всех движений",
              "var_1": "Виртуальная таблица используется для автоматического контроля прав доступа к данным регистра, которые не проверяются при прямом обращении",
              "var_2": "Виртуальная таблица остатков позволяет обращаться к данным регистра без блокировки записей, что невозможно при прямом чтении из таблицы движений",
              "var_3": "Виртуальная таблица остатков нужна для ускорения работы сервера за счёт кэширования данных регистра, так как прямое обращение создаёт слишком большую нагрузку",
              "var_4": "Виртуальная таблица автоматически рассчитывает итоговые остатки на указанную дату, избавляя от ручного суммирования всех движений",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Виртуальные таблицы не предназначены для контроля прав доступа. Права доступа проверяются на уровне объектов метаданных независимо от способа обращения к данным.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Блокировки не связаны с использованием виртуальных таблиц. И прямое чтение из таблицы движений, и чтение через виртуальную таблицу не блокируют записи при SELECT-запросах.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Виртуальные таблицы не кэшируют данные. Наоборот, они каждый раз выполняют расчёт остатков на основе движений (или итогов, если они включены). Ускорение достигается за счёт использования итогов регистра, а не кэширования.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это основное назначение виртуальных таблиц остатков - автоматический расчёт остатков на дату путём суммирования всех движений регистра, что избавляет от необходимости писать сложные запросы с группировками и суммированием вручную.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой метод объекта Запрос нужно вызвать для получения результата выборки данных из базы?",
              "correct_answer": "Метод Выполнить(), который возвращает объект РезультатЗапроса, из которого затем можно получить выборку методом Выбрать().",
              "var_1": "Метод ПолучитьДанные(), который напрямую возвращает массив записей из базы данных без необходимости дополнительных преобразований результата.",
              "var_2": "Метод ВыполнитьЗапрос(), возвращающий коллекцию значений, которую можно обойти циклом Для Каждого без дополнительных методов.",
              "var_3": "Метод Выполнить(), который возвращает объект РезультатЗапроса, из которого затем можно получить выборку методом Выбрать().",
              "var_4": "Метод Выбрать(), который сразу возвращает выборку данных из базы, минуя промежуточный этап создания объекта РезультатЗапроса.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Метода ПолучитьДанные() не существует в объекте Запрос. Правильный метод - Выполнить(), который возвращает РезультатЗапроса, а не массив записей.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Метода ВыполнитьЗапрос() не существует в объекте Запрос. Правильное название метода - Выполнить(), и он не возвращает коллекцию напрямую, а возвращает объект РезультатЗапроса.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это полностью корректное описание работы с запросами в 1С. Метод Выполнить() объекта Запрос действительно возвращает объект РезультатЗапроса, из которого затем получают выборку методом Выбрать().",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Метод Выбрать() не является методом объекта Запрос. Это метод объекта РезультатЗапроса, который получается после вызова метода Выполнить() объекта Запрос. Последовательность обязательна.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Перехват ошибок файловых операций - обработка исключений при чтении и записи файлов на диске",
          "competency": "Блок применения попытки/исключения 1С",
          "questions": [
            {
              "question": "Почему при записи файла важно помещать код в блок Попытка/Исключение, а не просто проверять существование каталога?",
              "correct_answer": "Запись может не удаться по другим причинам: нехватка места на диске, блокировка файла другим процессом, отсутствие прав доступа",
              "var_1": "Блок Попытка/Исключение нужен только для красивого оформления кода и соблюдения стандартов разработки 1С",
              "var_2": "Попытка/Исключение позволяет автоматически создать каталог, если он не существует, без дополнительного кода",
              "var_3": "Запись может не удаться по другим причинам: нехватка места на диске, блокировка файла другим процессом, отсутствие прав доступа",
              "var_4": "Проверка существования каталога выполняется асинхронно, а блок Попытка/Исключение делает операцию синхронной",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Блок Попытка/Исключение не является декоративным элементом. Он необходим для реальной обработки ошибок выполнения, которые невозможно предусмотреть простыми проверками.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Блок Попытка/Исключение не создает каталоги автоматически. Для создания каталога нужно явно использовать методы СоздатьКаталог() или подобные.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Проверка существования каталога не гарантирует успешную запись, так как могут возникнуть другие ошибки: недостаток места, блокировка файла, отсутствие прав доступа, неправильное имя файла и т.д.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "В 1С файловые операции выполняются синхронно независимо от использования блока Попытка/Исключение. Асинхронность здесь не при чем.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какое свойство объекта ИнформацияОбОшибке следует использовать в блоке Исключение для получения текста ошибки при неудачном чтении файла?",
              "correct_answer": "Следует использовать свойство Описание объекта ИнформацияОбОшибке() для получения текстового описания ошибки.",
              "var_1": "Для получения текста ошибки необходимо использовать свойство ТекстОшибки объекта ИнформацияОбОшибке(), которое возвращает строку.",
              "var_2": "Следует использовать свойство Описание объекта ИнформацияОбОшибке() для получения текстового описания ошибки.",
              "var_3": "Следует использовать свойство Причина объекта ИнформацияОбОшибке() для получения текста.",
              "var_4": "Нужно вызвать метод ПолучитьСообщениеОбОшибке() у объекта ИнформацияОбОшибке для получения текста.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "У объекта ИнформацияОбОшибке нет свойства ТекстОшибки. Правильное свойство называется Описание, которое возвращает строку с описанием ошибки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Свойство Описание объекта ИнформацияОбОшибке действительно возвращает текстовое описание ошибки и является корректным способом получения информации об ошибке.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Свойство Причина содержит вложенную ошибку (другой объект ИнформацияОбОшибке), а не текст ошибки. Для текста используется свойство Описание.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "У объекта ИнформацияОбОшибке нет метода ПолучитьСообщениеОбОшибке(). Это свойства, а не методы используются для получения информации об ошибке.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Права доступа к отчетам и обработкам - настройка видимости и запуска для определенных ролей",
          "competency": "Права и роли в 1С",
          "questions": [
            {
              "question": "Почему для ограничения доступа к отчету недостаточно просто убрать его из подсистемы в интерфейсе?",
              "correct_answer": "Пользователь может запустить отчет программно или через меню Все функции, поэтому нужны права на уровне роли",
              "var_1": "Скрытие отчета из подсистемы достаточно для типовых конфигураций, но в нестандартных решениях нужны дополнительные настройки",
              "var_2": "Убрать из подсистемы достаточно, просто нужно после этого перезапустить сеанс пользователя для применения",
              "var_3": "Удаление из подсистемы автоматически создает ограничение на уровне метаданных, но требуется дополнительная публикация конфигурации",
              "var_4": "Пользователь может запустить отчет программно или через меню Все функции, поэтому нужны права на уровне роли",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Неверно. Скрытие из подсистемы недостаточно ни для типовых, ни для нестандартных конфигураций. Это универсальное правило для всех конфигураций 1С - управление видимостью в интерфейсе не заменяет управление правами доступа через роли.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Неверно. Убрать из подсистемы недостаточно даже после перезапуска сеанса. Это только скрывает отчет из видимого интерфейса, но не ограничивает доступ на уровне прав. Пользователь все равно может запустить отчет другими способами.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Неверно. Удаление из подсистемы не создает никаких ограничений на уровне метаданных и не влияет на права доступа. Это только изменение состава интерфейса. Публикация конфигурации здесь не имеет отношения к правам доступа.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Верно. Удаление отчета из подсистемы скрывает его только из интерфейса, но пользователь может запустить отчет через меню 'Все функции' (Shift+F3) или программно. Для реального ограничения доступа необходимо использовать механизм ролей и прав доступа.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какое право необходимо назначить роли в конфигураторе, чтобы пользователь мог открывать определенную внешнюю обработку?",
              "correct_answer": "Для внешних обработок нужно назначить право «Интерактивное открытие внешних обработок» в свойствах роли на уровне конфигурации.",
              "var_1": "Достаточно назначить право «Использование» для объекта «Обработки» в свойствах роли, и пользователь автоматически получит доступ ко всем внешним обработкам.",
              "var_2": "Для внешних обработок нужно назначить право «Интерактивное открытие внешних обработок» в свойствах роли на уровне конфигурации.",
              "var_3": "Нужно назначить право «Открытие» непосредственно для каждой внешней обработки в дереве метаданных конфигурации в разделе «Обработки».",
              "var_4": "Для открытия внешних обработок необходимо установить право «Администрирование» в разделе «Общие права» конфигурации для соответствующей роли.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Неверно. Право «Использование» для объекта «Обработки» относится к встроенным обработкам конфигурации, а не к внешним. Внешние обработки требуют отдельного специального права.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Верно. Для работы с внешними обработками в 1С необходимо установить право «Интерактивное открытие внешних обработок» в свойствах роли. Это базовое право на уровне конфигурации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Неверно. Внешние обработки не являются частью метаданных конфигурации и не отображаются в дереве метаданных. Они подключаются извне, поэтому права настраиваются на уровне конфигурации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Неверно. Право «Администрирование» дает слишком широкие полномочия и не является необходимым для открытия внешних обработок. Существует специальное право для этой цели.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Переиспользование кода - применение готовых шаблонов для унификации процедур обработки данных",
          "competency": "Понимание модульности и архитектуры кода 1С",
          "questions": [
            {
              "question": "Почему использование готовых шаблонов обработки данных в 1С снижает количество ошибок в коде?",
              "correct_answer": "Шаблоны уже протестированы и отлажены, разработчик не пишет типовую логику с нуля",
              "var_1": "Использование шаблонов заставляет платформу 1С работать в специальном режиме отладки",
              "var_2": "Шаблоны блокируют возможность допустить синтаксическую ошибку",
              "var_3": "Шаблоны автоматически исправляют ошибки в коде разработчика при компиляции модуля конфигурации",
              "var_4": "Шаблоны уже протестированы и отлажены, разработчик не пишет типовую логику с нуля",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Использование шаблонов не активирует никакой специальный режим отладки в платформе 1С. Платформа работает в обычном режиме независимо от использования шаблонов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Шаблоны не блокируют синтаксические ошибки. Разработчик все равно может допустить синтаксическую ошибку при использовании или модификации шаблона.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Шаблоны не исправляют ошибки автоматически при компиляции. Они просто предоставляют готовый проверенный код, но не имеют механизма автоматического исправления ошибок разработчика.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Готовые шаблоны уже прошли тестирование и отладку, поэтому использование проверенного кода снижает вероятность ошибок по сравнению с написанием логики с нуля.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой общий модуль следует создать для унификации процедуры проверки заполнения обязательных реквизитов в разных документах?",
              "correct_answer": "Общий модуль с экспортной функцией проверки, принимающей объект и массив имён реквизитов, возвращающей структуру с результатами валидации.",
              "var_1": "Отдельный общий модуль для каждого документа со своей процедурой проверки, вызываемой из модуля объекта, что обеспечивает гибкость настройки под каждый тип документа.",
              "var_2": "Общий модуль с серверной процедурой, которая напрямую изменяет реквизиты документа и автоматически записывает объект после успешной проверки заполнения.",
              "var_3": "Модуль формы с клиентской процедурой проверки, вызываемой при нажатии кнопки \"Провести\" и выводящей сообщения пользователю.",
              "var_4": "Общий модуль с экспортной функцией проверки, принимающей объект и массив имён реквизитов, возвращающей структуру с результатами валидации.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Создание отдельного общего модуля для каждого документа противоречит принципу унификации и переиспользования кода. Это дублирование логики, а не её унификация.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Процедура проверки заполнения не должна изменять реквизиты и записывать объект. Её задача - только валидация данных и информирование о результате, а не модификация объекта.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Модуль формы не является общим модулем и не обеспечивает переиспользование кода между разными документами. Логика проверки должна быть на сервере, а не только на клиенте.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный подход к унификации: общий модуль с универсальной экспортной функцией, принимающей объект и список реквизитов для проверки, возвращающей результат валидации. Обеспечивает переиспользование кода.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Доработка отчетов через расширения - добавление колонок и модификация запросов СКД",
          "competency": "Знание работы с расширениями в 1С",
          "questions": [
            {
              "question": "Почему при добавлении нового поля в запрос СКД через расширение необходимо также добавить его в набор данных схемы?",
              "correct_answer": "Без регистрации в наборе данных СКД не сможет использовать поле в настройках вывода и группировках",
              "var_1": "Регистрация в наборе данных нужна для корректного подключения расширения к конфигурации",
              "var_2": "Без добавления в набор данных поле не будет отображаться в конструкторе запросов",
              "var_3": "Без регистрации в наборе данных СКД не сможет использовать поле в настройках вывода и группировках",
              "var_4": "Добавление в набор данных требуется только для правильной типизации значений в отчете",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Регистрация в наборе данных не связана с подключением расширения. Расширение подключается на уровне конфигурации независимо от изменений в наборах данных отчетов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Поле будет доступно в конструкторе запросов и без добавления в набор данных СКД. Конструктор запросов работает с текстом запроса напрямую, а не через механизмы СКД.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это верно. СКД использует набор данных как схему доступных полей. Без регистрации поля в наборе данных СКД не будет знать о его существовании и не сможет использовать его в настройках отбора, группировок, выбранных полей и других элементах компоновки данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Типизация значений в отчете определяется типом поля в запросе и метаданных, а не фактом добавления в набор данных. Добавление в набор данных нужно для видимости поля в СКД.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой объект расширения нужно использовать для добавления нового поля в существующий набор данных СКД типового отчета?",
              "correct_answer": "Заимствованный отчет с модификацией схемы компоновки данных",
              "var_1": "Заимствованный отчет с модификацией схемы компоновки данных",
              "var_2": "Расширение модуля менеджера отчета",
              "var_3": "Добавляемый набор данных в расширении отчета",
              "var_4": "Собственный отчет расширения с копированием данных из типовой схемы СКД",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Заимствованный отчет - правильный механизм расширений для модификации типовых отчетов. Он позволяет изменять схему СКД, добавлять новые поля в наборы данных, изменять запросы.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Расширение модуля менеджера позволяет изменить программный код, но не структуру СКД. Для добавления поля в набор данных нужно модифицировать саму схему компоновки данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Добавляемый набор данных создает новый отдельный набор, а не добавляет поле в существующий набор данных типового отчета. Это разные задачи.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Создание собственного отчета с копированием схемы - это не расширение типового отчета, а создание нового. Это нарушает принцип расширений и затрудняет обновление конфигурации.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Вывод сообщений пользователю и дублирование в журнал регистрации - использование процедуры Сообщить() и ЗаписьЖурналаРегистрации()",
          "competency": "Навыки работы с журналом регистрации и логированием 1С",
          "questions": [
            {
              "question": "Почему процедура Сообщить() не подходит для фиксации ошибок в серверных фоновых заданиях без участия пользователя?",
              "correct_answer": "Сообщить() выводит текст только в пользовательский интерфейс, а в фоновых заданиях нет активного сеанса пользователя для отображения сообщений",
              "var_1": "Сообщить() выводит текст только в пользовательский интерфейс, а в фоновых заданиях нет активного сеанса пользователя для отображения сообщений",
              "var_2": "Фоновые задания выполняются в отдельном потоке, где процедура Сообщить() недоступна по умолчанию",
              "var_3": "Сообщить() автоматически блокируется системой безопасности при выполнении на сервере, так как серверный код не имеет прав на вызов клиентских методов вывода",
              "var_4": "Сообщить() работает только в клиентском контексте и вызывает исключение при попытке использования на сервере приложений",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Верно. Процедура Сообщить() предназначена для вывода информации пользователю через UI. В фоновых заданиях нет активного пользовательского сеанса с интерфейсом, поэтому сообщения некуда выводить и они теряются.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Процедура Сообщить() доступна в фоновых заданиях и не блокируется по причине отдельного потока. Проблема не в доступности метода, а в отсутствии UI для вывода.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Сообщить() не блокируется системой безопасности и не является клиентским методом. Это серверная процедура, которая просто не имеет куда выводить информацию в фоновых заданиях.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Неверно. Сообщить() работает и на клиенте, и на сервере. Она не вызывает исключение на сервере, просто не имеет интерфейса для отображения в фоновых заданиях.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой уровень важности следует указать в ЗаписьЖурналаРегистрации() при логировании ошибки загрузки данных из внешнего источника?",
              "correct_answer": "Следует указать уровень УровеньЖурналаРегистрации.Ошибка, чтобы администратор мог отфильтровать критичные события в журнале регистрации.",
              "var_1": "Следует указать уровень УровеньЖурналаРегистрации.Информация, чтобы не засорять журнал ошибками и не пугать пользователей лишними сообщениями.",
              "var_2": "Следует указать уровень УровеньЖурналаРегистрации.Предупреждение, так как загрузка данных из внешнего источника не является критичной системной операцией.",
              "var_3": "Следует указать уровень УровеньЖурналаРегистрации.Ошибка, чтобы администратор мог отфильтровать критичные события в журнале регистрации.",
              "var_4": "Следует указать уровень УровеньЖурналаРегистрации.Примечание, поскольку ошибки загрузки носят информационный характер для анализа.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Уровень 'Информация' предназначен для обычных информационных событий. Ошибка загрузки данных - это критичное событие, которое нельзя скрывать под видом информационного сообщения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Ошибка загрузки данных - это именно ошибка, а не предупреждение. Предупреждение используется для потенциальных проблем, а не для фактических сбоев.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Ошибка загрузки данных из внешнего источника является критичным событием, которое должно быть зарегистрировано с уровнем 'Ошибка' для возможности фильтрации и оперативного реагирования администратором.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Уровень 'Примечание' используется для несущественной информации, а ошибка загрузки данных является важным событием, требующим внимания администратора.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Оборачивание операций записи объектов - применение транзакций при работе с документами и справочниками по образцам кода",
          "competency": "Знание работы транзакций в 1С",
          "questions": [
            {
              "question": "Почему при записи нескольких связанных объектов в 1С необходимо оборачивать операции в транзакцию?",
              "correct_answer": "Чтобы при ошибке в любой операции все изменения откатились и данные остались согласованными",
              "var_1": "Чтобы каждый объект записывался в отдельном потоке и не мешал записи остальных",
              "var_2": "Чтобы ускорить запись объектов за счёт группировки операций в один пакет",
              "var_3": "Чтобы система автоматически блокировала объекты от изменения другими пользователями",
              "var_4": "Чтобы при ошибке в любой операции все изменения откатились и данные остались согласованными",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "1С не поддерживает многопоточную запись объектов в рамках одной транзакции. Транзакция выполняется последовательно в одном потоке, а не параллельно",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Транзакции не предназначены для ускорения записи. Их цель - обеспечение целостности данных и атомарности операций, а не оптимизация производительности",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Транзакции не обеспечивают автоматическую блокировку объектов от других пользователей. Для этого нужно явно использовать механизмы блокировок (например, метод Заблокировать() или управляемые блокировки)",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это основная цель транзакций - обеспечить атомарность операций. Если произойдет ошибка при записи любого из связанных объектов, все изменения откатятся, и данные останутся в согласованном состоянии",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой метод необходимо вызвать для отмены всех изменений при возникновении ошибки внутри явной транзакции при записи документа?",
              "correct_answer": "Необходимо вызвать метод ОтменитьТранзакцию() в блоке Исключение для отката всех изменений, выполненных после НачатьТранзакцию().",
              "var_1": "Необходимо вызвать метод ОтменитьТранзакцию() в блоке Исключение для отката всех изменений, выполненных после НачатьТранзакцию().",
              "var_2": "Необходимо вызвать метод ЗафиксироватьТранзакцию() с параметром Ложь в блоке Исключение, чтобы система автоматически откатила все изменения.",
              "var_3": "При возникновении ошибки достаточно просто выйти из процедуры, так как система автоматически отменит транзакцию при завершении контекста.",
              "var_4": "Следует использовать метод Откатить() объекта документа для возврата к предыдущему состоянию базы данных.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. ОтменитьТранзакцию() - корректный метод для отката всех изменений, выполненных после НачатьТранзакцию().",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Метод ЗафиксироватьТранзакцию() используется для ФИКСАЦИИ изменений, а не для отката. Он не принимает параметров и выполняет commit транзакции.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Автоматический откат происходит только при аварийном завершении. При нормальном выходе из процедуры без фиксации транзакция остается открытой, что может привести к блокировкам.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Метод Откатить() не существует у объектов документов в 1С. Откат транзакции выполняется глобальным методом ОтменитьТранзакцию().",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "HTTPЗапрос 1С - настройка заголовков Content-Type и Authorization для базовой аутентификации",
          "competency": "Принципы работы http запросов 1С",
          "questions": [
            {
              "question": "Почему заголовок Authorization для базовой аутентификации должен содержать строку в кодировке Base64?",
              "correct_answer": "Для представления логина и пароля в текстовом ASCII-формате",
              "var_1": "Для представления логина и пароля в текстовом ASCII-формате",
              "var_2": "Для сжатия данных и уменьшения размера запроса",
              "var_3": "Для валидации корректности символов",
              "var_4": "Для шифрования данных и защиты пароля от перехвата при передаче по сети",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Верно. Base64 преобразует любые данные (включая спецсимволы в логине/пароле) в безопасный ASCII-текст, который можно передавать в HTTP-заголовках без проблем с кодировками.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Base64 не сжимает данные, а наоборот увеличивает их размер примерно на 33%. Это кодирование, а не компрессия.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Base64 не предназначен для валидации символов. Это метод кодирования для представления бинарных данных в текстовом формате, а не для проверки корректности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Base64 - это НЕ шифрование, а просто кодирование. Данные легко декодируются обратно без ключа. Для защиты нужно использовать HTTPS, а не Base64.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как установить заголовок Authorization при базовой аутентификации в объекте HTTPЗапрос в 1С?",
              "correct_answer": "Через HTTPЗапрос.Заголовки.Вставить('Authorization', 'Basic ' + Base64Строка('логин:пароль')).",
              "var_1": "HTTPЗапрос.Заголовки.Вставить('Authorization', 'логин:пароль') без кодирования.",
              "var_2": "HTTPЗапрос.Заголовки.Добавить('Auth', Base64Строка('логин:пароль')) напрямую.",
              "var_3": "Через HTTPЗапрос.Заголовки.Вставить('Authorization', 'Basic ' + Base64Строка('логин:пароль')).",
              "var_4": "HTTPЗапрос.УстановитьАвторизацию('Basic', 'логин', 'пароль') без заголовков.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Отсутствует обязательное Base64-кодирование учетных данных и префикс 'Basic '",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Неверное имя заголовка ('Auth' вместо 'Authorization') и отсутствует префикс 'Basic '",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Правильный способ: заголовок Authorization с префиксом 'Basic ' и Base64-кодированием строки 'логин:пароль'",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Метод УстановитьАвторизацию() не существует в объекте HTTPЗапрос в 1С",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Функции расчета и округления - реализация арифметических операций с числовыми типами согласно учетной политике",
          "competency": "Общие модули 1С",
          "questions": [
            {
              "question": "Почему в 1С при финансовых расчетах важно явно указывать количество знаков в функции Окр(), а не полагаться на значение по умолчанию?",
              "correct_answer": "По умолчанию округляет до целых, теряются копейки",
              "var_1": "Без указания знаков система автоматически выбирает валюту расчета неверно",
              "var_2": "По умолчанию функция использует банковское округление, что нарушает стандарты",
              "var_3": "По умолчанию округляет до целых, теряются копейки",
              "var_4": "Функция Окр() без параметров работает медленнее из-за автоопределения",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Функция Окр() не связана с валютой расчета и не выбирает её автоматически. Это функция работы с числами, она просто выполняет математическое округление независимо от валюты.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Банковское округление (до ближайшего четного) как раз является стандартом для финансовых расчетов и не нарушает их. Функция Окр() в 1С использует математическое округление, а не банковское по умолчанию.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Функция Окр() без второго параметра действительно округляет до целого числа (0 знаков после запятой по умолчанию), что приводит к потере дробной части - копеек в финансовых расчетах.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Производительность функции Окр() не зависит от наличия или отсутствия параметра количества знаков. Нет никакого автоопределения, которое бы замедляло работу - просто используется значение по умолчанию (0).",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую функцию следует использовать для округления суммы НДС до двух знаков после запятой?",
              "correct_answer": "Встроенную функцию Окр() с параметрами: сумма, 2, 0 (округление к ближайшему четному).",
              "var_1": "Встроенную функцию Окр() с параметрами: сумма, 2, 0 (округление к ближайшему четному).",
              "var_2": "Функцию Окр() с параметрами: сумма, 2, 1 (округление в большую сторону).",
              "var_3": "Встроенную функцию Формат() с форматной строкой \"ЧДЦ=2\" для округления.",
              "var_4": "Функцию Цел() с последующим умножением и делением на 100 для точности.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Окр(сумма, 2, 0) правильно округляет до 2 знаков после запятой по стандартному правилу (к ближайшему четному при 0.5)",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Режим округления 1 (в большую сторону) не соответствует стандартным правилам округления НДС, это приведет к завышению сумм",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Формат() выполняет форматирование для отображения, но не округляет само значение числа, а только его строковое представление",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Цел() отбрасывает дробную часть (округление вниз), что для НДС неприменимо, приводит к потере точности и некорректным суммам",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Воспроизведение ошибок - фиксация стека вызовов и условий возникновения",
          "competency": "Тестирование и отладка в 1С",
          "questions": [
            {
              "question": "Почему важно фиксировать полный стек вызовов при воспроизведении ошибки в 1С?",
              "correct_answer": "Стек показывает последовательность вызовов процедур, что позволяет определить путь выполнения кода до места ошибки",
              "var_1": "Стек вызовов показывает объём используемой памяти в момент ошибки, что помогает выявить проблемы производительности сервера",
              "var_2": "Стек вызовов нужен для автоматического исправления ошибок системой, так как платформа 1С использует его для восстановления работоспособности",
              "var_3": "Фиксация стека позволяет определить какой пользователь вызвал ошибку и отправить ему уведомление о необходимости повторить действие",
              "var_4": "Стек показывает последовательность вызовов процедур, что позволяет определить путь выполнения кода до места ошибки",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Стек вызовов показывает последовательность вызовов процедур и функций, а не объём используемой памяти. Для анализа памяти используются другие инструменты (профилировщик, замеры производительности).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Платформа 1С не использует стек вызовов для автоматического исправления ошибок. Стек нужен разработчику для ручного анализа и исправления кода.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Стек вызовов не предназначен для определения пользователя - он показывает последовательность выполнения кода. Информация о пользователе берется из других источников (контекст сеанса).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Стек вызовов действительно показывает последовательность вызовов процедур и функций, что позволяет проследить путь выполнения программы от точки входа до места возникновения ошибки.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой инструмент отладчика 1С позволяет получить полный стек вызовов процедур в момент возникновения ошибки?",
              "correct_answer": "Окно «Стек вызовов», отображающее иерархию вызовов процедур и функций до точки ошибки.",
              "var_1": "Журнал регистрации, содержащий данные о последовательности выполнения кода.",
              "var_2": "Окно «Стек вызовов», отображающее иерархию вызовов процедур и функций до точки ошибки.",
              "var_3": "Консоль сообщений с выводом трассировки выполнения программы.",
              "var_4": "Окно «Локальные переменные», которое автоматически сохраняет историю всех вызовов методов в системе.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Журнал регистрации фиксирует события системы (ошибки, действия пользователей), но не содержит детальную последовательность выполнения кода и стек вызовов",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Окно «Стек вызовов» в отладчике 1С именно для этого и предназначено - показывает полную цепочку вызовов процедур и функций до точки останова или ошибки",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Консоль сообщений используется для вывода отладочных сообщений через Сообщить(), но не предоставляет автоматический стек вызовов при ошибке",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Окно «Локальные переменные» показывает только значения переменных в текущем контексте, не сохраняет историю вызовов методов",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Проведение документа - реализация простых проверок корректности данных перед проведением",
          "competency": "Жизненный цикл документа 1С",
          "questions": [
            {
              "question": "Почему проверки корректности данных важно выполнять до обработчика ОбработкаПроведения?",
              "correct_answer": "Чтобы предотвратить формирование некорректных движений по регистрам",
              "var_1": "Чтобы ускорить процесс записи документа в базу данных",
              "var_2": "Потому что обработчик ОбработкаПроведения не поддерживает вызов исключений с сообщениями",
              "var_3": "Чтобы система автоматически исправляла ошибки в данных и корректировала реквизиты документа",
              "var_4": "Чтобы предотвратить формирование некорректных движений по регистрам",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Проверки перед проведением не ускоряют запись, а наоборот добавляют дополнительное время на выполнение проверок. Цель проверок - обеспечение корректности данных, а не производительность.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Обработчик ОбработкаПроведения поддерживает вызов исключений через ВызватьИсключение() или Отказ = Истина с сообщениями через Сообщить(). Это стандартный механизм отмены проведения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Проверки корректности не исправляют данные автоматически, а только выявляют ошибки и прерывают проведение. Автоматическое исправление реквизитов документа при проведении - это плохая практика, которая может привести к непредсказуемому поведению.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это основная причина проверок до ОбработкаПроведения. Если данные некорректны, а мы уже начали формировать движения, то можем записать в регистры ошибочные данные, что нарушит учет. Проверки позволяют отменить проведение до создания движений.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой обработчик события документа нужно использовать для проверки заполненности реквизита Контрагент перед проведением?",
              "correct_answer": "ОбработкаПроверкиЗаполнения в модуле объекта документа с установкой параметра Отказ при ошибке.",
              "var_1": "ОбработкаПроведения в модуле объекта документа с проверкой заполненности и вызовом исключения при пустом значении.",
              "var_2": "ПередЗаписью в модуле формы документа с установкой параметра Отказ при обнаружении незаполненного реквизита.",
              "var_3": "ОбработкаПроверкиЗаполнения в модуле объекта документа с установкой параметра Отказ при ошибке.",
              "var_4": "ПриЗаписи в модуле объекта документа с генерацией сообщения об ошибке пользователю.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "ОбработкаПроведения предназначена для формирования движений документа, а не для проверок заполненности. Проверки должны выполняться до проведения в ОбработкаПроверкиЗаполнения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "ПередЗаписью в модуле формы - не лучшее место для бизнес-логики проверок. Проверки должны выполняться на сервере в модуле объекта, а не в форме (клиентская сторона).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "ОбработкаПроверкиЗаполнения - стандартный обработчик для проверок корректности данных перед записью/проведением. Параметр Отказ правильно блокирует проведение при ошибках валидации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "ПриЗаписи срабатывает после записи документа, когда уже поздно проверять данные. Проверки должны выполняться ДО записи/проведения, а не после.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Система компоновки данных - создание простого отчета с базовыми фильтрами по датам и контрагентам",
          "competency": "Основы платформы 1С",
          "questions": [
            {
              "question": "Почему в СКД фильтр по контрагенту рекомендуется реализовывать через параметры запроса, а не через отбор в настройках?",
              "correct_answer": "Гарантированное ограничение выборки до получения данных из СУБД",
              "var_1": "Автоматическое кеширование данных по контрагентам",
              "var_2": "Гарантированное ограничение выборки до получения данных из СУБД",
              "var_3": "Удобство настройки отчета пользователем",
              "var_4": "Возможность использовать контрагента в группировках",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "СКД не предоставляет автоматического кеширования данных по параметрам. Кеширование нужно реализовывать отдельно программно, если требуется.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Параметры запроса подставляются непосредственно в текст SQL-запроса на уровне СУБД, что гарантирует ограничение выборки данных до их получения. Отбор в настройках СКД может применяться уже после получения данных, что неэффективно при больших объемах.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Удобство настройки одинаково и для параметров, и для отборов. Это не является причиной выбора параметров запроса.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Использование в группировках не зависит от того, параметр это или отбор. Контрагента можно использовать в группировках в любом случае, если он есть в наборе данных.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой параметр компоновки данных нужно добавить в отбор СКД, чтобы пользователь мог фильтровать отчет по периоду дат?",
              "correct_answer": "Параметр «Период» типа СтандартныйПериод в настройках отбора СКД.",
              "var_1": "Поле «Период» в структуре отчета с группировкой по датам.",
              "var_2": "Условие отбора «Дата» в запросе набора данных.",
              "var_3": "Параметр «Период» типа СтандартныйПериод в настройках отбора СКД.",
              "var_4": "Поле «Период» типа СтандартныйПериод в разделе параметры данных СКД.",
              "correct_position": 3,
              "fixes_applied": 1,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Поле группировки используется для структурирования данных отчета, а не для фильтрации. Группировка по датам влияет на представление данных, но не создает параметр для отбора пользователем.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Условие отбора в запросе не является параметром компоновки данных. Это часть текста запроса, а не элемент настроек СКД, который пользователь может изменять через интерфейс отчета.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Тип СтандартныйПериод используется в обычных формах, но не в СКД. В СКД для периода используются два параметра типа Дата (начало и окончание периода) или отдельные условия отбора.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Это правильный подход для СКД. Создаются два параметра данных типа Дата (ДатаНачала и ДатаОкончания), которые затем используются в условиях отбора запроса через конструкцию &ДатаНачала и &ДатаОкончания.",
                "was_replaced": true,
                "original_before_fix": "Параметр «ДатаНачала» и «ДатаОкончания» типа Дата в разделе параметры данных СКД."
              }
            }
          ]
        },
        {
          "theme": "Виртуальные таблицы регистров - получение остатков и оборотов",
          "competency": "Запросы в 1С",
          "questions": [
            {
              "question": "Почему при получении остатков регистра накопления рекомендуется использовать виртуальную таблицу вместо прямого запроса к основной таблице?",
              "correct_answer": "Виртуальная таблица использует предрассчитанные итоги, что значительно ускоряет получение данных без пересчёта всех движений",
              "var_1": "Виртуальная таблица обращается к отдельной физической таблице остатков, которая обновляется в реальном времени при каждой записи движений регистра",
              "var_2": "Виртуальная таблица позволяет получать данные только за текущий период, а основная таблица хранит всю историю движений",
              "var_3": "Виртуальная таблица автоматически блокирует записи на время выполнения запроса, что предотвращает конфликты при параллельном доступе нескольких пользователей к данным",
              "var_4": "Виртуальная таблица использует предрассчитанные итоги, что значительно ускоряет получение данных без пересчёта всех движений",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Виртуальная таблица не обращается к отдельной физической таблице остатков. Остатки рассчитываются на основе итогов, но это не отдельная таблица, обновляемая в реальном времени при каждой записи.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Виртуальная таблица может получать данные на любую дату, а не только за текущий период. Основная таблица действительно хранит всю историю, но это не причина использования виртуальной таблицы.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Виртуальная таблица не автоматически блокирует записи. Блокировки управляются транзакциями и механизмом управляемых блокировок, а не виртуальными таблицами остатков.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Виртуальная таблица остатков использует механизм итогов (предрассчитанных агрегатов), что позволяет быстро получить остатки без необходимости суммировать все движения с начала времён.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой параметр виртуальной таблицы РегистрНакопления.ОстаткиТоваров.Остатки() нужно указать, чтобы получить остатки на конкретную дату?",
              "correct_answer": "Первым параметром указывается дата, на которую нужно получить остатки, например: Остатки(&ДатаОстатков, Номенклатура = &Товар).",
              "var_1": "Параметр даты не требуется - система автоматически берёт текущую дату сеанса, а для другой даты используется метод УстановитьДатуОстатков().",
              "var_2": "Первым параметром указывается дата, на которую нужно получить остатки, например: Остатки(&ДатаОстатков, Номенклатура = &Товар).",
              "var_3": "Дата указывается вторым параметром после условия отбора, например: Остатки(Номенклатура = &Товар, &ДатаОстатков), где сначала фильтр, потом период.",
              "var_4": "Нужно указать параметр Период в секции ГДЕ запроса, а виртуальная таблица вызывается без параметров: Остатки().",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "В 1С не существует метода УстановитьДатуОстатков(). Дата передается как параметр виртуальной таблицы, а не через отдельный метод.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный синтаксис: первым параметром в виртуальную таблицу Остатки() передается дата, на которую нужно получить остатки, далее могут идти условия отбора.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Неверный порядок параметров. В виртуальной таблице Остатки() дата всегда указывается первым параметром, а условия отбора - после неё, а не наоборот.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Виртуальная таблица Остатки() требует обязательного параметра с датой, она не может вызываться без параметров. Период в ГДЕ не заменяет параметр таблицы.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Работа с простыми запросами - добавление полей в выборку и применение отборов по реквизитам справочников",
          "competency": "Навыки работы с консолью запросов 1С",
          "questions": [
            {
              "question": "Почему в запросе 1С условие отбора по реквизиту справочника выполняется быстрее при использовании индексированного поля?",
              "correct_answer": "Индекс позволяет СУБД искать данные без полного перебора всех записей таблицы",
              "var_1": "Индекс автоматически кэширует значения полей в оперативной памяти",
              "var_2": "Индексация сжимает данные, поэтому запрос обрабатывает меньше байт",
              "var_3": "Индекс позволяет СУБД искать данные без полного перебора всех записей таблицы",
              "var_4": "Индексированное поле хранится в отдельной таблице базы данных",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Индекс не кэширует автоматически значения полей в оперативной памяти. СУБД может кэшировать часто используемые страницы индекса, но это не автоматическое кэширование значений полей и работает на уровне СУБД, а не индекса.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Индексы не сжимают данные. Индекс — это отдельная структура данных, которая содержит ключевые значения и ссылки на строки. Она занимает дополнительное место, а не уменьшает объем данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение. Индекс создает упорядоченную структуру (обычно B-tree), которая позволяет СУБД быстро находить нужные записи по значению поля без необходимости последовательного сканирования всей таблицы (Full Table Scan).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Индексированное поле остается в той же таблице. Индекс — это отдельная структура (например, B-tree), которая хранится отдельно, но само поле остается частью основной таблицы.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какое условие нужно добавить в секцию ГДЕ запроса, чтобы отобрать только контрагентов с видом 'Поставщик' из справочника Контрагенты?",
              "correct_answer": "ГДЕ Контрагенты.ВидКонтрагента = &ВидКонтрагента, где параметру присвоено значение перечисления или элемента справочника 'Поставщик'.",
              "var_1": "ГДЕ Контрагенты.Наименование ПОДОБНО \"%Поставщик%\", так как вид контрагента определяется по вхождению текста в название элемента справочника.",
              "var_2": "ГДЕ Контрагенты.ВидКонтрагента = &ВидКонтрагента, где параметру присвоено значение перечисления или элемента справочника 'Поставщик'.",
              "var_3": "ГДЕ Контрагенты.Поставщик = Истина, используя булевый реквизит справочника Контрагенты.",
              "var_4": "ГДЕ Контрагенты.ВидКонтрагента = \"Поставщик\", указывая значение вида непосредственно строкой в тексте запроса.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Вид контрагента - это отдельный реквизит (перечисление или справочник), а не часть наименования. Поиск по наименованию через ПОДОБНО не связан с реквизитом ВидКонтрагента.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный способ отбора в 1С: использование параметра запроса с присвоением ему значения перечисления или ссылки на элемент справочника. Это типобезопасный и корректный подход.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Хотя в некоторых конфигурациях действительно могут быть булевы реквизиты 'Поставщик' и 'Покупатель', типовой подход - это использование реквизита ВидКонтрагента перечислимого типа, а не отдельных булевых флагов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "В 1С нельзя сравнивать значение перечисления или ссылочного типа напрямую со строкой. ВидКонтрагента - это ссылка на перечисление или справочник, а не строковый тип данных.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Регламентные задания - включение и отключение типовых заданий конфигурации по инструкции",
          "competency": "Навыки работы с консолью заданий 1С",
          "questions": [
            {
              "question": "Почему перед отключением типового регламентного задания необходимо понимать его назначение?",
              "correct_answer": "Отключение может нарушить работу системы, вызвать ошибки или потерю данных",
              "var_1": "Понимание назначения нужно только для отчёта руководству о проделанной работе с системой",
              "var_2": "Это требование платформы 1С для обеспечения документирования всех изменений в конфигурации",
              "var_3": "Отключение может нарушить работу системы, вызвать ошибки или потерю данных",
              "var_4": "Без понимания задания невозможно найти его в списке консоли",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Понимание назначения регламентного задания нужно для безопасной работы системы, а не только для отчётности руководству.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Платформа 1С не требует обязательного документирования изменений регламентных заданий. Это организационное требование, а не техническое.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Типовые регламентные задания выполняют критически важные функции (обмен данными, очистка, расчёты). Их отключение без понимания последствий может привести к сбоям, ошибкам или потере данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Регламентные задания можно найти в консоли по имени, расписанию или другим атрибутам независимо от понимания их назначения.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какое действие необходимо выполнить в консоли заданий 1С, чтобы временно отключить типовое регламентное задание обмена данными перед обновлением конфигурации?",
              "correct_answer": "Снять флажок 'Включено' у соответствующего регламентного задания в списке консоли заданий или в карточке задания.",
              "var_1": "Снять флажок 'Включено' у соответствующего регламентного задания в списке консоли заданий или в карточке задания.",
              "var_2": "Удалить регламентное задание из списка консоли заданий и создать его заново после обновления.",
              "var_3": "Установить флажок 'Приостановлено' в карточке регламентного задания для временной блокировки выполнения.",
              "var_4": "Изменить расписание задания на дату в далёком будущем, чтобы оно не запускалось при обновлении.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Снятие флажка 'Включено' - это стандартный и правильный способ временного отключения регламентного задания в 1С. Это действие выполняется через консоль заданий и полностью останавливает выполнение задания до его повторного включения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Удаление типового регламентного задания - это избыточное и опасное действие. Типовые задания могут потерять настройки, и их пересоздание может привести к ошибкам. Для временного отключения удаление не требуется.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "В консоли заданий 1С не существует флажка 'Приостановлено'. Это несуществующий элемент интерфейса. Для отключения используется флажок 'Включено', который нужно снять.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Изменение расписания на будущую дату - это обходной путь, но не стандартный и не рекомендуемый способ отключения регламентного задания. Такой подход усложняет управление и может привести к забыванию о задании.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Конструктор запросов 1С - настройка простых условий отбора по реквизитам документов и справочников",
          "competency": "Навыки работы с конструктором запросов 1С",
          "questions": [
            {
              "question": "Почему в конструкторе запросов условие отбора по реквизиту ссылочного типа требует сравнения именно со ссылкой, а не с представлением?",
              "correct_answer": "Потому что в базе данных хранятся ссылки как уникальные идентификаторы, а представление вычисляется динамически и не индексируется",
              "var_1": "Потому что в базе данных хранятся ссылки как уникальные идентификаторы, а представление вычисляется динамически и не индексируется",
              "var_2": "Потому что конструктор запросов поддерживает только примитивные типы данных для сравнения, а представление относится к составному типу данных",
              "var_3": "Потому что представление содержит форматированный текст с пробелами и спецсимволами, что делает невозможным точное сравнение строк в условиях отбора",
              "var_4": "Потому что ссылка автоматически преобразуется в представление при выводе результата, а обратное преобразование представления в ссылку невозможно",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Верно. В базе данных ссылочные типы хранятся как уникальные идентификаторы (GUID), индексируются и обеспечивают быстрый поиск. Представление - это вычисляемое строковое значение, которое формируется динамически и не хранится в таблице базы данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Неверно. Конструктор запросов поддерживает сравнение ссылочных типов данных, которые не являются примитивными. Представление - это обычная строка (примитивный тип), а не составной тип. Утверждение противоречит реальной работе платформы 1С.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Неверно. Представление - это обычная строка, и технически сравнение строк в запросах возможно. Проблема не в спецсимволах или пробелах, а в том, что представление не хранится в базе данных и не индексируется, что делает такое сравнение неэффективным и логически некорректным.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Неверно. Хотя ссылка действительно преобразуется в представление при выводе, основная причина не в этом. Дело в том, что в базе хранятся именно ссылки, а не представления. Кроме того, преобразование представления в ссылку технически возможно через поиск, но неэффективно.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какое условие нужно задать в конструкторе запросов для отбора документов Реализация с суммой больше 100000?",
              "correct_answer": "На вкладке Условия добавить реквизит Сумма, выбрать оператор сравнения Больше и указать значение 100000.",
              "var_1": "На вкладке Условия добавить реквизит Сумма, выбрать оператор сравнения Больше и указать значение 100000.",
              "var_2": "В секции Дополнительно задать ограничение по сумме документа с параметром Больше 100000 рублей.",
              "var_3": "На вкладке Таблицы и поля установить фильтр по реквизиту Сумма со значением 100000.",
              "var_4": "На вкладке Условия добавить реквизит Сумма, выбрать оператор Равно и указать значение больше 100000.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный способ: на вкладке Условия нужно добавить реквизит Сумма, выбрать оператор сравнения 'Больше' и указать значение 100000.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "В конструкторе запросов нет секции 'Дополнительно' для задания ограничений. Условия отбора задаются на вкладке 'Условия', а не в какой-то отдельной секции.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Вкладка 'Таблицы и поля' предназначена для выбора таблиц и полей запроса, а не для настройки условий отбора. Условия отбора настраиваются на вкладке 'Условия'.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Указан оператор 'Равно', который не подходит для условия 'больше'. Кроме того, фраза 'значение больше 100000' противоречива - при операторе 'Равно' указывается конкретное значение, а не диапазон.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Длительные операции - реализация фонового выполнения обработок с индикацией прогресса",
          "competency": "Работа с очередью и фоновыми заданиями 1С",
          "questions": [
            {
              "question": "Почему для передачи результата длительной операции используется временное хранилище, а не прямое обращение к фоновому заданию?",
              "correct_answer": "Фоновое задание выполняется в отдельном сеансе, прямой доступ невозможен",
              "var_1": "Прямое обращение к фоновому заданию блокирует его выполнение до завершения основного потока",
              "var_2": "Фоновое задание выполняется в отдельном сеансе, прямой доступ невозможен",
              "var_3": "Временное хранилище работает быстрее чем прямой доступ к данным",
              "var_4": "Временное хранилище автоматически очищается системой, что предотвращает утечки памяти при ошибках",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Прямое обращение к фоновому заданию не блокирует его выполнение. Проблема в другом - фоновое задание работает в отдельном сеансе, и прямой доступ к его данным невозможен из-за изоляции сеансов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это корректный ответ. Фоновое задание выполняется в отдельном изолированном сеансе 1С, поэтому прямой доступ к его данным из основного сеанса технически невозможен. Временное хранилище решает эту проблему, предоставляя механизм передачи данных между сеансами.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Скорость работы не является причиной использования временного хранилища. Временное хранилище используется из-за технической невозможности прямого обмена данными между изолированными сеансами.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Хотя временное хранилище действительно автоматически очищается, это не является основной причиной его использования для передачи результатов. Главная причина - невозможность прямого доступа между сеансами.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую процедуру следует вызвать для передачи текущего значения прогресса пользователю при выполнении длительной операции?",
              "correct_answer": "ДлительныеОперации.СообщитьПрогресс() с указанием процента выполнения и текста сообщения.",
              "var_1": "ДлительныеОперации.СообщитьПрогресс() с указанием процента выполнения и текста сообщения.",
              "var_2": "Состояние() работает только на сервере и не передает прогресс клиенту при фоновом выполнении.",
              "var_3": "ФоновыеЗадания.ОбновитьПрогресс() с процентом выполнения.",
              "var_4": "ОбщегоНазначения.СообщитьПользователю() с передачей процента и текста для отображения индикатора выполнения.",
              "correct_position": 1,
              "fixes_applied": 1,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "ДлительныеОперации.СообщитьПрогресс() - это стандартная процедура платформы 1С для передачи текущего значения прогресса при выполнении длительной операции. Принимает процент выполнения и текст сообщения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Состояние() - это процедура глобального контекста, которая также может использоваться для отображения прогресса выполнения операции с процентом и текстом сообщения, особенно в интерактивном режиме.",
                "was_replaced": true,
                "original_before_fix": "Состояние() с указанием процента выполнения и текста сообщения о прогрессе."
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Процедура ФоновыеЗадания.ОбновитьПрогресс() не существует в платформе 1С. ФоновыеЗадания - это подсистема для управления фоновыми заданиями, но не для передачи прогресса пользователю.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "ОбщегоНазначения.СообщитьПользователю() используется для вывода текстовых сообщений пользователю, но не предназначена для отображения прогресса выполнения длительных операций с процентами и индикатором.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        }
      ]
    },
    "middle": {
      "themes": [
        {
          "theme": "Интеграция через HTTP-сервисы - обработка JSON и реализация обмена данными с REST API",
          "competency": "Базовая теория 1С программирования",
          "questions": [
            {
              "question": "Почему при сериализации объекта 1С в JSON рекомендуется явно указывать состав выгружаемых полей?",
              "correct_answer": "Для контроля структуры данных и исключения циклических ссылок.",
              "var_1": "Для замедления сериализации путём детального контроля каждого поля объекта.",
              "var_2": "Для контроля структуры данных и исключения циклических ссылок.",
              "var_3": "Для автоматического определения типов данных и совместимости с различными версиями платформы.",
              "var_4": "Для соответствия стандартам формата JSON.",
              "correct_position": 2,
              "fixes_applied": 1,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Верно. Явное указание полей позволяет исключить ненужные свойства объекта из сериализации, уменьшая объём данных и ускоряя процесс передачи и обработки.",
                "was_replaced": true,
                "original_before_fix": "Для ускорения процесса сериализации за счёт уменьшения объёма передаваемых данных."
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это верный ответ. Явное указание полей позволяет контролировать структуру выгружаемых данных и избежать циклических ссылок, которые могут возникнуть при автоматической сериализации сложных объектов со взаимными ссылками.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Явное указание полей не влияет на автоматическое определение типов. Типы определяются платформой независимо от того, указаны поля явно или нет.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Формат JSON не требует явного указания полей при сериализации. Это технический аспект реализации в 1С, не связанный со стандартами JSON.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой метод объекта HTTPСоединение следует использовать для отправки POST-запроса с JSON-телом к внешнему REST API?",
              "correct_answer": "Метод ОтправитьДляОбработки() или ВызватьHTTPМетод() с параметром POST, передавая тело запроса через объект HTTPЗапрос с установленным заголовком Content-Type: application/json.",
              "var_1": "Метод Получить() с параметром ТелоЗапроса, где JSON автоматически преобразуется в строку при передаче через объект HTTPЗапрос.",
              "var_2": "Метод ЗаписатьДанные() объекта HTTPСоединение с указанием формата JSON в параметрах метода, тело запроса передается как структура.",
              "var_3": "Метод ОтправитьДляОбработки() или ВызватьHTTPМетод() с параметром POST, передавая тело запроса через объект HTTPЗапрос с установленным заголовком Content-Type: application/json.",
              "var_4": "Метод ОтправитьЗапрос() с автоматическим определением типа контента по расширению файла, заголовок Content-Type устанавливается системой.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Метод Получить() используется для GET-запросов, а не POST. Он не предназначен для отправки данных в теле запроса и не поддерживает параметр ТелоЗапроса",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Метод ЗаписатьДанные() не существует в объекте HTTPСоединение. Это выдуманный метод. Для POST-запросов используется ОтправитьДляОбработки() или ВызватьHTTPМетод()",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Метод ОтправитьДляОбработки() с параметром 'POST' является корректным способом отправки POST-запроса. HTTPЗапрос позволяет установить тело запроса и заголовок Content-Type: application/json",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Метод ОтправитьЗапрос() не существует в HTTPСоединение. Кроме того, Content-Type не определяется автоматически по расширению файла при работе с JSON - его нужно устанавливать явно",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Типизация исключений в 1С - анализ типов ошибок и дифференцированная обработка",
          "competency": "Блок применения попытки/исключения 1С",
          "questions": [
            {
              "question": "Почему в 1С невозможно реализовать типизированную обработку исключений с разными блоками catch для разных типов ошибок?",
              "correct_answer": "Нет разных классов исключений, только один объект ИнформацияОбОшибке()",
              "var_1": "Нет разных классов исключений, только один объект ИнформацияОбОшибке()",
              "var_2": "Платформа поддерживает типизацию, но разработчики редко используют эту возможность из-за сложности",
              "var_3": "Типизированные исключения доступны только в серверном контексте выполнения кода, не на клиенте",
              "var_4": "Множественные блоки Исключение существуют, но работают только в расширениях конфигурации",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это верный ответ. В 1С существует только один универсальный объект ИнформацияОбОшибке(), который содержит информацию о любой ошибке. Нет иерархии классов исключений, поэтому невозможно различать типы ошибок на уровне синтаксиса языка",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Платформа 1С вообще не поддерживает типизацию исключений. Нет разных классов ошибок и нет возможности создавать множественные блоки catch для разных типов",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Типизированные исключения недоступны ни в серверном, ни в клиентском контексте. Механизм обработки ошибок одинаков везде - только ИнформацияОбОшибке() без типизации",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "В 1С нет множественных блоков Исключение ни в расширениях, ни в обычной конфигурации. Существует только один блок Исключение для конструкции Попытка...Исключение...КонецПопытки",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой метод анализа текста ОписаниеОшибки() позволяет определить тип ошибки и выполнить дифференцированную обработку в блоке Исключение?",
              "correct_answer": "Использование функции Найти() или СтрНайти() для поиска ключевых подстрок в тексте ошибки, например 'Нарушение целостности', 'Таймаут', 'Блокировка'.",
              "var_1": "Использование метода ТипЗнч() для определения класса исключения и последующего ветвления обработки по типу объекта ошибки.",
              "var_2": "Вызов метода ИнформацияОбОшибке().Тип для получения перечисления с категорией ошибки и дифференцированной обработки.",
              "var_3": "Использование функции Найти() или СтрНайти() для поиска ключевых подстрок в тексте ошибки, например 'Нарушение целостности', 'Таймаут', 'Блокировка'.",
              "var_4": "Применение функции КодОшибки() которая возвращает числовой идентификатор исключения для выбора нужной ветки обработки.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "В 1С в блоке Исключение переменная содержит строковое описание ошибки, а не объект исключения. ТипЗнч() вернет Тип('Строка'), что не позволяет дифференцировать типы ошибок. В 1С нет объектной модели исключений с разными классами.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "В 1С не существует метода ИнформацияОбОшибке().Тип. Функция ИнформацияОбОшибке() возвращает структуру с полями Описание, Модуль, НомерСтроки и др., но не имеет поля Тип с перечислением категорий ошибок.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это корректный и наиболее распространенный метод анализа типа ошибки в 1С. Поскольку платформа не предоставляет встроенной типизации исключений, разработчики используют текстовый анализ ОписаниеОшибки() с помощью функций Найти() или СтрНайти() для поиска характерных подстрок и определения типа ошибки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "В 1С не существует встроенной функции КодОшибки(). Платформа 1С не предоставляет числовых идентификаторов исключений для их классификации. Доступна только текстовая информация через ОписаниеОшибки() и ИнформацияОбОшибке().",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Программные ограничения на уровне объектов - реализация событийных обработчиков для контроля доступа к записям регистров и справочников",
          "competency": "Права и роли в 1С",
          "questions": [
            {
              "question": "Почему для контроля доступа к записям регистров используется обработчик ПередЗаписью, а не ПриЗаписи?",
              "correct_answer": "ПередЗаписью позволяет отменить запись через Отказ до фиксации в БД",
              "var_1": "ПриЗаписи не поддерживается для регистров",
              "var_2": "ПередЗаписью выполняется в транзакции, а ПриЗаписи вне её",
              "var_3": "ПередЗаписью позволяет отменить запись через Отказ до фиксации в БД",
              "var_4": "ПриЗаписи используется только для интерактивной записи, а ПередЗаписью для программной",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Событие ПриЗаписи поддерживается для регистров в 1С. Существуют оба события: ПередЗаписью и ПриЗаписи для модулей менеджеров регистров.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Оба события ПередЗаписью и ПриЗаписи выполняются внутри транзакции. ПриЗаписи вызывается после физической записи в БД, но до фиксации транзакции, а не вне её.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. ПередЗаписью позволяет установить параметр Отказ = Истина и прервать операцию записи до её фактического выполнения в базе данных, что критично для контроля доступа.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Оба события (ПередЗаписью и ПриЗаписи) вызываются как при интерактивной, так и при программной записи. Разделения по типу записи не существует.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой обработчик модуля регистра сведений следует использовать для программной проверки прав текущего пользователя перед записью набора записей?",
              "correct_answer": "Обработчик ПередЗаписью модуля набора записей, где через параметр Отказ можно отменить запись при отсутствии необходимых прав у пользователя.",
              "var_1": "Обработчик ПередУдалением модуля набора записей регистра сведений, который универсально применяется для всех операций изменения данных включая запись новых записей.",
              "var_2": "Обработчик ПередЗаписью модуля набора записей, где через параметр Отказ можно отменить запись при отсутствии необходимых прав у пользователя.",
              "var_3": "Обработчик ПриЗаписи модуля набора записей, который вызывается после фактической записи данных и позволяет проанализировать результат операции для последующего контроля доступа.",
              "var_4": "Обработчик ОбработкаПроверкиЗаполнения модуля регистра сведений, где можно добавить проверку прав доступа пользователя и вернуть ошибку через массив НепроверяемыеРеквизиты.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "ПередУдалением вызывается только при удалении записей, а не при любых операциях изменения. Для проверки прав перед записью используется ПередЗаписью.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "ПередЗаписью модуля набора записей - правильный обработчик для проверки прав перед записью. Параметр Отказ=Истина позволяет предотвратить запись при недостаточных правах пользователя.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "ПриЗаписи вызывается после записи в базу данных, когда данные уже изменены. Для контроля доступа нужен обработчик ПЕРЕДзаписью, чтобы можно было отменить операцию.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "ОбработкаПроверкиЗаполнения предназначен для контроля корректности заполнения реквизитов, а не для проверки прав доступа. НепроверяемыеРеквизиты используется для исключения полей из проверки, а не для возврата ошибок.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Паттерны организации кода обработок - разделение ответственности между модулями объекта и модулем менеджера",
          "competency": "Понимание модульности и архитектуры кода 1С",
          "questions": [
            {
              "question": "Почему методы создания и поиска элементов справочника следует размещать в модуле менеджера, а не в модуле объекта?",
              "correct_answer": "Модуль менеджера работает с коллекцией объектов без создания экземпляра, а модуль объекта требует предварительного получения конкретного объекта",
              "var_1": "Модуль менеджера имеет доступ к базе данных напрямую, а модуль объекта работает только через буфер в оперативной памяти",
              "var_2": "Модуль объекта предназначен только для обработки событий записи, а вся бизнес-логика должна быть в модуле менеджера",
              "var_3": "Модуль менеджера работает с коллекцией объектов без создания экземпляра, а модуль объекта требует предварительного получения конкретного объекта",
              "var_4": "Модуль менеджера компилируется на сервере, а модуль объекта на клиенте, поэтому поиск работает быстрее",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Оба модуля имеют доступ к базе данных. Разница не в способе доступа к БД, а в том, что модуль менеджера работает без инстанцирования объекта, а модуль объекта - с конкретным экземпляром",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Модуль объекта не предназначен ТОЛЬКО для событий записи - в нём размещаются методы работы с конкретным экземпляром. Бизнес-логика распределяется между модулями в зависимости от назначения, а не концентрируется только в менеджере",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение. Модуль менеджера предназначен для операций с множеством объектов (поиск, создание) без необходимости получения конкретного экземпляра. Модуль объекта работает с уже существующим экземпляром объекта",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Оба модуля (и менеджера, и объекта) компилируются и выполняются на сервере. Модули формы могут быть клиентскими/серверными, но это не относится к модулям объекта и менеджера справочников",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой модуль обработки следует выбрать для размещения метода получения списка доступных вариантов отчёта без создания экземпляра объекта?",
              "correct_answer": "Модуль менеджера, поскольку он позволяет вызывать методы напрямую через имя обработки без создания экземпляра, что экономит ресурсы и упрощает обращение к общей функциональности.",
              "var_1": "Модуль объекта, так как список вариантов отчёта является свойством конкретного экземпляра обработки, и только через создание объекта можно получить доступ к его внутренним данным и корректно инициализировать все необходимые параметры отчёта.",
              "var_2": "Модуль формы обработки, потому что варианты отчёта связаны с интерфейсом пользователя и должны формироваться в контексте клиентского приложения.",
              "var_3": "Общий модуль с директивой компиляции сервер, поскольку это позволяет централизовать логику получения вариантов отчёта и обеспечивает доступ из любых модулей конфигурации без привязки к конкретной обработке.",
              "var_4": "Модуль менеджера, поскольку он позволяет вызывать методы напрямую через имя обработки без создания экземпляра, что экономит ресурсы и упрощает обращение к общей функциональности.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Модуль объекта требует создания экземпляра обработки, что противоречит условию задачи. Для получения списка вариантов без создания экземпляра используется модуль менеджера.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Модуль формы отвечает за логику конкретной формы и её интерфейс. Получение списка вариантов — это серверная бизнес-логика, не привязанная к форме. Также не подходит по условию задачи.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Общий модуль не является частью структуры обработки. Вопрос явно спрашивает про модуль обработки. Хотя это возможное решение, оно выходит за рамки архитектуры самой обработки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Модуль менеджера предназначен именно для размещения методов, доступных без создания экземпляра объекта. Вызов идет напрямую через имя обработки, что соответствует принципу разделения ответственности.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Архитектура расширений 1С - организация бизнес-логики в объектных модулях и обработчиках событий",
          "competency": "Знание работы с расширениями в 1С",
          "questions": [
            {
              "question": "Почему при перехвате события модуля объекта в расширении важно учитывать порядок вызова аннотаций &Перед и &После?",
              "correct_answer": "Определяют момент выполнения относительно базы и других расширений",
              "var_1": "Задают приоритет транзакций между модулями объекта",
              "var_2": "Влияют на производительность обработки события",
              "var_3": "Определяют права доступа к данным в момент вызова",
              "var_4": "Определяют момент выполнения относительно базы и других расширений",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Аннотации &Перед и &После не управляют приоритетами транзакций. Транзакции в 1С управляются через методы НачатьТранзакцию/ЗафиксироватьТранзакцию, а порядок аннотаций определяет момент выполнения кода относительно базы.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Хотя порядок вызова может косвенно влиять на производительность, это не является основной причиной важности учета аннотаций. Главное - это логика выполнения кода относительно базовой конфигурации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Аннотации &Перед и &После не связаны с правами доступа. Права доступа настраиваются через механизм ролей и RLS, а не через порядок вызова обработчиков событий в расширениях.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это верный ответ. Аннотации &Перед и &После определяют момент выполнения кода расширения относительно базовой конфигурации и других расширений. &Перед выполняется до базового кода, &После - после него. Порядок важен для корректной работы бизнес-логики.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой способ организации бизнес-логики в расширении следует выбрать для перехвата записи документа с возможностью отмены транзакции?",
              "correct_answer": "Использовать аннотацию &Перед для обработчика ПередЗаписью в модуле объекта расширения с установкой параметра Отказ=Истина.",
              "var_1": "Использовать обработчик ОбработкаПроведения в модуле менеджера расширения с установкой параметра Отказ=Истина.",
              "var_2": "Использовать аннотацию &Перед для обработчика ПередЗаписью в модуле объекта расширения с установкой параметра Отказ=Истина.",
              "var_3": "Использовать аннотацию &Вместо для обработчика ПередЗаписью с вызовом ПродолжитьВызов() при успешной проверке.",
              "var_4": "Использовать аннотацию &После для обработчика ПриЗаписи в модуле объекта с проверкой условий отмены.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "ОбработкаПроведения относится только к проведению документа, а не к записи в целом. Модуль менеджера в расширениях не используется для перехвата событий объектов - для этого используются аннотации в модуле объекта расширения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный способ: аннотация &Перед для обработчика ПередЗаписью в модуле объекта расширения позволяет выполнить дополнительные проверки до записи и отменить операцию через параметр Отказ=Истина, что прервёт транзакцию.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Аннотация &Вместо полностью заменяет базовую логику и не предназначена для расширения функциональности с возможностью отмены. ПродолжитьВызов() используется для передачи управления базовому коду, но это не подходит для перехвата с отменой транзакции.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Аннотация &После выполняется после завершения базового события, когда транзакция уже может быть зафиксирована. ПриЗаписи также происходит после записи, что делает невозможным отмену транзакции через параметр Отказ.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Оптимизация избыточного логирования - выявление узких мест и балансировка детализации с нагрузкой на систему",
          "competency": "Навыки работы с журналом регистрации и логированием 1С",
          "questions": [
            {
              "question": "Почему избыточная детализация журнала регистрации снижает производительность рабочих серверов кластера 1С?",
              "correct_answer": "Дисковые операции, синхронизация доступа, нагрузка на CPU и память.",
              "var_1": "Дисковые операции, синхронизация доступа, нагрузка на CPU и память.",
              "var_2": "Каждая запись журнала требует блокировки базы данных и ожидания подтверждения транзакции.",
              "var_3": "Журнал регистрации занимает место в оперативной памяти сервера и замедляет сетевое взаимодействие.",
              "var_4": "Логирование влияет только на клиентские сеансы пользователей.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Избыточное логирование создает множественные дисковые I/O операции записи, требует синхронизации доступа к файлам журнала от разных процессов rphost, потребляет CPU на формирование записей и память на буферизацию.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Запись в журнал регистрации 1С не требует блокировки базы данных и не использует механизм транзакций СУБД. Журнал пишется в файловую систему независимо от транзакций базы данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Журнал регистрации 1С хранится в файлах на диске (каталог log), а не в оперативной памяти сервера. Основная проблема связана с дисковыми операциями записи, а не с занятием RAM или сетевым взаимодействием.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Логирование влияет на серверные процессы (rphost, ragent), а не только на клиентские сеансы. Журнал регистрации ведется на стороне сервера и нагружает именно серверную инфраструктуру кластера 1С.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой параметр настройки журнала регистрации следует изменить в первую очередь, если обнаружено замедление работы базы из-за записи событий типа 'Данные'?",
              "correct_answer": "Следует отключить события типа 'Данные' (_ДанныеЗапись, _ДанныеЧтение), так как они создают максимальную нагрузку на систему.",
              "var_1": "Следует отключить события типа 'Данные' (_ДанныеЗапись, _ДанныеЧтение), так как они создают максимальную нагрузку на систему.",
              "var_2": "Следует перенести файл журнала регистрации на SSD-диск, сохранив логирование событий 'Данные' для полноты аудиторской истории.",
              "var_3": "Следует отключить все события кроме 'Данные', так как они являются основными для мониторинга и их запись оптимизирована платформой 1С.",
              "var_4": "Следует увеличить периодичность разделения журнала регистрации на файлы, чтобы снизить количество операций записи и повысить производительность системы.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "События типа 'Данные' (_ДанныеЗапись, _ДанныеЧтение) действительно создают максимальную нагрузку на систему, так как генерируют огромное количество записей при любых операциях с данными. Их отключение - первоочередная мера оптимизации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Хотя перенос на SSD улучшит производительность записи, это не решает проблему избыточного логирования событий 'Данные'. Это паллиативная мера, а не устранение причины. Первоочередно нужно отключить избыточное логирование.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Это перевёрнутая логика. События 'Данные' как раз НЕ оптимизированы и создают максимальную нагрузку. Отключение всех других событий и оставление только 'Данные' усугубит проблему производительности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Изменение периодичности разделения журнала на файлы не влияет существенно на производительность записи событий. Проблема в количестве записываемых событий 'Данные', а не в частоте создания новых файлов журнала.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Уровни блокировок в 1С - применение управляемых и автоматических блокировок для обеспечения консистентности данных в многопользовательском режиме",
          "competency": "Знание работы транзакций в 1С",
          "questions": [
            {
              "question": "Почему управляемые блокировки обеспечивают более высокую параллельность работы пользователей по сравнению с автоматическими?",
              "correct_answer": "Управляемые блокировки позволяют разработчику точно указать блокируемые данные и момент блокировки, минимизируя время и область захвата ресурсов",
              "var_1": "Управляемые блокировки позволяют разработчику точно указать блокируемые данные и момент блокировки, минимизируя время и область захвата ресурсов",
              "var_2": "Управляемые блокировки работают на уровне СУБД, что делает их более производительными по сравнению с программными автоматическими блокировками",
              "var_3": "Управляемые блокировки автоматически распределяют нагрузку между пользователями и используют очередь ожидания, что исключает взаимные блокировки и повышает пропускную способность",
              "var_4": "Управляемые блокировки используют оптимистичную стратегию и проверяют конфликты только при записи данных",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Управляемые блокировки позволяют разработчику явно указать, какие именно записи блокировать и когда это делать, в отличие от автоматических, которые блокируют все изменяемые данные на момент начала транзакции. Это сокращает время удержания блокировок и уменьшает область конфликтов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "И управляемые, и автоматические блокировки работают на уровне СУБД. Разница не в уровне работы, а в механизме: автоматические блокируют все данные транзакции автоматически, управляемые - только явно указанные разработчиком объекты.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Управляемые блокировки НЕ распределяют нагрузку автоматически и НЕ исключают взаимные блокировки (deadlock). Они требуют ручного управления разработчиком. Очередь ожидания есть у обоих типов блокировок, и взаимные блокировки возможны при неправильном проектировании.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Управляемые блокировки в 1С используют пессимистичную стратегию (явная блокировка перед изменением), а не оптимистичную. Оптимистичная стратегия подразумевает проверку конфликтов только при записи, что к управляемым блокировкам не относится.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой тип управляемой блокировки следует установить на остатки товара при проведении документа расхода, чтобы предотвратить списание в минус при параллельной работе пользователей?",
              "correct_answer": "Исключительную блокировку на записи регистра остатков по конкретной номенклатуре и складу через объект БлокировкаДанных перед проверкой остатков и записью движений.",
              "var_1": "Исключительную блокировку всей таблицы регистра накопления через метод Заблокировать() объекта РегистрНакопленияМенеджер.",
              "var_2": "Исключительную блокировку на записи регистра остатков по конкретной номенклатуре и складу через объект БлокировкаДанных перед проверкой остатков и записью движений.",
              "var_3": "Автоматическую блокировку СУБД на уровне записей таблицы регистра, которая устанавливается платформой при записи движений документа.",
              "var_4": "Разделяемую блокировку на весь регистр остатков через объект БлокировкаДанных, чтобы другие пользователи могли читать данные, но не могли изменять их до завершения текущей транзакции.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Блокировка всей таблицы регистра избыточна и создаст проблемы производительности - заблокируются все товары и склады, хотя документ работает только с конкретными позициями. Кроме того, метод Заблокировать() у менеджера регистра не является стандартным механизмом управляемых блокировок.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Исключительная блокировка через БлокировкаДанных на конкретные записи регистра (по измерениям: номенклатура, склад) перед проверкой остатков - это правильный подход. Она блокирует только нужные записи, предотвращает параллельное изменение остатков другими транзакциями и обеспечивает консистентность данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Автоматические блокировки СУБД устанавливаются слишком поздно - в момент записи движений, когда проверка остатков уже выполнена. Между проверкой и записью другая транзакция может изменить остатки, что приведет к списанию в минус.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Разделяемая блокировка позволяет другим транзакциям также устанавливать разделяемые блокировки и изменять данные. Для предотвращения списания в минус нужна исключительная блокировка, которая запретит другим транзакциям изменять данные до завершения текущей.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Пагинация и потоковая обработка - оптимизация работы с большими объемами данных через ЧтениеДанных и поблочную загрузку JSON",
          "competency": "Принципы работы http запросов 1С",
          "questions": [
            {
              "question": "Почему при обработке больших JSON-ответов через HTTP предпочтительнее использовать ЧтениеJSON с потоком вместо загрузки всего ответа в строку?",
              "correct_answer": "Потоковая обработка не загружает весь объём в память",
              "var_1": "Поток позволяет распараллелить обработку данных на несколько потоков",
              "var_2": "Потоковая обработка не загружает весь объём в память",
              "var_3": "Строковое чтение не поддерживает кодировку UTF-8",
              "var_4": "ЧтениеJSON автоматически разбивает ответ на страницы и выполняет пагинацию",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "ЧтениеJSON с потоком работает в одном потоке последовательно, не распараллеливает обработку. Речь идёт о потоке данных (stream), а не о потоках выполнения (threads)",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это основное преимущество потоковой обработки - данные читаются и обрабатываются порциями, не загружая весь JSON целиком в память, что критично для больших объёмов",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Строковое чтение в 1С полностью поддерживает UTF-8 и другие кодировки. Проблема не в кодировке, а в объёме памяти при загрузке всей строки",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "ЧтениеJSON не выполняет автоматическую пагинацию - это ответственность разработчика и API. ЧтениеJSON только последовательно парсит JSON-структуру",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой подход следует использовать для обработки JSON-ответа размером 500 МБ от REST-сервиса, чтобы избежать переполнения памяти?",
              "correct_answer": "Использовать пагинацию API для получения данных порциями, обрабатывая каждую страницу отдельно через ПрочитатьJSON.",
              "var_1": "Использовать пагинацию API для получения данных порциями, обрабатывая каждую страницу отдельно через ПрочитатьJSON.",
              "var_2": "Использовать ЗаписьТекста для сохранения в файл, затем загрузить весь файл через ПрочитатьJSON в память.",
              "var_3": "Увеличить размер буфера HTTP-соединения и таймаут запроса для полной загрузки большого ответа.",
              "var_4": "Загрузить весь JSON-ответ в оперативную память через ПрочитатьJSON, затем использовать сборщик мусора для освобождения памяти после обработки.",
              "correct_position": 1,
              "fixes_applied": 1,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Пагинация API - правильный подход для обработки больших объемов данных. Получение данных порциями (страницами) позволяет обрабатывать каждую часть отдельно, избегая загрузки всего 500 МБ ответа в память одновременно.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Сохранение ответа в файл и последующая потоковая обработка через ЧтениеТекста - валидный подход для работы с большими данными. Позволяет обрабатывать данные порциями, не загружая весь объем в память.",
                "was_replaced": true,
                "original_before_fix": "Использовать ЗаписьТекста для сохранения ответа в файл, а затем обрабатывать его через ЧтениеТекста построчно."
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Увеличение буфера и таймаута не решает проблему переполнения памяти. Это лишь позволит дождаться загрузки большого файла, но все 500 МБ все равно окажутся в памяти, что и является проблемой.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Загрузка всего 500 МБ JSON в память через ПрочитатьJSON как раз и приведет к переполнению памяти. Сборщик мусора работает после обработки, но не помогает во время загрузки большого объема данных.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Кэширование данных - проектирование механизмов хранения и инвалидации кэша справочной информации в общих модулях",
          "competency": "Общие модули 1С",
          "questions": [
            {
              "question": "Почему для кэширования часто изменяемой справочной информации рекомендуется использовать параметр 'НаВремяВызова', а не 'НаВремяСеанса'?",
              "correct_answer": "Чтобы избежать работы с устаревшими данными в течение сеанса.",
              "var_1": "Для уменьшения нагрузки на сервер за счёт повторного использования кэша",
              "var_2": "Чтобы избежать работы с устаревшими данными в течение сеанса.",
              "var_3": "Для ускорения повторных вызовов модуля",
              "var_4": "Для экономии оперативной памяти на клиентской части",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "'НаВремяВызова' наоборот УВЕЛИЧИВАЕТ нагрузку, так как данные не сохраняются между вызовами и требуют повторной загрузки. Для уменьшения нагрузки используется 'НаВремяСеанса', но это не подходит для часто изменяемых данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Параметр 'НаВремяВызова' обеспечивает актуальность данных при каждом вызове модуля, что критично для часто изменяемой информации. 'НаВремяСеанса' сохраняет данные на весь сеанс, что приводит к работе с устаревшими данными после их изменения в базе.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "'НаВремяВызова' не ускоряет повторные вызовы, а наоборот - данные не кэшируются между вызовами. Для ускорения повторных вызовов используется 'НаВремяСеанса', но это создаёт проблему с актуальностью данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Вопрос об экономии памяти на клиенте не является основной причиной выбора 'НаВремяВызова' для часто изменяемых данных. Основная причина - актуальность данных. К тому же, оба параметра работают на сервере в контексте общих модулей.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой способ инвалидации кэша справочной информации в общем модуле с повторным использованием наиболее эффективен при изменении данных справочника?",
              "correct_answer": "Вызов метода ОбновитьПовторноИспользуемыеЗначения() после записи справочника, либо использование версионирования кэша через хранение времени последнего изменения в константе или регистре сведений.",
              "var_1": "Перезапуск серверного процесса rphost для принудительного сброса кэша общих модулей при каждом изменении справочных данных системы.",
              "var_2": "Использование метода ОчиститьПараметрыСеанса() для полного сброса кэшированных данных модуля с повторным использованием, что гарантирует актуальность при следующем обращении к справочнику и автоматически обновляет все связанные данные.",
              "var_3": "Вызов метода ОбновитьПовторноИспользуемыеЗначения() после записи справочника, либо использование версионирования кэша через хранение времени последнего изменения в константе или регистре сведений.",
              "var_4": "Настройка регламентного задания для периодической очистки кэша через ПолучитьПовторноИспользуемоеЗначение() с интервалом 5-10 минут для поддержания актуальности.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Перезапуск rphost при каждом изменении справочника - крайне неэффективное решение, нарушающее работу всех пользователей. Это административная операция, недопустимая для обычной логики приложения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "ОчиститьПараметрыСеанса() очищает только параметры сеанса, но не сбрасывает повторно использумые значения. Кэш модулей с повторным использованием имеет область кластера/сервера, а не сеанса, поэтому этот метод неэффективен для инвалидации кэша.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "ОбновитьПовторноИспользуемыеЗначения() - стандартный механизм инвалидации кэша модулей с повторным использованием. Версионирование через константу/регистр также является эффективным паттерном для контроля актуальности кэша.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Регламентное задание с задержкой 5-10 минут не обеспечивает своевременную актуализацию данных. ПолучитьПовторноИспользуемоеЗначение() - это неправильное название метода (правильно - ПолучитьИзВременногоХранилища или использование кэша через модули).",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Отладка производительности запросов - анализ планов выполнения и оптимизация временных таблиц в сложных отчетах",
          "competency": "Тестирование и отладка в 1С",
          "questions": [
            {
              "question": "Почему использование временных таблиц вместо вложенных запросов часто улучшает производительность сложных отчетов в 1С?",
              "correct_answer": "Временные таблицы материализуют промежуточные результаты, исключая повторные вычисления и позволяя оптимизатору строить эффективные планы соединений",
              "var_1": "Временные таблицы уменьшают нагрузку на сеть, так как данные передаются между клиентом и сервером один раз",
              "var_2": "Временные таблицы материализуют промежуточные результаты, исключая повторные вычисления и позволяя оптимизатору строить эффективные планы соединений",
              "var_3": "Временные таблицы хранятся в оперативной памяти сервера, а вложенные запросы всегда обращаются к диску базы данных",
              "var_4": "Временные таблицы автоматически индексируются платформой 1С по всем полям, что делает любые соединения мгновенными независимо от структуры запроса и объёма данных",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Временные таблицы создаются на стороне СУБД (сервера БД), а не между клиентом и сервером. Сетевая нагрузка зависит от объема итоговых данных, а не от использования временных таблиц vs вложенных запросов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это верный ответ. Временные таблицы материализуют промежуточные результаты один раз, что исключает их повторное вычисление при многократном использовании. Оптимизатор СУБД может построить более эффективный план выполнения, имея статистику по временной таблице.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Временные таблицы не обязательно хранятся в ОЗУ - СУБД решает это сама. Вложенные запросы тоже могут использовать кеш и не всегда обращаются к диску. Это упрощенное и неточное представление работы СУБД.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Платформа 1С не индексирует автоматически все поля временных таблиц. Индексы нужно создавать явно при необходимости. Даже с индексами соединения не становятся 'мгновенными' - их производительность зависит от объема данных и структуры запроса.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой индекс следует добавить во временную таблицу запроса, если план выполнения показывает Table Scan при соединении по полю Номенклатура?",
              "correct_answer": "Необходимо добавить индекс по полю Номенклатура через ИНДЕКСИРОВАТЬ ПО в определении временной таблицы для оптимизации соединения.",
              "var_1": "Table Scan указывает на необходимость добавления составного индекса по всем полям соединения и выборки через конструкцию СГРУППИРОВАТЬ ПО в запросе.",
              "var_2": "Необходимо создать индекс в основной таблице базы данных по полю Номенклатура, так как временные таблицы автоматически наследуют индексы исходных таблиц.",
              "var_3": "Следует использовать УПОРЯДОЧИТЬ ПО Номенклатура в запросе создания временной таблицы, что автоматически создаст оптимальный индекс для соединения.",
              "var_4": "Необходимо добавить индекс по полю Номенклатура через ИНДЕКСИРОВАТЬ ПО в определении временной таблицы для оптимизации соединения.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "СГРУППИРОВАТЬ ПО выполняет агрегацию данных, а не создает индексы. Table Scan указывает на отсутствие индекса, который создается через ИНДЕКСИРОВАТЬ ПО.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Временные таблицы не наследуют индексы из исходных таблиц БД. Индексы на временных таблицах нужно создавать явно через ИНДЕКСИРОВАТЬ ПО.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "УПОРЯДОЧИТЬ ПО выполняет сортировку результата, но не создает индекс на временной таблице. Для индексации нужна конструкция ИНДЕКСИРОВАТЬ ПО.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "ИНДЕКСИРОВАТЬ ПО - правильная конструкция языка запросов 1С для создания индекса на поле временной таблицы, что устранит Table Scan при соединении.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Оптимизация запросов документа - индексы виртуальных таблиц и выборка данных для табличных частей",
          "competency": "Жизненный цикл документа 1С",
          "questions": [
            {
              "question": "Что важно учитывать при выборе между виртуальной таблицей СрезПоследних и вложенным запросом для табличных частей документа?",
              "correct_answer": "Наличие индексов на поля регистра и условия отбора.",
              "var_1": "Тип базы данных и объем оперативной памяти.",
              "var_2": "Версия платформы и режим совместимости.",
              "var_3": "Наличие индексов на поля регистра и условия отбора.",
              "var_4": "Количество полей в структуре регистра.",
              "correct_position": 3,
              "fixes_applied": 2,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Тип регистра (периодический/непериодический) и состав измерений определяют структуру индексов и эффективность СрезПоследних. При большом количестве измерений СрезПоследних может работать медленнее.",
                "was_replaced": true,
                "original_before_fix": "Тип регистра сведений и его измерения."
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Версия платформы и режим совместимости не являются определяющими факторами при выборе между СрезПоследних и вложенным запросом. Важны характеристики данных и структура запроса, а не технические параметры платформы.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Наличие правильных индексов критично для производительности. Если есть индексы по полям отбора, вложенный запрос может быть эффективнее. СрезПоследних требует специфичных индексов по измерениям и периоду.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Количество записей критически влияет на выбор: при большом объеме данных СрезПоследних может быть неэффективен из-за сканирования всех записей, тогда как вложенный запрос с отбором по конкретным значениям работает быстрее.",
                "was_replaced": true,
                "original_before_fix": "Количество записей в регистре."
              }
            },
            {
              "question": "Куда следует передать отбор по номенклатуре при выборке данных из виртуальной таблицы СрезПоследних для заполнения табличной части документа?",
              "correct_answer": "В параметр Условие виртуальной таблицы, чтобы платформа использовала индекс таблицы итогов регистра сведений.",
              "var_1": "В параметры виртуальной таблицы, чтобы ускорить выполнение запроса за счёт кэширования данных.",
              "var_2": "В условие соединения таблиц запроса для корректной работы индексов базы данных.",
              "var_3": "В секцию ГДЕ основного запроса после обращения к виртуальной таблице, это обеспечит более гибкую фильтрацию данных.",
              "var_4": "В параметр Условие виртуальной таблицы, чтобы платформа использовала индекс таблицы итогов регистра сведений.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Параметры виртуальной таблицы СрезПоследних не предназначены для отбора по номенклатуре и не влияют на кэширование данных таким образом.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Условие соединения таблиц не является оптимальным местом для передачи отбора по измерениям регистра при работе с виртуальной таблицей СрезПоследних, это не обеспечивает использование индексов таблицы итогов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Отбор в секции ГДЕ применяется уже после формирования виртуальной таблицы, что не позволяет использовать индексы таблицы итогов и приводит к неоптимальному выполнению запроса.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Параметр Условие виртуальной таблицы СрезПоследних позволяет передать отбор на уровень формирования виртуальной таблицы, что обеспечивает использование индексов таблицы итогов регистра сведений и оптимальную производительность.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Система компоновки данных - оптимизация производительности отчетов через настройки компоновщика",
          "competency": "Основы платформы 1С",
          "questions": [
            {
              "question": "Почему использование параметра в условии отбора СКД гарантирует фильтрацию на уровне СУБД?",
              "correct_answer": "Параметр всегда попадает в запрос, отбор компоновщика - не всегда",
              "var_1": "Отборы компоновщика всегда работают на уровне клиента, а параметры - на сервере",
              "var_2": "Параметры СКД автоматически оптимизируются движком СУБД благодаря индексам таблиц запроса",
              "var_3": "Параметр всегда попадает в запрос, отбор компоновщика - не всегда",
              "var_4": "Параметр преобразуется в хранимую процедуру, которая выполняется на стороне сервера СУБД",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Это неверно. Отборы компоновщика могут работать как на уровне СУБД (если преобразуются в SQL), так и на уровне постобработки. Параметры работают на сервере приложений 1С, а не на клиенте, но это не суть вопроса о фильтрации на уровне СУБД.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Параметры СКД не оптимизируются автоматически движком СУБД. Индексы влияют на производительность, но не на гарантию фильтрации на уровне СУБД. Суть в том, что параметр всегда попадает в SQL-запрос, а не в автоматической оптимизации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это верный ответ. Параметр СКД всегда подставляется в текст SQL-запроса и выполняется на уровне СУБД. Отбор компоновщика может применяться после получения данных (постобработка), если его нельзя преобразовать в условие SQL.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Параметры СКД не преобразуются в хранимые процедуры. Они подставляются как параметры в обычный SQL-запрос. Хранимые процедуры - это отдельный механизм СУБД, не используемый СКД для параметров.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой параметр компоновщика настроек следует использовать для ограничения количества считываемых записей из базы данных при формировании отчёта СКД?",
              "correct_answer": "Параметр Количество в наборе данных запроса, который транслируется в TOP/LIMIT на уровне SQL-запроса к СУБД.",
              "var_1": "Параметр Отбор с условием по количеству строк, применяемый на этапе группировки данных отчёта.",
              "var_2": "Свойство МаксимальноеКоличествоЗаписей в компоновщике, ограничивающее вывод в табличный документ.",
              "var_3": "Параметр ОграничениеВыборки в настройках отчёта, который фильтрует результат после выполнения.",
              "var_4": "Параметр Количество в наборе данных запроса, который транслируется в TOP/LIMIT на уровне SQL-запроса к СУБД.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Отбор применяется для фильтрации данных по условиям, но не ограничивает количество считываемых записей из БД. Он работает после получения данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "МаксимальноеКоличествоЗаписей ограничивает вывод в табличный документ после компоновки, но не ограничивает чтение из БД на уровне SQL.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "ОграничениеВыборки фильтрует результат после выполнения запроса, а не на этапе чтения из БД, поэтому не оптимизирует производительность запроса к СУБД.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Параметр Количество в наборе данных запроса действительно транслируется в TOP/LIMIT на уровне SQL, что ограничивает чтение записей непосредственно из СУБД.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Алгоритмы расчета себестоимости - реализация методов FIFO и средней себестоимости средствами языка запросов с использованием временных таблиц",
          "competency": "Запросы в 1С",
          "questions": [
            {
              "question": "Почему при реализации FIFO через запросы необходимо использовать накопительные итоги во временных таблицах?",
              "correct_answer": "Для определения границ списания каждой партии путём сравнения накопленного остатка с количеством к списанию",
              "var_1": "Для группировки однотипных партий товаров и ускорения выполнения запроса к регистрам накопления",
              "var_2": "Для обеспечения корректной сортировки партий по дате поступления и формирования очереди списания в хронологическом порядке",
              "var_3": "Для автоматического пересчёта себестоимости каждой партии при изменении цен поставщиков в течение периода расчёта",
              "var_4": "Для определения границ списания каждой партии путём сравнения накопленного остатка с количеством к списанию",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Накопительные итоги не используются для группировки или оптимизации производительности. Это аналитический механизм для расчёта нарастающих сумм в рамках упорядоченной выборки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Сортировка партий по дате - это базовая операция ORDER BY, не требующая накопительных итогов. Накопительные итоги нужны для другой цели.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "FIFO работает с уже зафиксированными ценами партий. Накопительные итоги не предназначены для пересчёта цен, они работают с количественными показателями.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Накопительные итоги (running total) позволяют накапливать остатки партий и определять, какая часть каждой партии должна быть списана, сравнивая накопленное количество с требуемым количеством для списания.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую конструкцию языка запросов следует применить для накопительного итога остатков при расчете себестоимости методом FIFO во временной таблице?",
              "correct_answer": "Соединение таблицы самой с собой с условием по дате или вложенный запрос с условием сравнения дат.",
              "var_1": "Конструкция ИТОГИ с группировкой по периоду и агрегатной функцией СУММА.",
              "var_2": "Соединение таблицы самой с собой с условием по дате или вложенный запрос с условием сравнения дат.",
              "var_3": "Использование конструкции ОБЪЕДИНИТЬ ВСЕ с предварительной сортировкой записей по дате.",
              "var_4": "Оконная функция МАКСИМУМ() с ключевым словом РАЗДЕЛИТЬ ПО в секции ВЫБРАТЬ запроса.",
              "correct_position": 2,
              "fixes_applied": 1,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "ИТОГИ используется для построения иерархических группировок и подытогов, но не для расчета накопительного (running total) итога внутри одной группы по строкам в порядке дат.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это устаревший и неэффективный подход. Самосоединение или вложенные запросы с условием по дате создают квадратичную сложность O(n²), что критично для больших объемов данных при расчете себестоимости.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "ОБЪЕДИНИТЬ ВСЕ используется для объединения разных наборов данных в один результат, а не для расчета накопительных итогов. Сортировка не создает накопительного эффекта.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Оконная функция СУММА() УПОРЯДОЧИТЬ ПО дата — это современный и эффективный способ расчета накопительного итога (running total) в 1С, необходимый для FIFO при определении последовательного списания партий по датам поступления.",
                "was_replaced": true,
                "original_before_fix": "Оконная функция СУММА() с ключевым словом УПОРЯДОЧИТЬ ПО в секции ВЫБРАТЬ запроса."
              }
            }
          ]
        },
        {
          "theme": "Временные таблицы - проектирование и отладка многоэтапных запросов для расчета остатков и оборотов",
          "competency": "Навыки работы с консолью запросов 1С",
          "questions": [
            {
              "question": "Почему при расчете остатков рекомендуется размещать результаты промежуточных вычислений во временных таблицах, а не использовать вложенные подзапросы?",
              "correct_answer": "Временные таблицы вычисляются однократно и переиспользуются, подзапросы выполняются заново",
              "var_1": "Подзапросы не поддерживают агрегатные функции для расчета остатков, временные таблицы позволяют их использовать",
              "var_2": "Временные таблицы вычисляются однократно и переиспользуются, подзапросы выполняются заново",
              "var_3": "Временные таблицы автоматически создают индексы для всех полей, что ускоряет соединения, а подзапросы индексов не имеют",
              "var_4": "Временные таблицы хранят данные на сервере СУБД, а подзапросы обрабатываются на стороне клиента 1С",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Подзапросы полностью поддерживают агрегатные функции (СУММА, КОЛИЧЕСТВО и т.д.). Это базовая функциональность SQL, доступная и в подзапросах, и во временных таблицах.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это ключевое преимущество временных таблиц. Они вычисляются один раз и могут многократно использоваться в последующих запросах. Вложенные подзапросы выполняются каждый раз при обращении, что снижает производительность при многократном использовании одних и тех же данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Временные таблицы не создают индексы автоматически для всех полей. Индексы можно создать явно, но это не происходит по умолчанию. Подзапросы также могут использовать индексы базовых таблиц.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Подзапросы также обрабатываются на стороне сервера СУБД, а не на клиенте. Весь запрос, включая вложенные подзапросы, выполняется на сервере базы данных.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой механизм временных таблиц следует использовать для передачи промежуточных результатов расчета остатков между несколькими последовательными запросами в пакете?",
              "correct_answer": "Менеджер временных таблиц, создаваемый через объект МенеджерВременныхТаблиц и передаваемый в свойство Запрос.МенеджерВременныхТаблиц для всех запросов пакета.",
              "var_1": "Использование конструкции ПОМЕСТИТЬ ВоВременнуюТаблицу в тексте запроса без менеджера, так как временные таблицы автоматически сохраняются между запросами пакета до конца сессии.",
              "var_2": "Передача результатов через ВременноеХранилище с сериализацией данных в строку для последующей десериализации в запросах.",
              "var_3": "Менеджер временных таблиц, создаваемый через объект МенеджерВременныхТаблиц и передаваемый в свойство Запрос.МенеджерВременныхТаблиц для всех запросов пакета.",
              "var_4": "Объект ХранилищеВременныхТаблиц, который создается автоматически при выполнении первого запроса пакета и доступен через контекст модуля.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Временные таблицы без МенеджераВременныхТаблиц существуют только в рамках одного запроса/пакета и автоматически удаляются после выполнения. Для передачи между запросами нужен МенеджерВременныхТаблиц.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "ВременноеХранилище используется для передачи данных между сеансами/формами, но не для работы временных таблиц в запросах. Это неэффективный и неправильный подход для расчета остатков.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный механизм. МенеджерВременныхТаблиц создается явно через Новый МенеджерВременныхТаблиц() и передается в свойство МенеджерВременныхТаблиц объекта Запрос для всех последовательных запросов пакета.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "ХранилищеВременныхТаблиц не создается автоматически и не доступен через контекст модуля. Необходимо явно создать МенеджерВременныхТаблиц и передать его в запросы.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Консоль заданий 1С - настройка расписания и параметров запуска регламентных операций обслуживания информационной базы",
          "competency": "Навыки работы с консолью заданий 1С",
          "questions": [
            {
              "question": "Почему в консоли заданий рекомендуется настраивать регламентные операции обслуживания на нерабочее время пользователей?",
              "correct_answer": "Регламентные операции создают блокировки и нагрузку на СУБД, что снижает производительность для активных пользователей.",
              "var_1": "Регламентные операции создают блокировки и нагрузку на СУБД, что снижает производительность для активных пользователей.",
              "var_2": "В ночное время сервер 1С автоматически переключается в специальный режим обслуживания с расширенными правами доступа к данным базы.",
              "var_3": "Регламентные задания могут выполняться только при отсутствии активных сеансов, иначе система выдаёт ошибку блокировки.",
              "var_4": "Регламентные операции требуют монопольного доступа к информационной базе, поэтому все пользователи автоматически отключаются на время выполнения.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Регламентные операции (перестроение индексов, сжатие таблиц, обновление итогов и т.д.) действительно создают значительную нагрузку на СУБД, могут устанавливать блокировки на таблицы и объекты базы данных, что замедляет работу пользователей.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Сервер 1С не переключается автоматически в специальный режим обслуживания с расширенными правами. Права доступа определяются ролями пользователей и не меняются в зависимости от времени суток.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Регламентные задания могут выполняться при наличии активных сеансов пользователей. Система не выдает ошибку блокировки из-за наличия сеансов. Именно поэтому их рекомендуют настраивать на нерабочее время, а не требуют отсутствия сеансов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Регламентные операции обслуживания не требуют монопольного доступа и не отключают пользователей автоматически. Они могут выполняться параллельно с работой пользователей, хотя это и нежелательно из-за снижения производительности.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какие параметры расписания необходимо настроить в консоли заданий, чтобы регламентное задание реиндексации таблиц выполнялось каждую ночь в период минимальной нагрузки на сервер?",
              "correct_answer": "Дата начала, время начала 03:00, период повтора дней = 1, указать все дни недели или бессрочное выполнение.",
              "var_1": "Время начала 00:00, интервал повтора = 24 часа, установить флаг \"Выполнять при простое сервера\".",
              "var_2": "Дата начала, время начала 03:00, период повтора часов = 24, установить приоритет \"Низкий\".",
              "var_3": "Дата начала, время начала 03:00, период повтора дней = 7, указать только будние дни недели.",
              "var_4": "Дата начала, время начала 03:00, период повтора дней = 1, указать все дни недели или бессрочное выполнение.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Флаг 'Выполнять при простое сервера' не существует в консоли заданий 1С. Время 00:00 может не быть периодом минимальной нагрузки. Интервал повтора в 24 часа не гарантирует ежедневное выполнение в одно и то же время.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Период повтора часов = 24 означает выполнение каждые 24 часа от времени последнего запуска, что может привести к смещению времени выполнения. Для ежедневного выполнения в одно и то же время нужен период повтора дней = 1.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Период повтора дней = 7 означает выполнение раз в неделю, а не каждую ночь. Указание только будних дней при недельном периоде не обеспечит ежедневное выполнение задания реиндексации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это корректная настройка: время начала 03:00 (типичное время минимальной нагрузки), период повтора дней = 1 обеспечивает ежедневное выполнение, указание всех дней недели или бессрочное выполнение гарантирует регулярность.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Оптимизация соединений таблиц - перестроение LEFT JOIN и INNER JOIN для повышения производительности запросов",
          "competency": "Навыки работы с конструктором запросов 1С",
          "questions": [
            {
              "question": "Почему замена LEFT JOIN на INNER JOIN в подзапросах 1С может существенно ускорить выполнение запроса?",
              "correct_answer": "INNER JOIN позволяет оптимизатору раньше отсекать строки, уменьшая объём обрабатываемых данных на промежуточных этапах",
              "var_1": "INNER JOIN не создаёт временных таблиц для хранения NULL-значений, экономя дисковое пространство",
              "var_2": "LEFT JOIN требует дополнительной сортировки данных, а INNER JOIN выполняет соединение напрямую",
              "var_3": "INNER JOIN позволяет оптимизатору раньше отсекать строки, уменьшая объём обрабатываемых данных на промежуточных этапах",
              "var_4": "INNER JOIN использует кэширование результатов соединения, что снижает нагрузку на оперативную память",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "LEFT JOIN не создаёт специальных временных таблиц для хранения NULL-значений. NULL-значения просто подставляются в результирующий набор для несовпавших строк, без дополнительного использования дискового пространства под их хранение.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "LEFT JOIN не требует обязательной дополнительной сортировки. Оба типа соединений могут использовать различные алгоритмы (hash join, merge join, nested loop), сортировка не является определяющим фактором различия.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это верный ответ. INNER JOIN позволяет оптимизатору применять предикаты фильтрации раньше в плане выполнения, так как не нужно сохранять строки без совпадений. Это уменьшает объём данных на промежуточных этапах обработки запроса.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "INNER JOIN не имеет специального механизма кэширования результатов соединений, который отличал бы его от LEFT JOIN. Оба типа соединений используют одинаковые механизмы работы с памятью, определяемые СУБД.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как следует перестроить запрос с LEFT JOIN к таблице остатков, если в результате нужны только документы с ненулевыми остатками?",
              "correct_answer": "Заменить LEFT JOIN на INNER JOIN, так как фильтрация по ненулевым остаткам всё равно отсекает NULL-записи, а INNER JOIN работает быстрее.",
              "var_1": "Добавить в LEFT JOIN дополнительное условие соединения по ненулевым остаткам, это ускорит выполнение без изменения типа связи.",
              "var_2": "Оставить LEFT JOIN и добавить условие WHERE по остаткам, так как это сохраняет возможность получить все документы при необходимости.",
              "var_3": "Использовать FULL JOIN вместо LEFT JOIN, чтобы гарантированно получить все записи из обеих таблиц и затем отфильтровать нужные.",
              "var_4": "Заменить LEFT JOIN на INNER JOIN, так как фильтрация по ненулевым остаткам всё равно отсекает NULL-записи, а INNER JOIN работает быстрее.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Добавление условия по ненулевым остаткам в ON не изменит суть LEFT JOIN - всё равно вернутся все документы слева с NULL справа. Это не эквивалентно фильтрации результата.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "LEFT JOIN с WHERE по остаткам фактически превращается в INNER JOIN, но медленнее: сначала формируется полный набор с NULL, затем фильтруется. Неоптимально.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "FULL JOIN объединяет все записи из обеих таблиц, включая NULL с обеих сторон, что избыточно и медленнее. Для фильтрации по ненулевым остаткам достаточно INNER JOIN.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Верно. Если нужны только документы с ненулевыми остатками, LEFT JOIN избыточен - он создаёт записи с NULL, которые потом отфильтровываются. INNER JOIN эффективнее, сразу отсекает несвязанные записи.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Обработка исключительных ситуаций в фоновых заданиях - реализация механизма повторных попыток при ошибках интеграции с внешними HTTP-сервисами",
          "competency": "Работа с очередью и фоновыми заданиями 1С",
          "questions": [
            {
              "question": "Почему при реализации повторных попыток HTTP-запросов в фоновых заданиях необходимо использовать экспоненциальную задержку между попытками?",
              "correct_answer": "Для снижения нагрузки на внешний сервис и предотвращения блокировки при временных сбоях, давая время на восстановление",
              "var_1": "Для синхронизации таймингов между клиентом и сервером, что обеспечивает корректную обработку ответов",
              "var_2": "Для соблюдения требований протокола HTTP к интервалам между запросами и предотвращения ошибок таймаута",
              "var_3": "Для снижения нагрузки на внешний сервис и предотвращения блокировки при временных сбоях, давая время на восстановление",
              "var_4": "Для оптимизации использования процессорного времени сервера 1С и равномерного распределения нагрузки",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Экспоненциальная задержка не связана с синхронизацией таймингов между клиентом и сервером. HTTP-протокол работает по модели запрос-ответ и не требует синхронизации таймингов для корректной обработки ответов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Протокол HTTP не содержит требований к интервалам между запросами. Экспоненциальная задержка не является требованием протокола и не связана с предотвращением ошибок таймаута. Таймауты настраиваются отдельно и не зависят от задержек между попытками.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Экспоненциальная задержка (exponential backoff) используется именно для того, чтобы не перегружать внешний сервис повторными запросами при временных сбоях, давая ему время на восстановление и снижая риск блокировки IP-адреса или превышения rate limits.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Экспоненциальная задержка не связана с оптимизацией процессорного времени 1С или равномерным распределением нагрузки на сервер 1С. Основная цель - дать время внешнему сервису на восстановление и избежать его перегрузки повторными запросами.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как реализовать механизм повторных попыток HTTP-запроса в фоновом задании с увеличивающимся интервалом между попытками при ошибках интеграции?",
              "correct_answer": "Использовать цикл с счётчиком попыток, перехватывать исключения в Попытка-Исключение, применять экспоненциальную задержку через ПриостановитьРаботу() перед каждой повторной попыткой, записывать ошибки в регистр сведений.",
              "var_1": "Реализовать рекурсивный вызов процедуры HTTP-запроса при возникновении ошибки с передачей номера попытки в параметрах, использовать транзакции для отката неуспешных операций, задержку вычислять через текущее системное время без приостановки потока.",
              "var_2": "Создать отдельное фоновое задание для каждой повторной попытки через ФоновыеЗадания.Выполнить() с параметром задержки запуска, хранить состояние в параметрах сеанса, использовать регламентное задание для мониторинга статуса выполнения всех запущенных попыток интеграции.",
              "var_3": "Настроить автоматический перезапуск фонового задания средствами платформы через свойство КоличествоПовторовПриАварийномЗавершении регламентного задания, задержка между попытками будет управляться системой автоматически, ошибки фиксировать в журнале регистрации штатными средствами.",
              "var_4": "Использовать цикл с счётчиком попыток, перехватывать исключения в Попытка-Исключение, применять экспоненциальную задержку через ПриостановитьРаботу() перед каждой повторной попыткой, записывать ошибки в регистр сведений.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Рекурсивный вызов в фоновом задании приведёт к проблемам с управлением стеком и ограничениям глубины рекурсии. Вычисление задержки через системное время без приостановки создаёт активное ожидание (busy waiting), что нагружает систему. Транзакции не помогают при HTTP-ошибках.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Создание отдельного фонового задания для каждой попытки избыточно и неэффективно. Параметры сеанса не подходят для хранения состояния фоновых заданий (выполняются в отдельном сеансе). Усложняет архитектуру без практических преимуществ.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "КоличествоПовторовПриАварийномЗавершении не предоставляет контроль над интервалами между попытками и не позволяет реализовать экспоненциальную задержку. Система использует фиксированные интервалы, что не соответствует требованию увеличивающегося интервала.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Корректный подход: цикл с счётчиком позволяет контролировать количество попыток, Попытка-Исключение перехватывает ошибки HTTP, ПриостановитьРаботу() реализует задержку с возможностью экспоненциального увеличения интервала, регистр сведений обеспечивает логирование для анализа.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        }
      ]
    },
    "senior": {
      "themes": [
        {
          "theme": "Объектная модель платформы 1С - создание переиспользуемых программных интерфейсов для типовых операций конфигурации",
          "competency": "Базовая теория 1С программирования",
          "questions": [
            {
              "question": "Почему при проектировании переиспользуемых API в 1С общие модули предпочтительнее обработок?",
              "correct_answer": "Единая точка входа без необходимости создания и передачи экземпляров объектов",
              "var_1": "Единая точка входа без необходимости создания и передачи экземпляров объектов",
              "var_2": "Обработки не поддерживают вызовы методов между разными сеансами работы пользователей системы",
              "var_3": "Обработки нельзя вызывать из фоновых заданий и регламентных задач",
              "var_4": "Общие модули автоматически компилируются на сервере, что обеспечивает более высокую производительность кода",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это ключевое преимущество общих модулей - прямой вызов методов без создания экземпляров объектов, что упрощает API и делает его более удобным для переиспользования.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Обработки можно вызывать между сеансами через серверные вызовы. Проблема не в межсеансовом взаимодействии, а в архитектуре API.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Обработки можно вызывать из фоновых заданий и регламентных задач. Это технически возможно и часто используется.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "И общие модули, и обработки компилируются в одинаковый байт-код платформы. Разница в производительности компиляции не является причиной выбора.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой архитектурный паттерн следует применить при проектировании общего модуля для унификации операций проведения документов разных типов с возможностью расширения логики без изменения базового кода?",
              "correct_answer": "Паттерн «Шаблонный метод» с использованием общего модуля-менеджера и делегированием специфичной логики в модули объектов или подписки на события для расширяемости.",
              "var_1": "Паттерн «Стратегия» с созданием отдельных общих модулей для каждого типа документа и жёстким связыванием через прямые вызовы между модулями, что обеспечивает максимальную производительность.",
              "var_2": "Паттерн «Шаблонный метод» с использованием общего модуля-менеджера и делегированием специфичной логики в модули объектов или подписки на события для расширяемости.",
              "var_3": "Паттерн «Фабрика» с динамическим созданием обработчиков проведения через конструкторы и хранением экземпляров в регистре сведений для кэширования логики обработки документов.",
              "var_4": "Паттерн «Наблюдатель» с регистрацией всех документов в едином реестре подписчиков и централизованной обработкой всех событий через один универсальный обработчик.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Хотя паттерн «Стратегия» подходит для вариативной логики, жёсткое связывание через прямые вызовы между модулями противоречит требованию расширяемости без изменения базового кода. Это создаёт сильную связанность и нарушает принцип открытости/закрытости.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Паттерн «Шаблонный метод» идеально подходит: общий модуль-менеджер содержит базовый алгоритм проведения (шаблон), а специфичная логика делегируется в модули объектов или реализуется через подписки на события, что обеспечивает расширяемость без изменения базового кода.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Паттерн «Фабрика» используется для создания объектов, но в 1С документы не создаются через конструкторы, а являются объектами метаданных. Хранение экземпляров обработчиков в регистре сведений архитектурно неверно и неэффективно для логики проведения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Паттерн «Наблюдатель» предназначен для оповещения зависимых объектов об изменениях состояния, а не для унификации операций проведения. Централизованный универсальный обработчик создаёт монолитную структуру, которую сложно расширять без изменения базового кода.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Dead letter queue - реализация механизма изоляции необрабатываемых сообщений в регистрах накопления с эскалацией",
          "competency": "Блок применения попытки/исключения 1С",
          "questions": [
            {
              "question": "Почему при реализации Dead Letter Queue в регистрах накопления критически важно выносить запись проблемного сообщения в изолированную транзакцию?",
              "correct_answer": "Иначе откат основной транзакции при исключении удалит и запись в DLQ, потеряв информацию о проблемном сообщении навсегда.",
              "var_1": "Без отдельной транзакции запись в DLQ будет ожидать завершения основной обработки, создавая дедлоки и снижая пропускную способность очереди сообщений.",
              "var_2": "Иначе откат основной транзакции при исключении удалит и запись в DLQ, потеряв информацию о проблемном сообщении навсегда.",
              "var_3": "Изолированная транзакция позволяет избежать блокировок основных таблиц регистра накопления, что критично для производительности системы при массовой обработке.",
              "var_4": "Выделение записи DLQ в отдельную транзакцию необходимо для корректного формирования итогов регистра накопления при параллельной обработке сообщений.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Запись в DLQ не будет ожидать завершения основной обработки - наоборот, она произойдет в той же транзакции. Проблема не в дедлоках от ожидания, а в откате данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это основная причина изоляции DLQ-записи. При возникновении исключения основная транзакция откатывается, и без отдельной транзакции запись о проблемном сообщении также откатится, что приведет к потере информации о сбое.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Изолированная транзакция не влияет на блокировки основных таблиц регистра. Запись в DLQ обычно идет в отдельный регистр или таблицу, блокировки не являются ключевой причиной изоляции.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Формирование итогов регистра накопления не связано с изоляцией транзакции DLQ. Итоги рассчитываются независимо от того, в какой транзакции происходит запись.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую структуру регистра накопления следует использовать для реализации Dead Letter Queue с возможностью эскалации при превышении порога неудачных попыток обработки сообщений?",
              "correct_answer": "Регистр оборотов с измерениями: ИдентификаторСообщения, УровеньЭскалации; ресурсом: КоличествоПопыток; реквизитами: ТелоСообщения, ДатаПоследнейПопытки. При превышении порога в блоке Исключение выполняется движение с новым УровнемЭскалации.",
              "var_1": "Регистр сведений с периодичностью по регистратору, измерением ИдентификаторСообщения и ресурсом УровеньЭскалации. Эскалация выполняется автоматически при записи нового движения.",
              "var_2": "Регистр оборотов с единственным измерением ИдентификаторСообщения и ресурсом КоличествоПопыток. УровеньЭскалации хранится в реквизите и обновляется через запись с заменой при каждой неудачной попытке обработки.",
              "var_3": "Регистр остатков с измерениями: ИдентификаторСообщения, СтатусОбработки, ПриоритетОчереди; ресурсами: КоличествоПопыток, ВремяОжидания; реквизитами: ТелоСообщения, ИсточникСообщения. Эскалация реализуется через периодический регламентный запрос к остаткам с группировкой по статусам.",
              "var_4": "Регистр оборотов с измерениями: ИдентификаторСообщения, УровеньЭскалации; ресурсом: КоличествоПопыток; реквизитами: ТелоСообщения, ДатаПоследнейПопытки. При превышении порога в блоке Исключение выполняется движение с новым УровнемЭскалации.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Регистр сведений с периодичностью по регистратору неприменим - он хранит исторические данные, привязанные к документам. Для DLQ нужна накопительная структура с учетом попыток, а не периодическая история.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Регистр оборотов с единственным измерением ИдентификаторСообщения не позволяет корректно отслеживать уровни эскалации. УровеньЭскалации должен быть измерением для правильной группировки и анализа, а не реквизитом.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Регистр остатков не подходит для DLQ - он предназначен для учета количественных показателей с остатками, а не для отслеживания попыток обработки. Структура с остатками избыточна и неэффективна для логирования ошибок.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Правильная структура: регистр оборотов накапливает попытки, УровеньЭскалации как измерение позволяет группировать сообщения по уровням, движения в блоке Исключение обеспечивают автоматическую эскалацию при превышении порога.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Производительность проверок прав - профилирование и оптимизация запросов с ограничениями доступа в конфигурациях с десятками ролей",
          "competency": "Права и роли в 1С",
          "questions": [
            {
              "question": "Почему в конфигурациях с десятками ролей RLS-ограничения могут значительно замедлять запросы к базе данных?",
              "correct_answer": "Платформа объединяет условия RLS всех ролей через OR, усложняя план запроса.",
              "var_1": "RLS-ограничения выполняются на стороне сервера 1С после получения данных из СУБД.",
              "var_2": "Платформа объединяет условия RLS всех ролей через OR, усложняя план запроса.",
              "var_3": "Система проверяет права каждого пользователя отдельным запросом к базе данных при каждом обращении к данным.",
              "var_4": "Большое количество ролей приводит к увеличению размера кэша метаданных и замедлению его работы.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "RLS-ограничения встраиваются непосредственно в SQL-запрос и выполняются на уровне СУБД, а не после получения данных на сервере 1С. Если бы фильтрация происходила после выборки, это было бы крайне неэффективно.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это верно. При множестве ролей платформа объединяет условия всех RLS-ограничений через OR, что создает сложные составные условия в WHERE. Это усложняет план выполнения запроса СУБД, делает невозможным эффективное использование индексов и значительно снижает производительность.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Платформа 1С не проверяет права отдельными запросами для каждого пользователя при каждом обращении. RLS-ограничения встраиваются в SQL-запрос один раз при формировании запроса.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Хотя большое количество ролей увеличивает размер метаданных, основная проблема производительности запросов связана со сложностью SQL-условий RLS, а не с кэшем метаданных. Кэш метаданных влияет на загрузку конфигурации, но не на выполнение запросов.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой инструмент платформы 1С следует использовать для выявления наиболее ресурсоёмких RLS-условий при массовых операциях чтения данных в конфигурации с 50+ ролями?",
              "correct_answer": "Технологический журнал с анализом событий SDBL и DBMSSQL, показывающих итоговые SQL-запросы с развёрнутыми RLS-условиями.",
              "var_1": "Консоль запросов с включённым режимом отладки RLS, позволяющая увидеть план выполнения запроса и время работы каждого условия доступа.",
              "var_2": "Отчёт \"Анализ прав доступа\" из БСП с детализацией по ролям, отображающий статистику применения RLS-шаблонов при чтении данных.",
              "var_3": "Технологический журнал с анализом событий SDBL и DBMSSQL, показывающих итоговые SQL-запросы с развёрнутыми RLS-условиями.",
              "var_4": "Замер производительности в конфигураторе с анализом стека вызовов, показывающий время выполнения каждой проверки прав доступа на уровне ролей.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Консоль запросов не имеет специального режима отладки RLS и не показывает детализацию времени работы каждого условия доступа. Она позволяет видеть план выполнения запроса, но без разбивки по RLS-условиям и их производительности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Отчёт 'Анализ прав доступа' из БСП показывает статическую информацию о правах пользователей и ролях, но не анализирует производительность и не собирает статистику времени выполнения RLS-условий при реальных операциях чтения данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Технологический журнал с событиями SDBL (запросы на языке 1С) и DBMSSQL (итоговые SQL-запросы к СУБД) позволяет увидеть полные SQL-запросы с развёрнутыми RLS-условиями всех ролей, их время выполнения и план запроса, что необходимо для выявления ресурсоёмких условий доступа.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Замер производительности в конфигураторе не показывает детализацию по отдельным проверкам прав доступа и RLS-условиям. Он фиксирует общее время выполнения методов, но не раскрывает структуру SQL-запросов с развёрнутыми условиями RLS.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Модульная декомпозиция функциональности - проектирование изолированных слоев бизнес-логики, данных и представления в конфигурации",
          "competency": "Понимание модульности и архитектуры кода 1С",
          "questions": [
            {
              "question": "Почему в 1С размещение бизнес-логики в модулях объектов вместо модулей форм повышает сопровождаемость конфигурации?",
              "correct_answer": "Бизнес-логика становится независимой от интерфейса, переиспользуемой из любого кода и тестируемой без форм",
              "var_1": "Размещение логики в модулях объектов позволяет использовать директивы компиляции &НаКлиенте, что недоступно в модулях форм конфигурации",
              "var_2": "Бизнес-логика становится независимой от интерфейса, переиспользуемой из любого кода и тестируемой без форм",
              "var_3": "Модули объектов компилируются на сервере и автоматически кэшируются платформой, что ускоряет выполнение кода и снижает нагрузку на систему",
              "var_4": "Модули объектов имеют прямой доступ к транзакциям базы данных, тогда как модули форм работают только через временные таблицы",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Директива &НаКлиенте доступна как в модулях объектов, так и в модулях форм. Это стандартная возможность обеих типов модулей в клиент-серверном варианте.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Размещение бизнес-логики в модулях объектов обеспечивает независимость от представления (форм), позволяет переиспользовать код из различных точек конфигурации (обработки, отчеты, регламентные задания) и упрощает модульное тестирование без необходимости создания форм.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Кэширование компилированного кода не является основной причиной повышения сопровождаемости. Речь идет о архитектурном разделении, а не о производительности платформы.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Модули форм могут работать напрямую с базой данных через запросы и методы платформы, а не только через временные таблицы. Транзакции доступны в серверном контексте независимо от типа модуля.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой паттерн организации общих модулей вы примените для изоляции слоя работы с внешними API от бизнес-логики в высоконагруженной конфигурации?",
              "correct_answer": "Создать отдельную подсистему с общими модулями-адаптерами, инкапсулирующими HTTP-вызовы, сериализацию и обработку ошибок, предоставляя бизнес-логике типизированный программный интерфейс через фасадный модуль.",
              "var_1": "Использовать единый серверный общий модуль для всех HTTP-вызовов без разделения по подсистемам, передавая параметры через структуры для универсальности и гибкости решения.",
              "var_2": "Размещать код работы с API непосредственно в модулях объектов справочников и документов, что обеспечит близость данных к логике их обработки и упростит отладку.",
              "var_3": "Выносить логику работы с API в регламентные задания, которые будут асинхронно обрабатывать очередь запросов, изолируя тем самым основную бизнес-логику от внешних вызовов.",
              "var_4": "Создать отдельную подсистему с общими модулями-адаптерами, инкапсулирующими HTTP-вызовы, сериализацию и обработку ошибок, предоставляя бизнес-логике типизированный программный интерфейс через фасадный модуль.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Единый монолитный модуль для всех HTTP-вызовов нарушает принципы модульности и Single Responsibility. В высоконагруженной системе это создаст узкое место, затруднит масштабирование и тестирование, не обеспечит изоляцию слоёв.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Размещение кода работы с API в модулях объектов нарушает separation of concerns, создаёт tight coupling, усложняет тестирование и переиспользование. Это антипаттерн, противоречащий принципам изоляции слоёв.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Регламентные задания — это механизм асинхронной обработки, а не паттерн изоляции слоёв архитектуры. Вопрос о структурной организации модулей и разделении ответственности, а не о способе выполнения запросов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это классический архитектурный паттерн Adapter + Facade для изоляции слоёв. Адаптеры инкапсулируют внешнюю интеграцию, фасад предоставляет единый типизированный интерфейс бизнес-логике, обеспечивая слабое связывание и высокую тестируемость.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Code review расширений - выявление архитектурных проблем и планирование рефакторинга кодовой базы",
          "competency": "Знание работы с расширениями в 1С",
          "questions": [
            {
              "question": "Почему при code review расширений критически важно выявлять жёсткие привязки к реквизитам типовой конфигурации?",
              "correct_answer": "После обновления типовой конфигурации переименованные или удалённые реквизиты вызовут ошибки в расширении, нарушив его работоспособность.",
              "var_1": "Привязки к реквизитам типовой конфигурации создают избыточную нагрузку на механизм синхронизации расширений и требуют дополнительных ресурсов сервера при работе.",
              "var_2": "После обновления типовой конфигурации переименованные или удалённые реквизиты вызовут ошибки в расширении, нарушив его работоспособность.",
              "var_3": "Жёсткие привязки к реквизитам типовой конфигурации снижают производительность системы при выполнении запросов, так как платформа не может оптимизировать обращения к данным.",
              "var_4": "Жёсткие привязки мешают платформе корректно кэшировать метаданные расширения, что приводит к увеличению времени загрузки конфигурации базы данных.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Жёсткие привязки к реквизитам не создают нагрузку на механизм синхронизации расширений. Синхронизация расширений работает на уровне метаданных, а не реквизитов. Проблема не в ресурсах сервера.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это основная причина. При обновлении типовой конфигурации реквизиты могут быть переименованы, удалены или изменён их тип. Жёсткие привязки в коде расширения (например, Объект.Наименование, Запрос с полями) приведут к ошибкам выполнения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Жёсткие привязки к реквизитам не влияют на производительность запросов. Платформа одинаково обрабатывает обращения к реквизитам независимо от того, есть привязка в расширении или нет. Проблема в другом - в хрупкости кода.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Привязки к реквизитам не влияют на кэширование метаданных расширения. Платформа кэширует метаданные на уровне объектов конфигурации, а не на уровне привязок к реквизитам. Это не связано с временем загрузки.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой подход к рефакторингу вы примените, обнаружив в расширении множественные перехваты одной процедуры БСП с дублирующейся логикой проверки прав доступа?",
              "correct_answer": "Вынести проверку прав в единый общий модуль расширения, заменить множественные перехваты одним с вызовом централизованной функции, устранив дублирование и упростив поддержку кода.",
              "var_1": "Создать отдельное расширение специально для проверки прав доступа с собственными перехватами БСП, которое будет вызываться из основного расширения через программный интерфейс, разделив ответственность между модулями.",
              "var_2": "Оставить множественные перехваты как есть, но добавить комментарии с описанием логики проверки прав в каждом месте, создать документацию по архитектуре расширения для упрощения понимания кода другими разработчиками.",
              "var_3": "Перенести логику проверки прав непосредственно в типовую конфигурацию БСП, отказавшись от использования расширений для данной функциональности.",
              "var_4": "Вынести проверку прав в единый общий модуль расширения, заменить множественные перехваты одним с вызовом централизованной функции, устранив дублирование и упростив поддержку кода.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Создание отдельного расширения для проверки прав избыточно усложняет архитектуру, добавляет зависимости между расширениями и перехваты БСП остаются множественными, только в другом месте. Проблема дублирования не решается.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Добавление комментариев и документации не решает проблему дублирования кода и множественных перехватов. Это лишь маскирует архитектурную проблему, усложняя поддержку и повышая риск ошибок при изменениях.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Изменение типовой конфигурации БСП противоречит концепции расширений и best practices 1С. Типовую конфигурацию нельзя модифицировать, для доработок используются именно расширения. Этот подход создаст проблемы при обновлении.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный подход к рефакторингу: централизация повторяющейся логики в общий модуль и единый перехват устраняет дублирование кода, упрощает поддержку и тестирование, соответствует принципу DRY.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Оптимизация хранения логов - разработка механизмов партицирования таблиц регистров логирования и архивации устаревших данных средствами встроенного языка",
          "competency": "Навыки работы с журналом регистрации и логированием 1С",
          "questions": [
            {
              "question": "Почему при организации хранения логов в 1С предпочтительнее группировать данные по временному измерению, а не по идентификатору записи?",
              "correct_answer": "Временная группировка позволяет эффективно удалять устаревшие данные целыми блоками без фрагментации.",
              "var_1": "Временная группировка позволяет эффективно удалять устаревшие данные целыми блоками без фрагментации.",
              "var_2": "Временная группировка обеспечивает более быстрый поиск записей по идентификатору за счёт автоматического индексирования временных полей.",
              "var_3": "Группировка по времени позволяет платформе 1С автоматически создавать резервные копии логов без участия администратора.",
              "var_4": "Временное измерение обеспечивает уникальность записей и предотвращает дублирование данных в регистрах логирования.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это основное преимущество временной группировки для логов. При партицировании по временным диапазонам (дням/месяцам) можно удалять целые блоки устаревших данных одной операцией, что минимизирует фрагментацию таблиц БД и снижает нагрузку на СУБД по сравнению с точечным удалением по ID.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Временная группировка не ускоряет поиск по идентификатору - наоборот, если нужно найти запись по ID без знания времени, придётся сканировать больше партиций. Автоматическое индексирование временных полей существует, но это не главное преимущество группировки по времени для логов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Платформа 1С не создаёт автоматически резервные копии логов на основе временной группировки. Резервное копирование - это отдельный процесс, управляемый администратором или средствами СУБД, не зависящий от способа группировки данных в регистрах.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Временное измерение не обеспечивает уникальность записей логов - за одну миллисекунду может произойти множество событий. Уникальность обеспечивается другими механизмами (составные ключи, GUID). Предотвращение дублирования не является преимуществом временной группировки.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой механизм встроенного языка 1С следует использовать для оптимизации хранения и удаления устаревших записей регистра сведений логирования?",
              "correct_answer": "Фоновое задание с порционным удалением записей старше порога через запрос с ПЕРВЫЕ N для минимизации блокировок.",
              "var_1": "Регламентное задание с прямым вызовом метода Удалить() для всех записей регистра за один вызов.",
              "var_2": "Фоновое задание с порционным удалением записей старше порога через запрос с ПЕРВЫЕ N для минимизации блокировок.",
              "var_3": "Обработка ожидания с выполнением запроса DELETE через внешний источник данных для быстрого удаления.",
              "var_4": "Использование метода УстановитьГраницуПоследовательности для автоматической очистки старых записей лога.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Удаление всех записей регистра за один вызов метода Удалить() приведет к длительной блокировке таблицы, что критично для работающей системы. Это противоречит принципам оптимизации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Порционное удаление через фоновое задание с использованием ПЕРВЫЕ N - оптимальный подход для минимизации блокировок базы данных и обеспечения стабильной работы системы при удалении больших объемов устаревших логов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Использование DELETE через внешний источник данных - нестандартный и рискованный подход, который может нарушить целостность базы данных 1С. Встроенный язык предоставляет собственные механизмы для работы с данными.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "УстановитьГраницуПоследовательности() используется для управления последовательностями, а не для очистки записей регистров. Этот метод не имеет отношения к удалению данных из регистров сведений.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Механизмы отложенной записи и накопления изменений - создание фреймворка буферизации движений документов для минимизации времени удержания блокировок в процессе массового проведения",
          "competency": "Знание работы транзакций в 1С",
          "questions": [
            {
              "question": "Почему буферизация движений документов при массовом проведении сокращает время удержания блокировок на регистрах накопления?",
              "correct_answer": "Блокировки удерживаются только в момент финальной записи, а не при обработке документов.",
              "var_1": "Блокировки удерживаются только в момент финальной записи, а не при обработке документов.",
              "var_2": "Движения записываются в отдельную таблицу, минуя стандартные блокировки регистров",
              "var_3": "Буфер сжимает данные движений, уменьшая объём записываемых данных",
              "var_4": "Буферизация автоматически переключает регистры накопления в режим разделения итогов, что устраняет конфликты",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это ключевой принцип буферизации: движения накапливаются в памяти при обработке документов, а блокировки регистров захватываются только в момент финальной записи буфера. Это сокращает время удержания блокировок с суммарного времени обработки всех документов до времени одной записи.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Движения не записываются в отдельную таблицу, минуя блокировки. Буферизация работает через накопление в памяти с последующей записью в те же регистры с теми же механизмами блокировок, но за одну операцию вместо множества.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Буферизация движений не связана со сжатием данных. Механизм работает через накопление и агрегацию движений в памяти перед записью, но не через сжатие объёма данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Буферизация не переключает режим разделения итогов автоматически. Режим разделения итогов - это отдельная настройка регистра, не связанная с механизмом буферизации движений.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую структуру данных и механизм сброса буфера вы реализуете во фреймворке буферизации движений для оптимизации массового проведения документов?",
              "correct_answer": "Таблицу значений в общем модуле, накапливающую движения с периодическим сбросом через НаборЗаписей.Записать() внутри отдельной транзакции после фиксации транзакции документа.",
              "var_1": "Массив структур в реквизите документа, накапливающий движения с немедленным сбросом через Движения.Записать() внутри той же транзакции документа при достижении порогового количества записей для балансировки памяти и производительности.",
              "var_2": "Соответствие в менеджере регистра, накапливающее движения с синхронным сбросом через прямой SQL-запрос INSERT в таблицу регистра без использования объектной модели для максимальной скорости записи.",
              "var_3": "Временная таблица в запросе, накапливающая движения с пакетным сбросом через НаборЗаписей.Загрузить() внутри транзакции документа перед её фиксацией.",
              "var_4": "Таблицу значений в общем модуле, накапливающую движения с периодическим сбросом через НаборЗаписей.Записать() внутри отдельной транзакции после фиксации транзакции документа.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Сброс через Движения.Записать() внутри транзакции документа не минимизирует время удержания блокировок - наоборот, расширяет транзакцию. Это противоречит основной цели фреймворка буферизации для массового проведения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Прямые SQL-запросы INSERT в таблицы регистров обходят механизмы контроля ссылочной целостности, не обновляют итоги, нарушают архитектуру 1С и могут привести к несогласованности данных. Это недопустимо для фреймворка буферизации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Временная таблица в запросе существует только в контексте выполнения запроса и не может использоваться для накопления движений между документами при массовом проведении. Сброс внутри транзакции документа не решает задачу минимизации времени блокировок.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Правильный подход: таблица значений в общем модуле накапливает движения от множества документов, сброс в отдельной транзакции после фиксации транзакций документов минимизирует время блокировок каждого документа, что критично для массового проведения.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Обработка webhook в 1С - валидация HMAC-подписей запросов и реализация rate limiting через регистры накопления",
          "competency": "Принципы работы http запросов 1С",
          "questions": [
            {
              "question": "Почему для реализации rate limiting предпочтительнее использовать регистр накопления с видом движения «Обороты», а не «Остатки»?",
              "correct_answer": "Остатки требуют парных операций прихода-расхода, а обороты позволяют просто накапливать счётчики запросов за период без необходимости списания.",
              "var_1": "Регистр остатков блокирует таблицу при записи для пересчёта итогов, а обороты записываются без блокировок базы данных.",
              "var_2": "Обороты работают быстрее остатков при записи, что критично для высоконагруженных webhook-обработчиков с частыми запросами.",
              "var_3": "Остатки не поддерживают измерения по времени, а обороты позволяют группировать записи по периодам для анализа нагрузки.",
              "var_4": "Остатки требуют парных операций прихода-расхода, а обороты позволяют просто накапливать счётчики запросов за период без необходимости списания.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Оба типа регистров накопления не блокируют всю таблицу при записи. Блокировки происходят на уровне записей/страниц. Пересчёт итогов в регистре остатков может создавать дополнительные блокировки, но это не блокировка всей базы данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Производительность записи в регистры накопления с видом 'Обороты' и 'Остатки' практически одинакова. Разница не в скорости записи, а в механизме работы и необходимости пересчёта итогов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Оба типа регистров накопления ('Остатки' и 'Обороты') поддерживают измерения по времени (периодичность). Разница не в поддержке измерений времени, а в логике учёта данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это верно. Регистр с видом 'Обороты' идеально подходит для rate limiting, так как позволяет просто записывать факты запросов (счётчики) за период. Регистр 'Остатки' требует парных операций (приход/расход) для поддержания баланса, что избыточно для подсчёта запросов.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую структуру регистра следует спроектировать для реализации rate limiting webhook-запросов с возможностью отслеживания лимитов по IP-адресу и endpoint за скользящее временное окно?",
              "correct_answer": "Регистр сведений с периодичностью по позиции регистра, измерениями IPАдрес и Endpoint, ресурсом КоличествоЗапросов. Для скользящего окна запрос с отбором по периоду.",
              "var_1": "Регистр накопления оборотов с измерениями IPАдрес и Endpoint, ресурсом КоличествоЗапросов. Периодичность устанавливается в свойствах регистра, скользящее окно рассчитывается через обороты.",
              "var_2": "Регистр сведений без периодичности с измерениями IPАдрес и Endpoint, ресурсами ПоследнийЗапрос и СчётчикЗапросов для контроля лимитов.",
              "var_3": "Регистр накопления остатков с измерениями IPАдрес, Endpoint и Период, ресурсом СуммаЗапросов. Скользящее окно реализуется через виртуальную таблицу остатков с автоматическим расчётом накопленных значений.",
              "var_4": "Регистр сведений с периодичностью по позиции регистра, измерениями IPАдрес и Endpoint, ресурсом КоличествоЗапросов. Для скользящего окна запрос с отбором по периоду.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Регистр накопления оборотов не подходит для rate limiting, так как обороты рассчитываются за фиксированные периоды (день, месяц и т.д.), а не за скользящее окно. Периодичность в свойствах регистра накопления не настраивается - это характеристика виртуальных таблиц.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Регистр сведений без периодичности не подходит для скользящего окна, так как хранит только текущее состояние (последний запрос и счётчик). Невозможно отследить количество запросов за последние N минут - нужна история всех запросов с временными метками для расчёта скользящего окна.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Регистр накопления остатков не подходит, так как остатки предназначены для учёта материальных/денежных величин с приходами/расходами. Для rate limiting нужно считать события за скользящее окно, а не накапливать остатки. Виртуальная таблица остатков не предназначена для подсчёта событий за временной интервал.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Регистр сведений с периодичностью позволяет хранить историю запросов с временными метками. Измерения IPАдрес и Endpoint идентифицируют источник запроса, ресурс КоличествоЗапросов считает запросы. Запрос с отбором по периоду (например, ТекущаяДата() - 60 секунд) реализует скользящее окно для подсчёта запросов.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Рефакторинг общих модулей - применение паттернов проектирования для устранения дублирования кода и оптимизации производительности",
          "competency": "Общие модули 1С",
          "questions": [
            {
              "question": "Почему применение паттерна «Стратегия» (через структуры соответствия) в общих модулях 1С предпочтительнее множественных условных операторов при рефакторинге алгоритмов расчёта?",
              "correct_answer": "Изолирует алгоритмы в процедурах, упрощает добавление вариантов, снижает цикломатическую сложность.",
              "var_1": "Изолирует алгоритмы в процедурах, упрощает добавление вариантов, снижает цикломатическую сложность.",
              "var_2": "Сокращает объём кода и автоматически кэширует результаты вычислений.",
              "var_3": "Позволяет хранить алгоритмы в базе данных и изменять их без обновления конфигурации.",
              "var_4": "Увеличивает скорость выполнения за счёт компиляции структур соответствия в байт-код платформы при запуске.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это корректное описание преимуществ паттерна «Стратегия» в 1С: каждый алгоритм изолируется в отдельной процедуре/функции, добавление новых вариантов упрощается (достаточно добавить новую функцию и запись в структуру соответствия), а цикломатическая сложность снижается за счёт замены множественных if/else на обращение к структуре.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Паттерн «Стратегия» не обеспечивает автоматическое кэширование результатов вычислений. Кэширование - это отдельная техника оптимизации, не связанная напрямую с этим паттерном. Сокращение кода тоже не является основным преимуществом.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Паттерн «Стратегия» через структуры соответствия в 1С не предполагает хранение алгоритмов в базе данных - это программная конструкция в коде конфигурации. Изменение стратегий требует изменения кода модулей.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Структуры соответствия в 1С не компилируются в специальный байт-код при запуске. Преимущество паттерна «Стратегия» не в скорости выполнения, а в улучшении архитектуры и поддерживаемости кода. Производительность остаётся сопоставимой с условными операторами.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой паттерн проектирования применить в общем модуле для унификации алгоритмов расчета себестоимости с различающимися шагами для разных типов номенклатуры?",
              "correct_answer": "Паттерн Шаблонный метод (Template Method) — создать базовый алгоритм в общем модуле с переопределяемыми шагами через делегирование в специализированные процедуры для каждого типа номенклатуры.",
              "var_1": "Паттерн Шаблонный метод (Template Method) — создать базовый алгоритм в общем модуле с переопределяемыми шагами через делегирование в специализированные процедуры для каждого типа номенклатуры.",
              "var_2": "Паттерн Стратегия (Strategy) — вынести все варианты расчета себестоимости в отдельные модули, а в основном алгоритме динамически подключать нужный модуль через Выполнить() в зависимости от типа номенклатуры.",
              "var_3": "Паттерн Декоратор (Decorator) — обернуть базовый расчет себестоимости дополнительными слоями для каждого типа номенклатуры с накоплением результатов.",
              "var_4": "Паттерн Фабричный метод (Factory Method) — создать отдельные функции-фабрики для каждого типа номенклатуры, которые будут возвращать готовый результат расчета себестоимости без общего алгоритма.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Шаблонный метод идеально подходит для унификации алгоритмов с общей структурой, но различающимися шагами. Базовый алгоритм определяет последовательность, а специфичные шаги делегируются процедурам для каждого типа.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Использование Выполнить() для динамического подключения модулей — это антипаттерн в 1С, который создаёт проблемы с производительностью, отладкой и поддержкой кода. Стратегия реализуется через структуры данных и явные вызовы.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Декоратор добавляет дополнительную функциональность к объекту, оборачивая его. Он не предназначен для варьирования шагов алгоритма — это задача Шаблонного метода или Стратегии.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Фабричный метод создаёт объекты разных типов, но не решает задачу унификации алгоритма с различающимися шагами. Здесь нет общего алгоритма, только набор независимых функций.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Тестирование расширений конфигурации - проверка совместимости и стабильности работы переопределяемых процедур и событий объектов при сложной архитектуре",
          "competency": "Тестирование и отладка в 1С",
          "questions": [
            {
              "question": "Почему при тестировании расширений с перехватом событий объектов критически важно проверять порядок вызова обработчиков нескольких расширений?",
              "correct_answer": "Порядок определяется приоритетом расширений, изменение приоритетов может вызывать конфликты данных.",
              "var_1": "Порядок вызова влияет только на производительность, но не на результат обработки данных.",
              "var_2": "Платформа автоматически сортирует обработчики по алфавиту, что может сломать бизнес-логику.",
              "var_3": "События всегда выполняются параллельно, поэтому важно исключить блокировки между расширениями.",
              "var_4": "Порядок определяется приоритетом расширений, изменение приоритетов может вызывать конфликты данных.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Порядок вызова напрямую влияет на результат обработки данных. Каждое расширение может модифицировать данные, и последующие расширения получают уже измененные значения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Платформа НЕ сортирует обработчики по алфавиту. Порядок определяется явно заданными приоритетами расширений (числовые значения), а не алфавитным порядком.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "События в 1С не выполняются параллельно - они вызываются последовательно, синхронно в порядке приоритета расширений. Проблема не в блокировках от параллельности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это корректный ответ. Порядок вызова обработчиков событий определяется приоритетами расширений. Изменение приоритетов меняет последовательность обработки, что может привести к конфликтам данных и нарушению бизнес-логики при зависимостях между расширениями.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую стратегию тестирования вы примените для проверки корректности работы расширения, переопределяющего обработчик ПередЗаписью документа, если основная конфигурация также содержит критичную логику в этом событии?",
              "correct_answer": "Применю модульные тесты с проверкой вызова оригинального обработчика через ПродолжитьВызов, интеграционные тесты на граничные сценарии и регрессионное тестирование базовой логики при включённом и отключённом расширении.",
              "var_1": "Использую автоматизированное нагрузочное тестирование для проверки производительности обработчика, создам отдельную тестовую базу без расширения для сравнения времени выполнения, применю профилировщик для анализа узких мест в коде обработчика ПередЗаписью.",
              "var_2": "Проведу тестирование методом белого ящика с полным покрытием кода расширения, исключу вызов ПродолжитьВызов для изоляции логики расширения от базовой конфигурации, применю мок-объекты для имитации поведения основного обработчика.",
              "var_3": "Применю модульные тесты с проверкой вызова оригинального обработчика через ПродолжитьВызов, интеграционные тесты на граничные сценарии и регрессионное тестирование базовой логики при включённом и отключённом расширении.",
              "var_4": "Применю только интеграционные тесты на реальных данных без модульного тестирования, так как изолированные тесты не отражают реального взаимодействия, отключу базовую логику через комментирование для проверки расширения.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Фокус на нагрузочном тестировании и производительности не решает главную задачу - проверку корректности работы и совместимости логики расширения с базовой конфигурацией. Производительность - вторичный аспект по сравнению с функциональной корректностью.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Исключение ПродолжитьВызов критически неверно - это нарушит выполнение базовой логики конфигурации, что недопустимо при работе с критичным обработчиком. Изоляция через моки не позволит проверить реальное взаимодействие расширения и основной конфигурации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Комплексный подход, включающий модульные тесты с ПродолжитьВызов (обеспечивает вызов базовой логики), интеграционные тесты граничных случаев и регрессионное тестирование с включённым/отключённым расширением - оптимальная стратегия для проверки совместимости расширения с критичной базовой логикой.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Отсутствие модульных тестов и комментирование базовой логики абсолютно неприемлемо - это нарушит работу критичной функциональности основной конфигурации и не позволит проверить корректность совместной работы расширения и базового кода.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Архитектура регистров движений - проектирование структуры хранения для оптимизации массового проведения документов",
          "competency": "Жизненный цикл документа 1С",
          "questions": [
            {
              "question": "Почему при проектировании регистра накопления для массового проведения предпочтительнее минимизировать количество измерений?",
              "correct_answer": "Каждое измерение увеличивает размер индекса и количество блокировок при записи, что снижает параллельность проведения документов.",
              "var_1": "Количество измерений влияет только на скорость чтения данных из регистра, при записи система автоматически оптимизирует работу с индексами независимо от их числа.",
              "var_2": "Большое число измерений усложняет отладку запросов и затрудняет понимание структуры данных разработчиками.",
              "var_3": "Минимизация измерений уменьшает объём данных в таблице движений, что критично для производительности при массовой записи документов.",
              "var_4": "Каждое измерение увеличивает размер индекса и количество блокировок при записи, что снижает параллельность проведения документов.",
              "correct_position": 4,
              "fixes_applied": 1,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Неверно. Количество измерений напрямую влияет на скорость записи, так как каждое измерение входит в индексы, и система НЕ может автоматически оптимизировать работу независимо от их числа. При записи происходит обновление всех индексов и блокировки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Хотя большое число измерений действительно усложняет отладку, это не является основной технической причиной для минимизации измерений при массовом проведении. Вопрос касается производительности, а не удобства разработки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Верно. Каждое измерение добавляется в структуру таблицы итогов, увеличивая её размер и количество комбинаций для хранения. При большом количестве измерений таблица итогов разрастается экспоненциально, что критически снижает производительность расчёта остатков.",
                "was_replaced": true,
                "original_before_fix": "Минимизация измерений позволяет уменьшить объём хранимых данных в таблице итогов, что критично для производительности при расчёте остатков."
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Верно. Каждое измерение участвует в составных индексах регистра. Чем больше измерений, тем больше размер индекса, больше операций при его обновлении и выше гранулярность блокировок на уровне индекса, что снижает параллельность массового проведения.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую стратегию индексирования регистра накопления следует применить при проектировании системы, где 90% запросов при проведении выполняют получение остатков по измерениям Номенклатура+Склад?",
              "correct_answer": "Создать регистр накопления с видом Остатки, установить измерения Номенклатура и Склад как основные отборы для автоматического построения оптимального индекса таблицы остатков.",
              "var_1": "Использовать регистр сведений с периодичностью и создать дополнительные индексы базы данных на уровне СУБД для ускорения выборки по измерениям.",
              "var_2": "Создать регистр накопления с видом Остатки, установить измерения Номенклатура и Склад как основные отборы для автоматического построения оптимального индекса таблицы остатков.",
              "var_3": "Создать регистр накопления с видом Остатки, добавив все измерения в индексирование и установив флаг \"Индексировать\" для каждого измерения отдельно.",
              "var_4": "Создать регистр накопления с видом Обороты и добавить составной индекс по полям Номенклатура+Склад через конфигуратор в свойствах регистра.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Регистр сведений не предназначен для учета остатков и движений документов. Для этого используются регистры накопления. Создание индексов на уровне СУБД минует механизмы платформы 1С и не рекомендуется.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильная стратегия: регистр накопления вида Остатки с установкой измерений Номенклатура и Склад как основных отборов автоматически создает оптимальный составной индекс для таблицы остатков, что ускоряет выборку при проведении документов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Установка флага 'Индексировать' для каждого измерения отдельно создает отдельные индексы по каждому полю, а не составной индекс. Это не оптимально для запросов с условиями по нескольким измерениям одновременно (Номенклатура+Склад).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Регистр накопления вида Обороты не подходит для получения остатков - он хранит только обороты за период. Для работы с остатками нужен вид Остатки. Составной индекс через конфигуратор также не создается явно для таких регистров.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Управляемые блокировки - разработка стратегий блокирования данных при многопоточной обработке документов",
          "competency": "Основы платформы 1С",
          "questions": [
            {
              "question": "Почему при многопоточной обработке документов рекомендуется использовать управляемые блокировки вместо автоматических в режиме управляемого блокирования?",
              "correct_answer": "Управляемые блокировки позволяют точно определить момент и объем блокируемых данных, минимизируя время удержания блокировки и снижая вероятность взаимоблокировок при параллельной работе",
              "var_1": "Управляемые блокировки автоматически обрабатывают все конфликты между потоками, поэтому разработчику не нужно писать дополнительный код для синхронизации",
              "var_2": "Управляемые блокировки снижают нагрузку на сервер СУБД за счёт переноса логики блокирования на сервер 1С, что ускоряет выполнение параллельных операций",
              "var_3": "Автоматические блокировки работают только в файловом режиме, а управляемые блокировки необходимы для корректной работы с СУБД в клиент-серверном варианте",
              "var_4": "Управляемые блокировки позволяют точно определить момент и объем блокируемых данных, минимизируя время удержания блокировки и снижая вероятность взаимоблокировок при параллельной работе",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Управляемые блокировки НЕ обрабатывают конфликты автоматически. Наоборот, они требуют от разработчика явного написания кода для установки блокировок и обработки возможных конфликтов и взаимоблокировок.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Управляемые блокировки НЕ снижают нагрузку на СУБД и НЕ переносят логику блокирования на сервер 1С. Блокировки все равно устанавливаются на уровне СУБД. Основное преимущество - контроль момента и объема блокировок разработчиком.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Автоматические блокировки работают и в клиент-серверном режиме с СУБД, не только в файловом режиме. Проблема автоматических блокировок не в режиме работы, а в отсутствии контроля над моментом и объемом блокирования.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение. Управляемые блокировки дают разработчику контроль над моментом установки блокировки и объемом блокируемых данных, что позволяет минимизировать время удержания блокировки и снизить вероятность deadlock при параллельной обработке.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую стратегию блокирования следует применить для параллельного проведения документов, изменяющих остатки одной и той же номенклатуры в регистре накопления?",
              "correct_answer": "Использовать управляемую блокировку с режимом Исключительная на уровне измерений регистра (номенклатура, склад), устанавливая её до чтения остатков в транзакции, чтобы исключить deadlock и обеспечить последовательную обработку конкурирующих документов.",
              "var_1": "Использовать автоматические блокировки платформы 1С без явного управления, так как СУБД самостоятельно определит оптимальную стратегию и разрешит конфликты через механизм версионирования записей регистра.",
              "var_2": "Применять блокировку с режимом Разделяемая на уровне записей регистра после чтения остатков, что позволит нескольким транзакциям одновременно читать данные и повысит параллелизм обработки, а конфликты разрешатся автоматически при записи движений регистра накопления.",
              "var_3": "Устанавливать управляемую блокировку после записи движений документа с режимом Разделяемая, что обеспечит корректность данных при параллельной обработке документов.",
              "var_4": "Использовать управляемую блокировку с режимом Исключительная на уровне измерений регистра (номенклатура, склад), устанавливая её до чтения остатков в транзакции, чтобы исключить deadlock и обеспечить последовательную обработку конкурирующих документов.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Автоматические блокировки СУБД недостаточны для сложной бизнес-логики 1С. При параллельном проведении документов с одной номенклатурой возникнут проблемы: lost updates (потерянные изменения), некорректные остатки, возможны deadlock'и. Механизм версионирования не решает проблему конкурентного доступа к остаткам.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Разделяемая блокировка ПОСЛЕ чтения остатков бесполезна - данные уже прочитаны без защиты. Разделяемые блокировки не предотвращают одновременную запись, только параллельное чтение. Конфликты при записи движений НЕ разрешатся автоматически корректно - возникнут проблемы с целостностью остатков (lost updates).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Блокировка ПОСЛЕ записи движений бессмысленна - данные уже изменены, транзакция фактически завершена. Разделяемая блокировка не защищает от конкурентной записи. Это не обеспечит корректность данных - блокировка должна устанавливаться ДО чтения остатков, а не после записи.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это корректная стратегия для многопоточной обработки. Исключительная блокировка на уровне измерений (номенклатура+склад) ДО чтения остатков предотвращает одновременную обработку документов с одинаковыми измерениями, исключает deadlock и гонки данных, обеспечивает последовательность обработки конкурирующих транзакций.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Проектирование запросов для распределенных информационных баз - учет обмена данными и минимизация конфликтов",
          "competency": "Запросы в 1С",
          "questions": [
            {
              "question": "Почему при проектировании запросов в РИБ следует избегать использования справочников с автонумерацией кодов в качестве измерений регистров?",
              "correct_answer": "Автонумерация генерирует коды независимо в узлах, создавая конфликты при обмене.",
              "var_1": "Автонумерация генерирует коды независимо в узлах, создавая конфликты при обмене.",
              "var_2": "Автонумерация справочников снижает производительность запросов к регистрам из-за индексации строковых ключей.",
              "var_3": "Коды автонумерации не поддерживаются механизмом регистрации изменений для обмена данными в РИБ.",
              "var_4": "Справочники с автонумерацией блокируют таблицы регистров при параллельном доступе из разных узлов РИБ.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "В РИБ каждый узел генерирует автонумерацию независимо, что приводит к созданию разных элементов справочника с одинаковыми кодами в разных узлах. При обмене данными это вызывает конфликты идентификации и дублирование элементов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Автонумерация кодов не связана с производительностью запросов к регистрам. В 1С измерения регистров хранят ссылки на элементы справочников, а не коды. Индексация и производительность не зависят от способа генерации кодов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Механизм регистрации изменений полностью поддерживает справочники с любым типом кодов, включая автонумерацию. Проблема не в механизме обмена, а в логике генерации одинаковых кодов в разных узлах.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Узлы РИБ работают автономно и не имеют параллельного доступа к одним и тем же таблицам в реальном времени. Блокировки возникают только внутри одной базы. Автонумерация не создает межузловых блокировок.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой механизм регистрации изменений следует использовать в запросах при разработке обмена для РИБ, чтобы избежать передачи данных, созданных на принимающем узле?",
              "correct_answer": "Использовать соединение с таблицей регистрации изменений, фильтруя данные где узел регистрации не равен принимающему узлу обмена.",
              "var_1": "Применять фильтрацию по полю ОбменДанными.Отправитель в запросе, исключая записи где отправитель соответствует текущему узлу информационной базы.",
              "var_2": "Использовать механизм версионирования объектов, сравнивая временные метки создания записей и передавая только те данные, которые были созданы раньше начала сеанса обмена.",
              "var_3": "Использовать регистрацию изменений с условием, где узел регистрации не равен текущему узлу отправителя, для формирования пакета обмена данными.",
              "var_4": "Использовать соединение с таблицей регистрации изменений, фильтруя данные где узел регистрации не равен принимающему узлу обмена.",
              "correct_position": 4,
              "fixes_applied": 1,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "ОбменДанными.Отправитель используется при ЗАГРУЗКЕ данных для отключения обработчиков, а не при ВЫГРУЗКЕ в запросах для фильтрации. Для фильтрации используется план обмена с регистрацией изменений и НомерОтправителя.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Версионирование и временные метки не являются стандартным механизмом РИБ для предотвращения зацикливания данных. В РИБ используется механизм регистрации изменений с учетом узлов отправителя/получателя.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Правильный подход: при формировании пакета обмена регистрируются изменения для конкретного узла-получателя, при этом система автоматически исключает данные, которые пришли с этого узла (по механизму НомерОтправителя).",
                "was_replaced": true,
                "original_before_fix": "Использовать регистрацию изменений с условием, где узел регистрации равен текущему узлу отправителя, для формирования пакета обмена данными."
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Некорректная формулировка: нужно фильтровать не по 'не равен принимающему узлу', а проверять что данные не пришли С принимающего узла (т.е. узел отправителя данных != узлу получателя обмена).",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Рекурсивные CTE в языке запросов 1С - проектирование запросов для обхода иерархических справочников с расчетом накопленных показателей",
          "competency": "Навыки работы с консолью запросов 1С",
          "questions": [
            {
              "question": "Почему язык запросов 1С не поддерживает рекурсивные CTE для обхода иерархических справочников?",
              "correct_answer": "Платформа не реализует конструкцию WITH RECURSIVE, используются встроенные операторы иерархии",
              "var_1": "Платформа не реализует конструкцию WITH RECURSIVE, используются встроенные операторы иерархии",
              "var_2": "Поддержка WITH RECURSIVE планируется в следующих версиях, сейчас используется временное ограничение платформы",
              "var_3": "CTE поддерживаются полностью, но рекурсия отключена из-за совместимости с файловым режимом работы базы",
              "var_4": "Рекурсия в запросах создаёт высокую нагрузку на СУБД, поэтому 1С блокирует такие конструкции на уровне платформы",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Верно. 1С не реализует синтаксис WITH RECURSIVE, вместо этого предоставляет встроенные средства для работы с иерархией: ИЕРАРХИЯ, В ИЕРАРХИИ и др.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Нет официальной информации о планах внедрения WITH RECURSIVE в 1С. Это не временное ограничение, а архитектурное решение платформы",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "CTE (Common Table Expressions) в принципе не поддерживаются в языке запросов 1С, не только рекурсивные. Это не связано с файловым режимом",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "1С не блокирует рекурсивные CTE из-за нагрузки на СУБД - платформа просто не реализует синтаксис WITH RECURSIVE в своем языке запросов",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой механизм в языке запросов 1С позволяет реализовать рекурсивный обход иерархического справочника для расчёта накопленного итога от корня до элемента?",
              "correct_answer": "Временные таблицы с итеративным наращиванием в цикле запросов, так как нативные рекурсивные CTE (WITH RECURSIVE) в языке запросов 1С не поддерживаются.",
              "var_1": "Механизм виртуальных таблиц СрезПоследних с параметром иерархии, который разворачивает дерево справочника до нужного уровня.",
              "var_2": "Временные таблицы с итеративным наращиванием в цикле запросов, так как нативные рекурсивные CTE (WITH RECURSIVE) в языке запросов 1С не поддерживаются.",
              "var_3": "Конструкция WITH RECURSIVE поддерживается в языке запросов 1С начиная с версии 8.3.18, что позволяет напрямую использовать рекурсивные CTE для обхода иерархий.",
              "var_4": "Использование вложенных запросов с оператором ИЕРАРХИЯ в секции ИЗ, который автоматически разворачивает все уровни подчинённости и рассчитывает накопленные итоги.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "СрезПоследних - это механизм для работы с регистрами сведений, а не для обхода иерархий справочников. Не предназначен для расчёта накопленных итогов по дереву.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это корректный подход: в 1С действительно отсутствует нативная поддержка WITH RECURSIVE, поэтому используются временные таблицы с циклическим добавлением уровней иерархии.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Язык запросов 1С не поддерживает конструкцию WITH RECURSIVE ни в одной версии платформы 8.3, включая 8.3.18 и более поздние.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Оператор ИЕРАРХИЯ позволяет развернуть иерархию, но не рассчитывает автоматически накопленные итоги - это требует дополнительной логики в запросе.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Консоль заданий 1С - стратегии распределения регламентных заданий между рабочими процессами кластера для балансировки нагрузки",
          "competency": "Навыки работы с консолью заданий 1С",
          "questions": [
            {
              "question": "Почему платформа 1С при высокой загрузке кластера может откладывать выполнение регламентных заданий вместо немедленного запуска по расписанию?",
              "correct_answer": "Менеджер кластера оценивает доступность ресурсов рабочих процессов и ожидает освобождения соединений, предотвращая деградацию производительности интерактивных пользователей",
              "var_1": "Менеджер кластера оценивает доступность ресурсов рабочих процессов и ожидает освобождения соединений, предотвращая деградацию производительности интерактивных пользователей",
              "var_2": "Регламентные задания имеют встроенную задержку запуска для синхронизации времени между серверами кластера и предотвращения коллизий при выполнении",
              "var_3": "Планировщик заданий проверяет наличие свободных лицензий и откладывает запуск до их появления, приоритет отдаётся интерактивным сеансам пользователей",
              "var_4": "Платформа ожидает завершения блокировок в базе данных СУБД, так как регламентные задания требуют монопольного доступа к таблицам информационной базы",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это корректный ответ. Менеджер кластера действительно оценивает загрузку рабочих процессов и может откладывать запуск регламентных заданий при высокой нагрузке, чтобы не ухудшать производительность для интерактивных пользователей.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "В 1С нет встроенной задержки для синхронизации времени между серверами. Задания запускаются согласно расписанию без искусственных задержек для предотвращения коллизий.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Планировщик не откладывает задания из-за лицензий. Регламентные задания выполняются без потребления клиентских лицензий и не зависят от их доступности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Регламентные задания не требуют монопольного доступа к таблицам и не ожидают завершения блокировок как условие запуска. Они работают в обычном режиме транзакций.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую стратегию назначения требований к функциональности рабочих серверов вы примените для изоляции тяжелых регламентных заданий обмена данными от пользовательских сессий в кластере из четырех серверов?",
              "correct_answer": "Выделить отдельный рабочий сервер с требованием 'BackgroundJob' и объектом требования для конкретных заданий обмена, отключив на нём пользовательские сессии через требование 'ClientConnection' с нулевым приоритетом.",
              "var_1": "Настроить на всех серверах требование 'BackgroundJob' с разными приоритетами, позволив кластеру автоматически распределять задания между серверами по мере загрузки.",
              "var_2": "Выделить отдельный рабочий сервер с требованием 'BackgroundJob' и объектом требования для конкретных заданий обмена, отключив на нём пользовательские сессии через требование 'ClientConnection' с нулевым приоритетом.",
              "var_3": "Выделить сервер с требованием 'RegularTask' и отключить на нём rphost для пользовательских соединений через консоль администрирования.",
              "var_4": "Использовать требование 'ScheduledJob' для всех четырёх серверов с равномерным распределением приоритетов, настроив балансировку нагрузки через объект требования 'LoadBalance' и ограничив пользовательские сессии через максимальное количество соединений.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Требование 'BackgroundJob' не существует в 1С. Для фоновых заданий используется требование функциональности с указанием конкретного регламентного задания. Приоритеты не обеспечивают изоляцию тяжелых заданий от пользовательских сессий.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Правильный подход для senior-уровня: выделение отдельного сервера с требованием функциональности для фоновых заданий, указание конкретных заданий обмена через объект требования, и отключение пользовательских сессий через отключение ClientConnection обеспечивает полную изоляцию.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Требование 'RegularTask' не существует в 1С. Отключение rphost через консоль администрирования не является механизмом назначения требований к функциональности рабочих серверов, это другой уровень управления кластером.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Требование 'ScheduledJob' и объект требования 'LoadBalance' не существуют в 1С. Равномерное распределение приоритетов не обеспечивает изоляцию тяжелых заданий. Ограничение через максимальное количество соединений не является механизмом требований к функциональности.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Рефакторинг запросов конструктора - анализ и реорганизация структуры соединений для устранения избыточных вложенных подзапросов",
          "competency": "Навыки работы с конструктором запросов 1С",
          "questions": [
            {
              "question": "Почему замена вложенных подзапросов на временные таблицы повышает производительность соединений в конструкторе запросов 1С?",
              "correct_answer": "Временные таблицы материализуются однократно и можно явно задать индексы через ИНДЕКСИРОВАТЬ ПО.",
              "var_1": "Временные таблицы материализуются однократно и можно явно задать индексы через ИНДЕКСИРОВАТЬ ПО.",
              "var_2": "Временные таблицы автоматически кешируются на сервере СУБД без дополнительных затрат.",
              "var_3": "Временные таблицы хранятся на диске сервера, что ускоряет повторные обращения к ним.",
              "var_4": "Вложенные подзапросы блокируют основные таблицы, а временные таблицы работают изолированно.",
              "correct_position": 1,
              "fixes_applied": 1,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это ключевое преимущество временных таблиц: они материализуются один раз, а конструкция ИНДЕКСИРОВАТЬ ПО позволяет явно создать индексы для оптимизации соединений, что невозможно для вложенных подзапросов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Временные таблицы не кешируются автоматически на уровне СУБД. Они создаются и удаляются в рамках сессии, а их производительность зависит от явного индексирования и однократной материализации, а не от автоматического кеширования.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Временные таблицы в 1С действительно хранятся в оперативной памяти (или в tempdb СУБД), что обеспечивает быстрый доступ при многократных обращениях к ним в рамках одного запроса или пакета запросов.",
                "was_replaced": true,
                "original_before_fix": "Временные таблицы хранятся в оперативной памяти, что ускоряет повторные обращения к ним."
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Вложенные подзапросы не блокируют основные таблицы больше, чем временные. Проблема подзапросов в их многократном выполнении и невозможности индексирования, а не в блокировках. Временные таблицы используют те же механизмы блокировок СУБД.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой подход рефакторинга применить для замены вложенного подзапроса в соединении, если он фильтрует данные по условию и используется только для проверки существования записей?",
              "correct_answer": "Заменить на внутреннее соединение (INNER JOIN) с основной таблицей или использовать конструкцию В (подзапрос) для проверки вхождения.",
              "var_1": "Заменить на внутреннее соединение (INNER JOIN) с основной таблицей или использовать конструкцию В (подзапрос) для проверки вхождения.",
              "var_2": "Использовать конструкцию ЛЕВОЕ СОЕДИНЕНИЕ с дополнительной проверкой на NULL в условии ГДЕ, что позволит сохранить все записи и отфильтровать нужные.",
              "var_3": "Преобразовать вложенный подзапрос в временную таблицу с индексацией, а затем выполнить левое соединение с основной таблицей для оптимизации плана выполнения.",
              "var_4": "Заменить на коррелированный подзапрос в секции ВЫБРАТЬ с использованием функции ЕСТЬNULL для обработки отсутствующих значений в результате.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "INNER JOIN или конструкция В (IN) - оптимальные способы замены вложенного подзапроса для проверки существования записей, устраняют избыточность и улучшают читаемость.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "ЛЕВОЕ СОЕДИНЕНИЕ с проверкой NULL сохраняет все записи из левой таблицы, но для проверки существования это избыточно и менее эффективно, чем INNER JOIN или IN.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Создание временной таблицы добавляет излишнюю сложность и накладные расходы на создание и индексацию. Для простой проверки существования это избыточное решение.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Коррелированный подзапрос в SELECT с ЕСТЬNULL не заменяет подзапрос для проверки существования, а добавляет вычисляемое поле, что ухудшает производительность.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Архитектура очередей заданий - реализация системы динамической приоритизации и балансировки нагрузки между рабочими процессами кластера",
          "competency": "Работа с очередью и фоновыми заданиями 1С",
          "questions": [
            {
              "question": "Почему при реализации динамической приоритизации фоновых заданий в кластере 1С нельзя полагаться исключительно на встроенные механизмы приоритетов?",
              "correct_answer": "Встроенные приоритеты не учитывают текущую загрузку кластера и бизнес-контекст заданий.",
              "var_1": "Встроенные приоритеты не учитывают текущую загрузку кластера и бизнес-контекст заданий.",
              "var_2": "Система приоритетов платформы требует лицензию КОРП и недоступна в базовых версиях серверных лицензий 1С.",
              "var_3": "Встроенные механизмы приоритетов работают только на уровне сервера приложений и не передаются в кластер СУБД для оптимизации.",
              "var_4": "Приоритеты заданий сбрасываются при каждом перезапуске рабочих процессов кластера.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это корректный ответ. Встроенные приоритеты в 1С статичны и устанавливаются при создании задания. Они не учитывают динамическую загрузку кластера, не анализируют текущее состояние ресурсов и не могут учитывать изменяющийся бизнес-контекст (например, срочность обработки документов в конце отчетного периода).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Механизмы приоритетов фоновых заданий доступны во всех редакциях платформы 1С:Предприятие, включая базовые серверные лицензии. Это не функция, ограниченная лицензией КОРП.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Приоритеты заданий работают на уровне менеджера кластера и влияют на распределение заданий между рабочими процессами. Они не связаны напрямую с передачей приоритетов в СУБД - это разные уровни архитектуры.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Приоритеты заданий хранятся в базе данных и не сбрасываются при перезапуске рабочих процессов. Они персистентны и сохраняются между перезапусками.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой механизм вы реализуете для предотвращения голодания низкоприоритетных фоновых заданий при постоянном потоке высокоприоритетных в очереди 1С?",
              "correct_answer": "Реализую механизм aging — постепенное повышение приоритета заданий в зависимости от времени ожидания в очереди, используя регистр сведений с отметками времени постановки и периодический пересчёт эффективного приоритета.",
              "var_1": "Реализую механизм aging — постепенное повышение приоритета заданий в зависимости от времени ожидания в очереди, используя регистр сведений с отметками времени постановки и периодический пересчёт эффективного приоритета.",
              "var_2": "Настраиваю в консоли кластера параметр «Квота низкоприоритетных заданий», который автоматически обеспечивает гарантированный запуск определённого числа таких заданий в час.",
              "var_3": "Реализую механизм случайного выбора заданий из очереди с весовыми коэффициентами, что статистически гарантирует выполнение всех приоритетов.",
              "var_4": "Использую жёсткое ограничение количества одновременно выполняемых высокоприоритетных заданий через параметры кластера, резервируя фиксированный процент рабочих процессов исключительно для низкоприоритетных задач независимо от текущей загрузки системы.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Механизм aging (старения) — классическое и эффективное решение проблемы голодания в теории очередей. Постепенное повышение приоритета по времени ожидания гарантирует, что любое задание рано или поздно достигнет приоритета достаточного для выполнения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "В консоли кластера 1С не существует параметра «Квота низкоприоритетных заданий». Это выдуманный параметр, которого нет в стандартных настройках платформы 1С:Предприятие.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Случайный выбор с весами не гарантирует предотвращение голодания при постоянном потоке высокоприоритетных заданий. Статистическая вероятность не решает проблему, когда высокоприоритетные задачи постоянно доминируют.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Жёсткая резервация процессов для низкоприоритетных задач неэффективна и не является оптимальным решением. Это приводит к простою ресурсов и снижению общей производительности системы, не решая проблему голодания гибко.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        }
      ]
    }
  }
}