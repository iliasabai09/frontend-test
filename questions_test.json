{
  "profile": "Frontend Developer (Angular)",
  "specialization": "Frontend Developer (Angular)",
  "file_name": "SA_Frontend_30",
  "levels": {
    "junior": {
      "themes": [
        {
          "theme": "CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету",
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "questions": [
            {
              "question": "Почему свойство grid-template-columns с repeat(auto-fit, minmax()) позволяет создавать адаптивные сетки без медиа-запросов?",
              "correct_answer": "Браузер автоматически вычисляет количество колонок, умещающихся в контейнер при заданных минимальных и максимальных размерах",
              "var_1": "Функция repeat() автоматически добавляет скрытые медиа-запросы в CSS, которые обрабатывает браузер",
              "var_2": "Значение auto-fit заставляет элементы сетки растягиваться на всю ширину, игнорируя заданные размеры колонок",
              "var_3": "Браузер автоматически вычисляет количество колонок, умещающихся в контейнер при заданных минимальных и максимальных размерах",
              "var_4": "minmax() создаёт фиксированные точки перелома на основе минимальных размеров, аналогично breakpoints в CSS",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "repeat() не добавляет никаких медиа-запросов. Адаптивность достигается за счёт встроенного алгоритма CSS Grid, который вычисляет layout на основе доступного пространства и параметров функций.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "auto-fit не заставляет элементы растягиваться, игнорируя размеры. Он сворачивает пустые треки, а растяжение элементов происходит из-за второго параметра minmax() (обычно 1fr), но размеры колонок всё равно учитываются.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильное объяснение. Браузер динамически рассчитывает, сколько колонок с размерами между min и max из minmax() поместится в доступную ширину контейнера, автоматически адаптируя макет.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "minmax() не создаёт фиксированные точки перелома как breakpoints. Вместо этого он задаёт диапазон допустимых размеров для колонок, а браузер плавно пересчитывает их количество при изменении ширины.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какое CSS Grid свойство следует использовать для создания адаптивной сетки карточек товаров с автоматическим переносом на новую строку?",
              "correct_answer": "grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)) — автоматически подстраивает количество колонок под ширину контейнера с минимальной шириной карточки.",
              "var_1": "grid-template-columns: repeat(auto-fill, 250px) — жёстко фиксирует ширину каждой карточки в 250 пикселей, автоматически создавая нужное количество колонок для заполнения контейнера.",
              "var_2": "grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)) — автоматически подстраивает количество колонок под ширину контейнера с минимальной шириной карточки.",
              "var_3": "flex-wrap: wrap — обеспечивает автоматический перенос карточек на новую строку при нехватке места в контейнере.",
              "var_4": "grid-auto-flow: dense — автоматически заполняет пустые ячейки сетки карточками и управляет переносом элементов на новые строки.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Хотя repeat(auto-fill, 250px) создаёт колонки автоматически, жёсткая фиксация в 250px без minmax делает решение неадаптивным - карточки не растягиваются на доступное пространство",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильное решение: auto-fit с minmax(250px, 1fr) создаёт адаптивную сетку, автоматически подстраивая количество колонок под контейнер с минимальной шириной 250px",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "flex-wrap: wrap - это свойство Flexbox, а не CSS Grid. Вопрос явно спрашивает про CSS Grid свойство",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "grid-auto-flow: dense управляет алгоритмом размещения элементов в уже существующей сетке, заполняя пустоты, но не создаёт адаптивную сетку с автоматическим переносом",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Условные операторы - реализация условного отображения элементов UI",
          "competency": "Знание языка программирования JavaScript",
          "questions": [
            {
              "question": "Почему при условном отображении элементов в JavaScript предпочтительнее использовать тернарный оператор вместо if-else для присваивания значений переменным?",
              "correct_answer": "Тернарный оператор является выражением и возвращает значение, в отличие от if-else, который является инструкцией",
              "var_1": "If-else занимает больше памяти, поэтому тернарный оператор экономит ресурсы при рендеринге UI",
              "var_2": "Тернарный оператор является выражением и возвращает значение, в отличие от if-else, который является инструкцией",
              "var_3": "Тернарный оператор автоматически приводит типы данных, что упрощает работу с условиями в JavaScript",
              "var_4": "Тернарный оператор работает быстрее, так как компилятор оптимизирует его лучше чем if-else",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "If-else и тернарный оператор не имеют значимой разницы в потреблении памяти. Оба варианта занимают примерно одинаковое количество памяти при выполнении.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Тернарный оператор — это выражение, которое возвращает значение и может быть присвоено переменной или передано как аргумент. If-else — это инструкция (statement), которая не возвращает значение напрямую.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Тернарный оператор не выполняет автоматическое приведение типов. Приведение типов в условиях работает одинаково для обоих операторов согласно правилам JavaScript.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Нет существенной разницы в производительности между тернарным оператором и if-else. Современные JavaScript-движки оптимизируют оба варианта примерно одинаково.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой условный оператор JavaScript вы используете для отображения кнопки 'Выйти' только авторизованным пользователям?",
              "correct_answer": "Тернарный оператор: isLoggedIn ? '<button>Выйти</button>' : '' или условие if с проверкой флага авторизации перед рендерингом элемента.",
              "var_1": "Оператор ?? (nullish coalescing): user ?? '<button>Выйти</button>' для условного рендеринга элемента.",
              "var_2": "Оператор || для fallback: isLoggedIn || '<button>Выйти</button>' — если пользователь не авторизован, покажется кнопка.",
              "var_3": "Тернарный оператор: isLoggedIn ? '<button>Выйти</button>' : '' или условие if с проверкой флага авторизации перед рендерингом элемента.",
              "var_4": "Оператор switch для проверки состояния пользователя: switch(userState) { case 'logged': return '<button>Выйти</button>'; } — универсальный способ.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Оператор ?? проверяет null/undefined, а не булево значение авторизации. Если user существует (даже неавторизованный объект), кнопка не покажется.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Оператор || работает наоборот: если isLoggedInfalsy (не авторизован), то вернется правая часть с кнопкой. Это перевёрнутая логика - кнопка покажется неавторизованным.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Тернарный оператор и if с проверкой флага - стандартные и корректные способы условного рендеринга элементов в зависимости от статуса авторизации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Switch можно использовать, но он не является универсальным способом для простой булевой проверки авторизации. Для условного отображения UI по флагу авторизации более идиоматичны if или тернарный оператор.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Union и Literal типы - типизация состояний компонента и параметров конфигурации",
          "competency": "Знание языка программирования TypeScript",
          "questions": [
            {
              "question": "Почему использование Literal типов для состояний компонента надёжнее, чем обычных строк?",
              "correct_answer": "TypeScript проверяет допустимые значения на этапе компиляции, предотвращая опечатки и недопустимые состояния",
              "var_1": "TypeScript проверяет допустимые значения на этапе компиляции, предотвращая опечатки и недопустимые состояния",
              "var_2": "Literal типы позволяют IDE показывать автодополнение, но не влияют на проверку ошибок компилятором",
              "var_3": "Literal типы автоматически конвертируют строки в нужный формат во время выполнения программы",
              "var_4": "Literal типы занимают меньше памяти чем обычные строки и ускоряют работу приложения в браузере",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Literal типы позволяют TypeScript проверять на этапе компиляции, что используются только допустимые значения из заданного набора, предотвращая опечатки и присвоение некорректных состояний компоненту.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Literal типы действительно обеспечивают автодополнение в IDE, но также критически важно, что они влияют на проверку ошибок компилятором TypeScript - это их основное преимущество. Вариант утверждает обратное.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Literal типы - это механизм статической типизации TypeScript, работающий на этапе компиляции. Они не выполняют никакой конвертации строк во время выполнения (runtime), так как после компиляции весь TypeScript превращается в обычный JavaScript.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Literal типы существуют только на этапе компиляции TypeScript. После компиляции в JavaScript они исчезают и представляют собой обычные строки. Они не влияют на потребление памяти или производительность runtime.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой Union тип следует использовать для типизации состояния загрузки данных в Angular-компоненте?",
              "correct_answer": "type LoadingState = 'idle' | 'loading' | 'success' | 'error' — Literal Union тип с конкретными строковыми значениями состояний.",
              "var_1": "type LoadingState = boolean | null — использовать примитивные типы, где true означает загрузку, false — успех, null — начальное состояние.",
              "var_2": "type LoadingState = 'idle' | 'loading' | 'success' | 'error' — Literal Union тип с конкретными строковыми значениями состояний.",
              "var_3": "type LoadingState = number — числовые коды состояний (0, 1, 2, 3) более производительны для проверок в шаблонах.",
              "var_4": "type LoadingState = string — строковый тип позволяет гибко добавлять новые состояния без изменения типа.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Использование boolean | null семантически неясно и не позволяет различить состояние ошибки, что критично для обработки загрузки данных",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Literal Union тип с конкретными значениями обеспечивает type safety, автодополнение в IDE, явную семантику и покрывает все необходимые состояния загрузки",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Числовые коды не обеспечивают читаемость и семантичность кода, требуют дополнительной документации для понимания значений и не дают преимуществ в производительности",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Строковый тип (string) не обеспечивает type safety - позволяет любые строковые значения, что делает невозможным отлов ошибок на этапе компиляции",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Классы и объекты - создание TypeScript-классов для моделей данных компонентов",
          "competency": "Базовая теория программирования, ООП",
          "questions": [
            {
              "question": "Почему в TypeScript-классах моделей данных рекомендуется использовать модификатор readonly для полей, которые не должны изменяться после создания объекта?",
              "correct_answer": "Readonly обеспечивает иммутабельность на этапе компиляции, предотвращая случайное изменение данных и делая код предсказуемым",
              "var_1": "Readonly делает поля приватными по умолчанию и недоступными для чтения из других классов компонента",
              "var_2": "Readonly обеспечивает иммутабельность на этапе компиляции, предотвращая случайное изменение данных и делая код предсказуемым",
              "var_3": "Readonly уменьшает размер скомпилированного JavaScript-кода, убирая лишние проверки на изменение значений",
              "var_4": "Readonly автоматически создаёт геттеры для всех полей класса, упрощая доступ к данным извне",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Readonly не делает поля приватными. Он только предотвращает изменение значения после инициализации, но не влияет на модификаторы доступа (public/private/protected). Поля остаются доступными для чтения согласно их модификатору доступа.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это верный ответ. Readonly действительно обеспечивает иммутабельность на уровне компиляции TypeScript, предотвращая случайные изменения полей после их инициализации, что делает код более предсказуемым и безопасным.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Readonly - это конструкция TypeScript, которая проверяется только на этапе компиляции и полностью исчезает в скомпилированном JavaScript-коде. Она не добавляет и не убирает никаких проверок в runtime, поэтому не влияет на размер итогового кода.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Readonly не создаёт автоматически геттеры. Это просто модификатор, который запрещает присваивание новых значений полю после инициализации. Для создания геттеров нужно использовать синтаксис get accessor() или другие механизмы.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой модификатор следует использовать для свойства id модели User, чтобы оно было доступно только для чтения после создания объекта?",
              "correct_answer": "Модификатор readonly — позволяет установить значение только при инициализации или в конструкторе.",
              "var_1": "Модификатор private — делает свойство недоступным извне класса, что автоматически защищает его от изменения.",
              "var_2": "Модификатор static — фиксирует значение на уровне класса и предотвращает изменения.",
              "var_3": "Модификатор const — запрещает изменение значения свойства после его первого присвоения.",
              "var_4": "Модификатор readonly — позволяет установить значение только при инициализации или в конструкторе.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Модификатор private делает свойство недоступным извне класса, но не защищает от изменения внутри класса. Это про инкапсуляцию, а не про защиту от записи.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Модификатор static делает свойство принадлежащим классу, а не экземпляру, и не предотвращает изменения. Static-свойства можно изменять.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "В TypeScript нет модификатора const для свойств класса. Const используется для объявления переменных, но не применим к свойствам класса.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Модификатор readonly действительно позволяет установить значение свойства только при инициализации или в конструкторе, после чего свойство становится доступным только для чтения.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Фиксация изменений - составление понятных commit-сообщений при изменении TypeScript кода",
          "competency": "Знание Git",
          "questions": [
            {
              "question": "Почему в commit-сообщении для TypeScript кода важно указывать затронутый компонент или модуль?",
              "correct_answer": "Позволяет быстро найти связанные изменения в истории и понять область влияния коммита",
              "var_1": "Помогает Angular CLI автоматически генерировать документацию для изменённых файлов",
              "var_2": "Позволяет быстро найти связанные изменения в истории и понять область влияния коммита",
              "var_3": "Указание компонента позволяет TypeScript компилятору оптимизировать сборку только изменённых модулей проекта",
              "var_4": "Это требование Git для корректной работы системы версионирования и автоматического создания веток по компонентам",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Angular CLI не использует commit-сообщения для автоматической генерации документации. Документация создаётся из комментариев в коде (JSDoc/TSDoc) и специальных инструментов вроде Compodoc.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Указание компонента/модуля в commit-сообщении - это best practice для навигации по истории изменений. Позволяет быстро фильтровать коммиты по областям, понимать контекст изменений и оценивать потенциальное влияние на другие части приложения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "TypeScript компилятор не использует commit-сообщения для оптимизации сборки. Оптимизация зависит от конфигурации tsconfig.json и системы сборки, а не от текста коммитов в Git.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Git не требует указания компонентов в commit-сообщениях для своей работы. Это соглашение команды разработчиков для удобства, а не техническое требование системы контроля версий.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какое commit-сообщение будет наиболее информативным при добавлении валидации email в компоненте регистрации Angular?",
              "correct_answer": "feat(registration): add email validation to registration form - описывает тип изменения, область и суть действия по conventional commits",
              "var_1": "added email validation - добавлена валидация email в форме регистрации с проверкой корректности ввода пользователя",
              "var_2": "fix(auth): update registration component - исправлено поле email, добавлена проверка формата адреса пользователя",
              "var_3": "feat(registration): add email validation to registration form - описывает тип изменения, область и суть действия по conventional commits",
              "var_4": "refactor(registration): email validation - улучшена структура кода валидации email в компоненте регистрации",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Не следует стандарту conventional commits, отсутствует тип изменения (feat/fix), область (scope) и структурированный формат",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Неверный тип изменения 'fix' (это новая функция, а не исправление бага), плюс некорректная область 'auth' вместо 'registration'",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Полностью соответствует conventional commits: есть тип 'feat' (новая функциональность), scope 'registration', четкое описание действия",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Неверный тип 'refactor' - это добавление новой функциональности (валидации), а не рефакторинг существующего кода",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Template-driven Forms - работа с NgModel и директивами для двусторонней привязки данных",
          "competency": "Формы (Template/Reactive, валидаторы)",
          "questions": [
            {
              "question": "Почему для работы NgModel необходимо импортировать FormsModule в модуль приложения?",
              "correct_answer": "FormsModule содержит директиву NgModel и инфраструктуру для отслеживания изменений форм",
              "var_1": "FormsModule подключает HTTP-клиент для отправки данных форм на сервер",
              "var_2": "NgModel работает без FormsModule, но импорт нужен для корректной компиляции",
              "var_3": "FormsModule автоматически добавляет валидаторы ко всем полям ввода и управляет состоянием всей формы",
              "var_4": "FormsModule содержит директиву NgModel и инфраструктуру для отслеживания изменений форм",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "FormsModule не имеет отношения к HTTP-клиенту. Он предоставляет директивы для работы с формами, а не функциональность для отправки данных на сервер.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "NgModel НЕ работает без FormsModule. Без импорта FormsModule Angular не распознает директиву NgModel и выдаст ошибку компиляции о неизвестной директиве.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "FormsModule не добавляет валидаторы автоматически ко всем полям. Валидаторы нужно явно указывать через атрибуты HTML (required, minlength и т.д.) или программно.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "FormsModule действительно экспортирует директиву NgModel и всю необходимую инфраструктуру для Template-driven форм, включая механизмы отслеживания изменений значений и состояния формы.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой атрибут нужно добавить к input с ngModel, чтобы форма могла отслеживать это поле по имени?",
              "correct_answer": "Атрибут name — он обязателен для регистрации контрола в форме и доступа к его состоянию через ngForm.",
              "var_1": "Атрибут ngModelName — он задаёт имя контрола и связывает его с формой через ngForm.",
              "var_2": "Атрибут formControlName — он регистрирует поле в форме и обеспечивает доступ к состоянию через родительскую директиву формы.",
              "var_3": "Атрибут name — он обязателен для регистрации контрола в форме и доступа к его состоянию через ngForm.",
              "var_4": "Атрибут id — он необходим для связывания контрола с DOM-элементом и позволяет форме идентифицировать поле по уникальному идентификатору.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Директивы ngModelName не существует в Angular. Для регистрации контрола в template-driven формах используется атрибут name, а не ngModelName.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Атрибут formControlName используется в reactive формах (с FormGroup/FormControl), а не в template-driven формах с ngModel. Это разные подходы к работе с формами в Angular.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Атрибут name действительно обязателен при использовании ngModel в template-driven формах. Он регистрирует контрол в NgForm и позволяет отслеживать его состояние через form.controls['name'].",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Атрибут id используется для идентификации DOM-элемента и связи с label, но не имеет отношения к регистрации контрола в форме. NgForm не использует id для отслеживания полей.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Санитизация контента - применение DomSanitizer для очистки HTML, URL и стилей от вредоносного кода",
          "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
          "questions": [
            {
              "question": "Почему Angular по умолчанию блокирует вставку HTML-кода через интерполяцию в шаблонах?",
              "correct_answer": "Для защиты от XSS-атак путём автоматической санитизации потенциально опасного контента",
              "var_1": "Для защиты от XSS-атак путём автоматической санитизации потенциально опасного контента",
              "var_2": "Потому что интерполяция предназначена только для текстовых данных и не поддерживает разметку технически",
              "var_3": "Для повышения производительности рендеринга, так как парсинг HTML требует дополнительных ресурсов браузера",
              "var_4": "Для обеспечения совместимости с серверным рендерингом, где DOM-операции работают иначе",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Верно. Angular автоматически экранирует HTML в интерполяции ({{ }}) для предотвращения XSS-атак, преобразуя специальные символы в безопасные HTML-entities.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Это не техническое ограничение интерполяции. Angular намеренно экранирует HTML в интерполяции по соображениям безопасности, а не из-за технической невозможности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Производительность не является причиной блокировки HTML. Основная цель - безопасность приложения от XSS-атак, а не оптимизация производительности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Совместимость с серверным рендерингом не является причиной блокировки HTML в интерполяции. Это связано исключительно с безопасностью.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой метод DomSanitizer нужно вызвать для безопасной вставки HTML-разметки из внешнего источника в Angular компонент?",
              "correct_answer": "Метод sanitize() с SecurityContext.HTML, который очищает HTML от потенциально опасного кода.",
              "var_1": "Метод trustAsHtml(), который помечает HTML как безопасный для вставки в шаблон.",
              "var_2": "Метод bypassSecurityTrustHtml(), который полностью отключает санитизацию и доверяет любому HTML-коду из источника.",
              "var_3": "Метод sanitize() с SecurityContext.URL, который автоматически очищает HTML и URL от вредоносного контента.",
              "var_4": "Метод sanitize() с SecurityContext.HTML, который очищает HTML от потенциально опасного кода.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Метод trustAsHtml() не существует в DomSanitizer. Реальный метод называется bypassSecurityTrustHtml(), и он не санитизирует контент.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "bypassSecurityTrustHtml() не выполняет санитизацию, а обходит защиту Angular, помечая контент как доверенный. Это опасно для внешних источников.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "SecurityContext.URL предназначен для санитизации URL, а не HTML. Неправильный контекст безопасности для данной задачи.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "sanitize() с SecurityContext.HTML - правильный метод для безопасной вставки HTML из внешних источников, удаляет опасные элементы и атрибуты.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Computed signals - добавление производных вычислений для фильтрации и трансформации данных в сервисах",
          "competency": "Состояние приложения (signals services)",
          "questions": [
            {
              "question": "Почему computed signal автоматически пересчитывается при изменении исходных сигналов, а не при каждом обращении?",
              "correct_answer": "Angular отслеживает зависимости и кэширует результат, пересчитывая только при изменении зависимых сигналов для оптимизации производительности",
              "var_1": "Angular отслеживает зависимости и кэширует результат, пересчитывая только при изменении зависимых сигналов для оптимизации производительности",
              "var_2": "Computed signal пересчитывается при изменении исходных сигналов потому что браузер использует механизм MutationObserver для отслеживания любых изменений в DOM-дереве приложения",
              "var_3": "Пересчёт происходит через систему polling с интервалом проверки, что более эффективно чем постоянное обращение к значению",
              "var_4": "Angular использует dirty-checking на каждом цикле обнаружения изменений для проверки computed сигналов",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Angular Signals использует реактивную систему с отслеживанием зависимостей. Computed signal автоматически регистрирует все сигналы, которые читаются во время вычисления, кэширует результат и пересчитывает его только когда один из зависимых сигналов изменяется. Это обеспечивает оптимальную производительность.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "MutationObserver - это браузерный API для отслеживания изменений DOM, он не имеет отношения к механизму работы computed signals, которые работают на уровне состояния приложения, а не DOM.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Computed signals не используют polling. Они работают на основе реактивной системы push-based, где изменения распространяются мгновенно через граф зависимостей, а не через периодические проверки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Angular Signals не используют dirty-checking. Это механизм старого подхода с Zone.js. Computed signals работают на основе реактивной системы с отслеживанием зависимостей.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как создать computed signal для отображения только выполненных задач из списка todos в сервисе?",
              "correct_answer": "Использовать computed(() => this.todos().filter(todo => todo.completed)), который автоматически обновляется при изменении todos.",
              "var_1": "Использовать computed(() => this.todos().filter(todo => todo.completed)), который автоматически обновляется при изменении todos.",
              "var_2": "Создать effect(() => this.completedTodos = this.todos().filter(todo => todo.completed)) для отслеживания.",
              "var_3": "Использовать this.todos.filter(todo => todo.completed) напрямую в шаблоне для фильтрации данных.",
              "var_4": "Использовать signal(() => this.todos().filter(todo => todo.completed)) для создания производного сигнала.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Правильное использование computed для создания производного сигнала. Computed автоматически отслеживает зависимости и пересчитывается при изменении todos.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "effect() предназначен для побочных эффектов, а не для создания computed signals. Присвоение обычному свойству не создает реактивный сигнал.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "this.todos без вызова () не является вызовом сигнала. Нужно this.todos(), но фильтрация в шаблоне не создает computed signal в сервисе, как требуется в вопросе.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "signal() не принимает функцию для создания производных значений. Для этого используется computed(). signal() создает writable сигнал с начальным значением.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "HTTP интерцепторы - подключение готовых интерцепторов для добавления заголовков и обработки токенов",
          "competency": "HTTP/интерцепторы/типизация API",
          "questions": [
            {
              "question": "Почему HTTP интерцепторы в Angular необходимо добавлять в массив провайдеров в определённом порядке?",
              "correct_answer": "Потому что запросы проходят через интерцепторы последовательно в порядке их регистрации, а ответы — в обратном порядке",
              "var_1": "Порядок регистрации интерцепторов влияет на приоритет их выполнения — интерцепторы с более высоким приоритетом обрабатывают ошибки первыми",
              "var_2": "Angular использует порядок интерцепторов для определения зависимостей между ними и автоматического внедрения необходимых сервисов",
              "var_3": "Порядок нужен для корректной сериализации запросов, иначе они могут отправиться одновременно и вызвать конфликты",
              "var_4": "Потому что запросы проходят через интерцепторы последовательно в порядке их регистрации, а ответы — в обратном порядке",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "В Angular нет концепции приоритета интерцепторов. Порядок выполнения определяется исключительно порядком регистрации в массиве провайдеров, а не какими-то приоритетами для обработки ошибок.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Angular не использует порядок интерцепторов для определения зависимостей. Зависимости внедряются через DI стандартным образом, независимо от порядка регистрации интерцепторов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Интерцепторы не связаны с сериализацией запросов и не предотвращают одновременную отправку. Запросы могут отправляться параллельно независимо от порядка интерцепторов. Каждый запрос проходит через всю цепочку интерцепторов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильное описание работы интерцепторов в Angular. Запросы проходят через цепочку интерцепторов в прямом порядке (как они зарегистрированы), а ответы обрабатываются в обратном порядке (как при выходе из вложенных функций).",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой метод интерцептора нужно использовать для добавления Authorization заголовка к каждому исходящему HTTP-запросу?",
              "correct_answer": "Метод intercept, в котором клонируем запрос через req.clone() и добавляем заголовок через setHeaders: { Authorization: 'Bearer ' + token }.",
              "var_1": "Метод intercept, где напрямую модифицируем req.headers.set('Authorization', token) без клонирования исходного запроса.",
              "var_2": "Метод transform, в котором создаём новый запрос и устанавливаем заголовок через request.addHeader({ Authorization: 'Bearer ' + token }).",
              "var_3": "Метод intercept, в котором клонируем запрос через req.clone() и добавляем заголовок через setHeaders: { Authorization: 'Bearer ' + token }.",
              "var_4": "Метод handle, который автоматически перехватывает все запросы и позволяет напрямую модифицировать заголовки через req.headers.append('Authorization', token).",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "HttpRequest в Angular является immutable объектом, поэтому нельзя напрямую модифицировать req.headers.set(). Необходимо клонировать запрос через req.clone().",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "В Angular HttpInterceptor нет метода transform(). Также не существует метода addHeader() для HttpRequest. Правильный метод - intercept().",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный подход: используется метод intercept(), запрос клонируется через req.clone() (т.к. HttpRequest immutable), и заголовок добавляется через setHeaders.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Метод handle() не является методом для перехвата запросов - это метод HttpHandler, который передаёт запрос дальше по цепочке. Перехват происходит в методе intercept().",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Resolvers - предзагрузка данных перед отображением компонента через resolve",
          "competency": "Роутинг (standalone, guards, resolvers)",
          "questions": [
            {
              "question": "Почему resolver выполняется до активации маршрута, а не после загрузки компонента?",
              "correct_answer": "Чтобы компонент получил готовые данные и не показывал пустое состояние",
              "var_1": "Чтобы Angular мог кэшировать компонент без данных",
              "var_2": "Resolver срабатывает для валидации параметров URL",
              "var_3": "Чтобы компонент получил готовые данные и не показывал пустое состояние",
              "var_4": "Для улучшения производительности за счёт параллельной загрузки данных и компонента",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Angular не кэширует компоненты без данных. Resolver не имеет отношения к кэшированию компонентов - его задача предоставить данные до активации маршрута. Кэширование данных может быть реализовано внутри сервисов, но не является целью resolver.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Валидация параметров URL - это задача guards (CanActivate, CanMatch), а не resolvers. Resolver предназначен именно для предзагрузки данных, а не для валидации параметров маршрута.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это основная цель resolver - предзагрузить данные до активации маршрута и рендеринга компонента, чтобы компонент сразу получил готовые данные и мог отобразить их без промежуточного пустого состояния или загрузчиков.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Resolver НЕ загружает данные параллельно с компонентом - он работает последовательно: сначала выполняется resolver, и только после его завершения активируется маршрут и загружается компонент. Это блокирующая операция.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой тип данных должен возвращать ResolveFn, чтобы роутер дождался загрузки данных перед активацией маршрута?",
              "correct_answer": "ResolveFn должен возвращать Observable, Promise или синхронное значение — роутер автоматически подпишется и дождётся результата.",
              "var_1": "ResolveFn должен возвращать только Observable — Promise и синхронные значения не поддерживаются, так как роутер работает исключительно с реактивными потоками.",
              "var_2": "ResolveFn должен возвращать BehaviorSubject с начальным значением null, а роутер активирует маршрут только после получения следующего значения.",
              "var_3": "ResolveFn должен возвращать Subject с методом complete(), чтобы роутер понял, когда данные загружены — без этого навигация не завершится корректно.",
              "var_4": "ResolveFn должен возвращать Observable, Promise или синхронное значение — роутер автоматически подпишется и дождётся результата.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Утверждение неверно — ResolveFn поддерживает не только Observable, но также Promise и синхронные значения. Angular роутер гибко обрабатывает различные типы возвращаемых данных, а не ограничивается только реактивными потоками.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "BehaviorSubject не является обязательным типом для ResolveFn. Роутер не требует начального значения null и не ждёт следующего значения — он просто берёт первое эмитированное значение из Observable или результат Promise.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Subject не является обязательным типом возвращаемого значения для ResolveFn. Роутер не требует метода complete() — он работает с Observable, Promise и синхронными значениями напрямую, без необходимости использования Subject.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "ResolveFn в Angular действительно может возвращать Observable, Promise или синхронное значение. Роутер автоматически обрабатывает все эти типы, подписывается на асинхронные источники и ожидает их завершения перед активацией маршрута.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Операторы трансформации данных - применение map и filter для обработки потоков из API",
          "competency": "RxJS (операторы, пайплайны, управление подписками)",
          "questions": [
            {
              "question": "Почему оператор filter в RxJS возвращает Observable, а не отфильтрованное значение напрямую?",
              "correct_answer": "Чтобы сохранить реактивный поток и возможность дальнейшей цепочки операторов",
              "var_1": "Потому что Angular требует Observable для работы с async pipe в шаблонах и автоматической отписки компонентов",
              "var_2": "Чтобы браузер мог кэшировать результат фильтрации и не выполнять повторные запросы к серверу",
              "var_3": "Чтобы сохранить реактивный поток и возможность дальнейшей цепочки операторов",
              "var_4": "Это нужно для совместимости с TypeScript, который не поддерживает синхронную фильтрацию массивов в потоках",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Хотя Angular действительно использует Observable с async pipe, это не причина, почему filter возвращает Observable. RxJS существует независимо от Angular, и архитектура операторов не диктуется требованиями фреймворка.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Кэширование результатов фильтрации не имеет отношения к тому, почему filter возвращает Observable. Это вопрос архитектуры RxJS, а не оптимизации браузера или HTTP-запросов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Filter возвращает Observable для сохранения реактивной природы потока и возможности композиции операторов. Это фундаментальный принцип RxJS - операторы должны возвращать Observable, чтобы можно было строить цепочки преобразований.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "TypeScript поддерживает синхронную фильтрацию массивов (метод Array.filter). Возврат Observable не связан с ограничениями TypeScript, это архитектурное решение RxJS для работы с асинхронными потоками данных.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой оператор RxJS следует использовать, чтобы из потока объектов пользователей извлечь поток их email-адресов?",
              "correct_answer": "Оператор map, который трансформирует каждый объект пользователя, возвращая только значение свойства email.",
              "var_1": "Оператор filter, который отбирает из потока только те объекты пользователей, у которых есть непустое свойство email.",
              "var_2": "Оператор tap, который позволяет получить доступ к свойству email каждого пользователя.",
              "var_3": "Оператор map, который трансформирует каждый объект пользователя, возвращая только значение свойства email.",
              "var_4": "Оператор pluck, который объединяет значения свойства email всех пользователей в один массив строк.",
              "correct_position": 3,
              "fixes_applied": 1,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Оператор filter используется для фильтрации элементов потока по условию, но не трансформирует объекты и не извлекает конкретные свойства. Он вернёт поток объектов пользователей, а не поток email-адресов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Оператор tap используется для побочных эффектов (например, логирования) и не трансформирует поток. Он возвращает исходный поток объектов пользователей без изменений.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Оператор map трансформирует каждый элемент потока, применяя к нему функцию. В данном случае map(user => user.email) извлечёт email из каждого объекта пользователя, создав поток email-адресов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Оператор pluck (хотя deprecated в RxJS 7+) специально предназначен для извлечения значений указанного свойства из объектов потока. pluck('email') извлечёт все email-адреса из потока пользователей.",
                "was_replaced": true,
                "original_before_fix": "Оператор pluck, который автоматически извлекает значения указанного свойства из каждого объекта потока."
              }
            }
          ]
        },
        {
          "theme": "HTTP статус-коды - обработка ошибок 4xx и 5xx в subscribe блоке Observable",
          "competency": "Понимание принципов работы сетевых протоколов, знание HTTP",
          "questions": [
            {
              "question": "Почему ошибки 4xx и 5xx в Angular HttpClient попадают в error-колбэк subscribe, а не в next?",
              "correct_answer": "Потому что HTTP-коды 4xx и 5xx указывают на неуспешный ответ, и HttpClient автоматически преобразует их в Observable error",
              "var_1": "Ошибки попадают в error только если не настроен interceptor, иначе они обрабатываются как обычные ответы",
              "var_2": "Потому что браузер перехватывает эти ответы и блокирует их передачу в JavaScript из соображений безопасности",
              "var_3": "Потому что RxJS требует явно указывать статус-коды для next через специальный оператор throwError в pipe",
              "var_4": "Потому что HTTP-коды 4xx и 5xx указывают на неуспешный ответ, и HttpClient автоматически преобразует их в Observable error",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Interceptor может перехватить и обработать ошибку, но это не меняет базового поведения HttpClient - 4xx/5xx всегда изначально считаются ошибками. Interceptor может только модифицировать это поведение, но не определяет его по умолчанию.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Браузер не блокирует HTTP ответы с кодами 4xx/5xx из соображений безопасности - они успешно доставляются в JavaScript. Это HttpClient на уровне приложения интерпретирует их как ошибки, а не браузер.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "throwError используется для создания Observable с ошибкой, но не для конфигурации того, какие статус-коды идут в next/error. HttpClient сам определяет это поведение на основе HTTP спецификации, а не через RxJS операторы.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "HttpClient в Angular действительно автоматически интерпретирует HTTP статус-коды 4xx и 5xx как ошибки и направляет их в error-колбэк Observable, так как эти коды по спецификации HTTP указывают на неуспешный запрос.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой оператор RxJS следует использовать в pipe для обработки HTTP ошибок 401 Unauthorized?",
              "correct_answer": "Оператор catchError в pipe, проверяя error.status === 401 для редиректа на логин.",
              "var_1": "Оператор catchError в pipe, проверяя error.status === 401 для редиректа на логин.",
              "var_2": "Оператор retry в pipe для автоматического повторного запроса при 401.",
              "var_3": "Оператор finalize в pipe, который срабатывает при любых HTTP ошибках.",
              "var_4": "Оператор tap в pipe для перехвата ошибки и вызова метода авторизации.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "catchError - правильный оператор для обработки ошибок в RxJS pipe. Он перехватывает ошибки в Observable stream, позволяя проверить error.status === 401 и выполнить редирект на страницу логина или вернуть fallback значение.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "retry автоматически повторяет запрос при ошибке, но это неправильный подход для 401. Повторный запрос без валидного токена приведёт к той же ошибке. Нужен catchError для редиректа на логин.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "finalize выполняется при завершении Observable (как успешном, так и с ошибкой), но не обрабатывает ошибки и не предоставляет доступ к объекту ошибки. Для обработки ошибок используется catchError.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "tap используется для side-effects и не перехватывает ошибки. Ошибка всё равно пробрасывается дальше по stream. Для обработки ошибок нужен catchError.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Computed signals - использование computed() для производных вычислений на основе signal()",
          "competency": "Signals API (signal/computed/effect)",
          "questions": [
            {
              "question": "Почему computed signal автоматически пересчитывается только при изменении зависимых сигналов?",
              "correct_answer": "Angular отслеживает зависимости при первом вычислении и подписывается на их изменения",
              "var_1": "Angular отслеживает зависимости при первом вычислении и подписывается на их изменения",
              "var_2": "Angular вызывает пересчёт computed в каждом цикле Change Detection автоматически",
              "var_3": "Computed signal запускает таймер и проверяет значения каждые 100мс",
              "var_4": "Computed кэширует результат и обновляется только при явном вызове метода update()",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильное объяснение механизма работы computed signals. Angular действительно отслеживает все сигналы, которые читаются во время первого вычисления computed функции, и автоматически подписывается на их изменения. Это называется реактивным отслеживанием зависимостей.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Это неверно. Computed signals работают на основе реактивности, а не Change Detection. Они пересчитываются только при изменении зависимых сигналов, а не в каждом цикле CD. Это одно из ключевых преимуществ Signals API - избежание лишних вычислений.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Это абсолютно неверно. Computed signals не используют таймеры или polling. Они работают на основе реактивной системы с push-уведомлениями от зависимых сигналов. Проверка каждые 100мс была бы крайне неэффективной.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Частично верно про кэширование, но неверно про update(). Computed signals действительно кэшируют результат, но обновляются автоматически при изменении зависимостей, а не через явный вызов метода update() (такого метода у computed вообще нет).",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как создать computed signal для отображения полного имени пользователя из двух сигналов firstName и lastName?",
              "correct_answer": "Использовать computed(() => firstName() + ' ' + lastName()), который автоматически пересчитывается при изменении любого из исходных сигналов.",
              "var_1": "Использовать signal(() => firstName() + ' ' + lastName()), который создаёт реактивный сигнал и автоматически отслеживает зависимости от других сигналов.",
              "var_2": "Применить computed(firstName() + ' ' + lastName()) без стрелочной функции, передав значения напрямую для вычисления производного состояния компонента.",
              "var_3": "Создать обычную переменную fullName = firstName() + ' ' + lastName() и обновлять её в effect(), который отслеживает изменения и вызывает пересчёт при каждом обновлении сигналов.",
              "var_4": "Использовать computed(() => firstName() + ' ' + lastName()), который автоматически пересчитывается при изменении любого из исходных сигналов.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "signal() не принимает функцию для создания производных вычислений. signal() используется для создания обычных сигналов с начальным значением, а не для вычисляемых.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "computed() требует функцию в качестве аргумента, а не готовое значение. Передача значений напрямую без обёртки в функцию приведёт к ошибке.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Это неэффективный подход. Обычная переменная не реактивна, и использование effect() для этой цели неправильно - effect() предназначен для побочных эффектов, а не для вычислений.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный способ создания computed signal. computed() принимает функцию, автоматически отслеживает зависимости от других сигналов и пересчитывается при их изменении.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Встроенные директивы шаблонов - применение @if и @for для условного рендеринга и отображения списков данных",
          "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for, OnPush)",
          "questions": [
            {
              "question": "Почему @for требует обязательного указания track-выражения при итерации по массиву?",
              "correct_answer": "Для эффективного отслеживания изменений элементов и минимизации перерисовок DOM при обновлении списка",
              "var_1": "Для сохранения ссылок на DOM-элементы в памяти браузера и предотвращения утечек памяти при частом обновлении данных",
              "var_2": "Для эффективного отслеживания изменений элементов и минимизации перерисовок DOM при обновлении списка",
              "var_3": "Для автоматической сортировки элементов массива в правильном порядке и синхронизации с исходными данными компонента",
              "var_4": "Для создания уникальных CSS-селекторов каждого элемента списка и применения стилей через Angular-компилятор",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Track-выражение не связано с управлением памятью или предотвращением утечек. Оно используется для идентификации элементов при сравнении состояний DOM.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Верно. Track-выражение позволяет Angular идентифицировать каждый элемент массива по уникальному значению, что позволяет фреймворку понять, какие элементы были добавлены, удалены или перемещены, и обновить только необходимые части DOM вместо полной перерисовки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Track-выражение не выполняет сортировку элементов. Оно только помогает идентифицировать элементы для оптимизации обновлений DOM.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Track-выражение не имеет отношения к CSS-селекторам или применению стилей. Это механизм для отслеживания идентичности элементов списка.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую директиву Angular использовать для отображения списка товаров из массива products в шаблоне компонента?",
              "correct_answer": "Директиву @for с обязательным указанием track для отслеживания элементов: @for (product of products; track product.id) { <div>{{product.name}}</div> }",
              "var_1": "Директиву @repeat для итерации по массиву: @repeat (products as product) { <div>{{product.name}}</div> } без дополнительных параметров",
              "var_2": "Директиву @foreach с обязательным указанием index для оптимизации: @foreach (product of products; let i = index) { <div>{{product.name}}</div> } - это стандартный синтаксис",
              "var_3": "Директиву *ngFor с указанием trackBy функции: *ngFor=\"let product of products; trackBy: trackByFn\" где trackByFn определяется в классе компонента отдельным методом",
              "var_4": "Директиву @for с обязательным указанием track для отслеживания элементов: @for (product of products; track product.id) { <div>{{product.name}}</div> }",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Директивы @repeat не существует в Angular. Это несуществующий синтаксис.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Директивы @foreach не существует в Angular. Правильное название - @for, а не @foreach.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "*ngFor - это старый синтаксис Angular (до версии 17), который до сих пор работает, но вопрос про новые встроенные директивы (@if/@for). В контексте современного Angular это не рекомендуемый подход.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Директива @for - это новый синтаксис Angular 17+ для итерации по массивам. Параметр track обязателен для оптимизации отслеживания изменений элементов.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Standalone-компоненты - создание и регистрация сервисов через providers в standalone-компонентах",
          "competency": "Архитектура Angular (DI, standalone)",
          "questions": [
            {
              "question": "Почему сервис, зарегистрированный в providers standalone-компонента, недоступен в родительском компоненте?",
              "correct_answer": "Потому что создаётся дочерний инжектор с ограниченной областью видимости только для этого компонента и его потомков",
              "var_1": "Потому что сервисы в standalone-компонентах регистрируются как приватные и требуют явного экспорта",
              "var_2": "Потому что родительский компонент загружается раньше дочернего и на момент его создания сервис ещё не был зарегистрирован в системе DI",
              "var_3": "Потому что standalone-компоненты работают в изолированном модуле и Angular автоматически блокирует доступ к их провайдерам из внешних компонентов",
              "var_4": "Потому что создаётся дочерний инжектор с ограниченной областью видимости только для этого компонента и его потомков",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Неверно. В Angular нет концепции 'приватных' сервисов, требующих явного экспорта. Сервисы доступны в пределах области видимости инжектора, но не требуют экспорта.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Неверно. Хотя родительский компонент действительно загружается раньше, это не причина недоступности. Даже после создания дочернего компонента его провайдеры недоступны родителю из-за иерархии инжекторов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Неверно. Standalone-компоненты не работают в 'изолированном модуле', и Angular не блокирует доступ специально. Причина в стандартной иерархии инжекторов DI.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильное объяснение. В Angular провайдеры, указанные в компоненте, создают дочерний инжектор для этого компонента и его потомков. Родительский компонент находится выше в иерархии DI и не имеет доступа к провайдерам дочернего инжектора.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой массив нужно добавить в декоратор @Component, чтобы зарегистрировать DataService только для standalone-компонента и его потомков?",
              "correct_answer": "Массив providers: [DataService] в декораторе @Component, что создаст отдельный экземпляр сервиса для данного компонента.",
              "var_1": "Массив imports: [DataService] в декораторе @Component, что позволит импортировать сервис как зависимость для standalone-компонента.",
              "var_2": "Массив viewProviders: [DataService] в декораторе @Component, что создаст экземпляр сервиса доступный только в шаблоне компонента.",
              "var_3": "Массив declarations: [DataService] в декораторе @Component, который объявит сервис доступным для компонента и его дочерних элементов.",
              "var_4": "Массив providers: [DataService] в декораторе @Component, что создаст отдельный экземпляр сервиса для данного компонента.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Массив imports используется для импорта других модулей или standalone-компонентов, но не для регистрации сервисов. Сервисы регистрируются через providers.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "viewProviders создает экземпляр сервиса только для view (представления) компонента, но НЕ для его content children (ng-content). Это не подходит для регистрации сервиса для компонента и всех его потомков.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Массив declarations используется только в NgModule для объявления компонентов, директив и пайпов. В standalone-компонентах этот массив не используется, и сервисы через него не регистрируются.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Массив providers в декораторе @Component — это правильный способ регистрации сервиса для standalone-компонента. Создается отдельный экземпляр сервиса, доступный компоненту и всем его потомкам через DI.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Процесс сборки Angular - различия между development и production режимами",
          "competency": "Angular CLI/сборка/конфиги",
          "questions": [
            {
              "question": "Почему production сборка Angular работает быстрее, чем development?",
              "correct_answer": "Включены минификация, tree-shaking, AOT-компиляция и отключены отладочные проверки",
              "var_1": "Включены минификация, tree-shaking, AOT-компиляция и отключены отладочные проверки",
              "var_2": "В production браузер кэширует файлы лучше чем в режиме разработки",
              "var_3": "Production использует более быстрый сервер для раздачи файлов",
              "var_4": "Production сборка использует другую версию JavaScript движка браузера",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Production сборка включает минификацию кода, tree-shaking (удаление неиспользуемого кода), AOT-компиляцию (компиляция шаблонов заранее, а не в браузере) и отключение отладочных проверок Angular, что существенно ускоряет работу приложения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Кэширование браузером зависит от настроек сервера и HTTP-заголовков, а не от режима сборки Angular. Это может влиять на загрузку, но не является причиной, почему production сборка работает быстрее.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Скорость работы приложения не зависит от сервера раздачи файлов. Production сборка быстрее из-за оптимизаций самого кода (минификация, AOT и т.д.), а не из-за используемого сервера.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Браузер использует один и тот же JavaScript движок независимо от режима сборки Angular. Движок определяется браузером (V8 в Chrome, SpiderMonkey в Firefox и т.д.), а не режимом сборки приложения.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую команду Angular CLI нужно использовать, чтобы создать оптимизированный бандл для деплоя на продакшен сервер?",
              "correct_answer": "ng build --configuration=production или ng build (production по умолчанию), включает минификацию, tree-shaking и AOT-компиляцию.",
              "var_1": "ng build --development создаёт готовый бандл для продакшена, так как development режим уже включает все оптимизации по умолчанию в новых версиях Angular.",
              "var_2": "ng build --configuration=production или ng build (production по умолчанию), включает минификацию, tree-shaking и AOT-компиляцию.",
              "var_3": "ng serve --prod запускает production сборку и автоматически деплоит приложение на сервер, включая все необходимые оптимизации и минификацию кода.",
              "var_4": "ng compile --output-hashing=all создаёт оптимизированную сборку с хешированием файлов, что является основной командой для подготовки продакшен бандла.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Development режим НЕ включает оптимизации для продакшена. Флаг --development создаёт неоптимизированную сборку с source maps, без минификации и с JIT-компиляцией для ускорения разработки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Команда ng build --configuration=production (или сокращённо ng build --prod, а в новых версиях просто ng build) действительно создаёт оптимизированный production бандл с минификацией, tree-shaking, AOT-компиляцией и другими оптимизациями.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Команда ng serve предназначена для локальной разработки и запускает dev-сервер, но НЕ деплоит приложение на сервер. Даже с флагом --prod она только запускает локальный сервер с production настройками.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Команды ng compile не существует в Angular CLI. Правильная команда - ng build. Output hashing настраивается через конфигурацию, но это не основная команда для production сборки.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Оптимизация шаблонов - реализация trackBy функций для ngFor директив",
          "competency": "Производительность (CD, trackBy, bundle анализ)",
          "questions": [
            {
              "question": "Почему без trackBy Angular перерисовывает весь список при изменении одного элемента?",
              "correct_answer": "Angular сравнивает объекты по ссылке, не по содержимому",
              "var_1": "Angular сравнивает объекты по ссылке, не по содержимому",
              "var_2": "Браузер автоматически очищает DOM при любых изменениях в массиве данных",
              "var_3": "ngFor всегда полностью обновляет шаблон по умолчанию",
              "var_4": "Angular не может определить тип данных в массиве без явного указания типа элементов",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Без trackBy Angular использует идентичность объектов (сравнение по ссылке) для определения, какие элементы изменились. При получении нового массива (даже с теми же данными) все ссылки новые, поэтому Angular пересоздает все DOM-элементы",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Браузер не очищает DOM автоматически при изменениях в JavaScript массивах. Angular сам управляет обновлением DOM, и без trackBy он пересоздает элементы из-за изменения ссылок на объекты",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "ngFor не полностью обновляет шаблон по умолчанию. Angular пытается оптимизировать, но без trackBy использует идентичность объектов (ссылки) для отслеживания изменений, что приводит к пересозданию DOM-элементов при изменении массива",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "TypeScript типизация не влияет на runtime поведение ngFor. Angular определяет изменения через сравнение ссылок на объекты, а не через анализ типов данных",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую trackBy функцию нужно написать для ngFor, чтобы Angular отслеживал элементы списка пользователей по их уникальному id?",
              "correct_answer": "trackByUserId(index: number, user: User): number { return user.id; } — функция возвращает уникальный идентификатор элемента для оптимизации перерисовки.",
              "var_1": "trackByUserId(index: number, user: User): number { return index; } — функция возвращает индекс элемента в массиве, что позволяет Angular эффективно отслеживать изменения позиций.",
              "var_2": "trackByUserId(user: User, index: number): number { return user.id; } — функция принимает пользователя первым параметром и возвращает его идентификатор для оптимизации.",
              "var_3": "trackByUserId(index: number, user: User): number { return user.id; } — функция возвращает уникальный идентификатор элемента для оптимизации перерисовки.",
              "var_4": "trackByUserId(index: number, user: User): string { return user.name + user.id; } — функция возвращает комбинацию полей для более точного отслеживания элементов списка.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Возврат индекса не оптимизирует перерисовку, так как при изменении порядка элементов индексы меняются, и Angular будет перерисовывать DOM-узлы вместо их переиспользования.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Неправильный порядок параметров. TrackBy функция в Angular должна принимать index первым параметром, а item вторым. Такая сигнатура вызовет ошибку типизации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Функция корректно возвращает уникальный id элемента, что позволяет Angular отслеживать элементы по их идентичности, а не позиции, и переиспользовать DOM-узлы при изменениях массива.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Конкатенация name + id создаёт избыточную зависимость от изменяемого поля name. При изменении имени пользователя Angular будет считать это другим элементом и перерисует DOM.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Рефакторинг кода - вынесение магических чисел и строк в константы",
          "competency": "Навыки проведения рефакторинга и code review",
          "questions": [
            {
              "question": "Почему вынесение магических чисел в константы улучшает поддержку кода?",
              "correct_answer": "Изменение значения происходит в одном месте, а имя константы объясняет его назначение",
              "var_1": "Константы автоматически оптимизируются компилятором Angular, что значительно ускоряет производительность приложения",
              "var_2": "Изменение значения происходит в одном месте, а имя константы объясняет его назначение",
              "var_3": "Вынесение в константы позволяет TypeScript лучше проводить статический анализ типов во время сборки",
              "var_4": "Константы занимают меньше памяти в браузере чем обычные переменные в коде",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Компилятор Angular не производит специальной оптимизации констант. После компиляции разница между константами и литералами минимальна с точки зрения производительности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Константы с понятными именами делают код самодокументируемым, а изменение значения в одном месте упрощает поддержку и избегает ошибок при изменениях.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Вынесение магических чисел в константы не влияет на качество статического анализа типов TypeScript. Статический анализ работает одинаково с литералами и константами.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Константы и литералы занимают одинаковое количество памяти после компиляции. Преимущество констант не в экономии памяти, а в читаемости и поддержке кода.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как бы вы отрефакторили условие if (status === 3) в Angular компоненте, если 3 означает 'завершённый заказ'?",
              "correct_answer": "Создать константу ORDER_STATUS.COMPLETED = 3 в отдельном файле констант и использовать её вместо числа 3 в условии.",
              "var_1": "Создать переменную let completedStatus = 3 прямо в том же компоненте перед условием if и использовать её вместо магического числа 3.",
              "var_2": "Использовать строковое сравнение if (status === '3') вместо числового, так как строки более читаемы и понятны в Angular шаблонах.",
              "var_3": "Создать константу ORDER_STATUS.COMPLETED = 3 в отдельном файле констант и использовать её вместо числа 3 в условии.",
              "var_4": "Оставить число 3 в коде и добавить комментарий // status 3 = завершённый заказ, чтобы другие разработчики понимали значение этого числа.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Использование let вместо const делает переменную изменяемой, что небезопасно. Кроме того, размещение константы внутри компонента не решает проблему переиспользования в других местах приложения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Замена числа на строку не решает проблему магического значения, а только меняет тип. Это может привести к ошибкам типизации и не улучшает читаемость кода.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный подход: вынесение магического числа в именованную константу в отдельном файле обеспечивает переиспользование, улучшает читаемость и упрощает поддержку кода.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Комментарии не решают проблему магических чисел. При изменении значения статуса придётся искать все места в коде. Комментарии могут устаревать и вводить в заблуждение.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        }
      ]
    },
    "middle": {
      "themes": [
        {
          "theme": "Адаптивная верстка - применение breakpoints и стратегий mobile-first для корректного отображения UI на различных устройствах",
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "questions": [
            {
              "question": "Почему стратегия mobile-first в Tailwind использует min-width вместо max-width для breakpoints?",
              "correct_answer": "Стили применяются базово к мобильным устройствам и расширяются для больших экранов, а не переопределяются для меньших",
              "var_1": "min-width используется потому что Tailwind компилирует стили в порядке возрастания, а max-width нарушил бы каскадность CSS правил",
              "var_2": "Это связано с тем, что min-width обеспечивает лучшую производительность при рендеринге страницы, так как браузер быстрее обрабатывает условия увеличения",
              "var_3": "min-width позволяет браузеру кэшировать медиа-запросы эффективнее, чем max-width для тех же экранов",
              "var_4": "Стили применяются базово к мобильным устройствам и расширяются для больших экранов, а не переопределяются для меньших",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Каскадность CSS работает одинаково для min-width и max-width. Порядок компиляции не является причиной выбора min-width в mobile-first подходе.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Производительность рендеринга не зависит от типа медиа-запроса (min-width vs max-width). Браузеры обрабатывают оба типа с одинаковой скоростью.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Кэширование медиа-запросов браузером не зависит от использования min-width или max-width. Это техническое заблуждение без фактического основания.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильное объяснение mobile-first подхода: базовые стили без медиа-запросов применяются к мобильным устройствам, а min-width расширяет функциональность для больших экранов прогрессивно.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой класс Tailwind следует использовать для скрытия элемента на мобильных устройствах и отображения только начиная с планшетов?",
              "correct_answer": "hidden md:block — скрывает элемент по умолчанию и отображает как блок начиная с breakpoint md (768px), следуя mobile-first подходу",
              "var_1": "hidden md:block — скрывает элемент по умолчанию и отображает как блок начиная с breakpoint md (768px), следуя mobile-first подходу",
              "var_2": "block md:hidden — отображает элемент как блок на мобильных устройствах по умолчанию, а затем полностью скрывает начиная с планшетов (breakpoint md 768px)",
              "var_3": "visible md:hidden — показывает элемент на мобильных устройствах и скрывает его начиная с breakpoint md (768px), что является стандартным подходом для адаптивной верстки",
              "var_4": "invisible md:visible — управляет видимостью элемента, скрывая на мобильных и показывая на планшетах через свойство visibility",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Правильный ответ: hidden скрывает элемент на мобильных (display: none), md:block отображает его как блок начиная с 768px, что соответствует mobile-first подходу.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Вариант делает противоположное требуемому: показывает на мобильных (block) и скрывает на планшетах (md:hidden). Это desktop-first подход с обратной логикой.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Вариант делает противоположное: показывает на мобильных (visible по умолчанию) и скрывает на планшетах (md:hidden). Это обратная логика.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "invisible/visible управляют visibility (элемент занимает место), но не display. Кроме того, invisible md:visible не работает корректно в Tailwind - нужно использовать invisible md:visible, но это не отображает элемент визуально правильно.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Event Loop и микрозадачи - понимание порядка выполнения промисов и setTimeout для отладки асинхронных проблем в Angular",
          "competency": "Знание языка программирования JavaScript",
          "questions": [
            {
              "question": "Почему callback из Promise.then выполнится раньше callback из setTimeout с нулевой задержкой?",
              "correct_answer": "Микрозадачи промисов имеют приоритет над макрозадачами и обрабатываются перед ними в Event Loop",
              "var_1": "Браузер оптимизирует промисы для лучшей производительности, помещая их callback в начало общей очереди задач",
              "var_2": "Микрозадачи промисов имеют приоритет над макрозадачами и обрабатываются перед ними в Event Loop",
              "var_3": "setTimeout всегда добавляет минимальную задержку в 4мс согласно спецификации HTML5, поэтому Promise успевает выполниться раньше",
              "var_4": "Promise.then использует синхронный стек вызовов и выполняется сразу после текущей функции, минуя очередь задач полностью",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Это не оптимизация браузера. Промисы используют отдельную очередь микрозадач, а не общую очередь задач. Это фундаментальная особенность Event Loop.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Верно. В Event Loop есть две очереди: микрозадачи (промисы, queueMicrotask) и макрозадачи (setTimeout, setInterval). Микрозадачи всегда обрабатываются полностью перед следующей макрозадачей.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Хотя setTimeout действительно имеет минимальную задержку (4мс при вложенности >5), это не причина. Promise.then выполнится раньше даже с setTimeout(0, 0) из-за очередей микро/макрозадач.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Promise.then не выполняется синхронно и не минует очередь задач. Callback из then помещается в очередь микрозадач и выполняется асинхронно.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой порядок вывода console.log будет при выполнении кода: console.log('1'); setTimeout(() => console.log('2'), 0); Promise.resolve().then(() => console.log('3'));?",
              "correct_answer": "Порядок вывода: 1, 3, 2. Синхронный код выполняется первым, затем микрозадачи промисов, потом макрозадачи setTimeout.",
              "var_1": "Порядок вывода: 2, 1, 3. setTimeout всегда имеет приоритет над синхронным кодом из-за Web API очереди.",
              "var_2": "Порядок вывода: 1, 3, 2. Синхронный код выполняется первым, затем микрозадачи промисов, потом макрозадачи setTimeout.",
              "var_3": "Порядок вывода: 3, 1, 2. Промисы выполняются первыми как высокоприоритетные задачи в Event Loop.",
              "var_4": "Порядок вывода: 1, 2, 3. Код выполняется строго последовательно сверху вниз, setTimeout с задержкой 0 выполняется немедленно перед промисом.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Неверный порядок. Синхронный код (console.log('1')) выполняется первым, а setTimeout не имеет приоритета над синхронным кодом.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Правильный порядок. Сначала выполняется синхронный код (1), затем очередь микрозадач с промисами (3), и в конце макрозадачи setTimeout (2).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Неверный порядок. Синхронный код всегда выполняется первым, до любых асинхронных задач (промисов или таймеров).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Неверно. setTimeout с задержкой 0 не выполняется немедленно - он попадает в очередь макрозадач и выполнится после микрозадач (промисов).",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Декораторы TypeScript - понимание работы Angular декораторов и создание custom декораторов для компонентов",
          "competency": "Знание языка программирования TypeScript",
          "questions": [
            {
              "question": "Почему Angular декораторы должны быть вызваны как функции со скобками, а не просто указаны как идентификаторы?",
              "correct_answer": "Декораторы являются фабричными функциями, которые принимают конфигурацию и возвращают функцию-модификатор класса",
              "var_1": "Это синтаксическое требование TypeScript компилятора для корректной обработки метаданных класса",
              "var_2": "Скобки нужны для синхронного выполнения декоратора до загрузки модуля в браузере",
              "var_3": "Декораторы являются фабричными функциями, которые принимают конфигурацию и возвращают функцию-модификатор класса",
              "var_4": "Скобки создают замыкание для сохранения ссылки на класс и его методы в памяти при компиляции",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Это не синтаксическое требование компилятора для метаданных. Скобки нужны потому, что Angular декораторы - это фабрики функций. TypeScript поддерживает декораторы и без скобок, если они не являются фабриками.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Скобки не связаны с синхронным выполнением или загрузкой модуля в браузере. Декораторы выполняются на этапе определения класса, а скобки нужны для вызова фабричной функции, которая возвращает реальный декоратор.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Angular декораторы (@Component, @Injectable и др.) - это фабричные функции (decorator factories). Они принимают конфигурационный объект как параметр и возвращают функцию-декоратор, которая модифицирует класс. Поэтому необходимы скобки для вызова фабрики.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Скобки не создают замыкание для сохранения ссылки на класс. Декораторы вызываются как функции, потому что это фабрики, возвращающие реальную функцию-декоратор. Замыкание здесь не является основной причиной использования скобок.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой паттерн использовать при создании кастомного декоратора для автоматической отписки от Observable в ngOnDestroy компонента?",
              "correct_answer": "Декоратор класса, добавляющий Subject как destroy$, переопределяющий ngOnDestroy для emit/complete, подписки используют takeUntil(destroy$).",
              "var_1": "Декоратор свойства для каждой Observable-переменной, который автоматически вызывает unsubscribe() при уничтожении компонента через WeakMap и FinalizationRegistry.",
              "var_2": "Декоратор параметра конструктора, внедряющий ChangeDetectorRef сервис и регистрирующий callback для отписки через detectChanges hook.",
              "var_3": "Декоратор класса, добавляющий Subject как destroy$, переопределяющий ngOnDestroy для emit/complete, подписки используют takeUntil(destroy$).",
              "var_4": "Декоратор метода для ngOnInit, который оборачивает все Observable свойства класса в pipe с take(1), автоматически завершая подписку после первого значения.",
              "correct_position": 3,
              "fixes_applied": 1,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "WeakMap и FinalizationRegistry - не подходят для управления подписками Angular. FinalizationRegistry срабатывает при garbage collection непредсказуемо, что может привести к утечкам памяти. Не контролируется lifecycle hooks.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: DestroyRef (Angular 16+) - современный подход для управления lifecycle. Декоратор параметра может инжектить DestroyRef и регистрировать cleanup через onDestroy() без Subject, что элегантно и эффективно.",
                "was_replaced": true,
                "original_before_fix": "Декоратор параметра конструктора, внедряющий DestroyRef сервис и регистрирующий callback для отписки через onDestroy hook без использования Subject."
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Классический и наиболее популярный паттерн. Декоратор класса добавляет Subject для уничтожения, переопределяет ngOnDestroy для emit/complete, все подписки используют takeUntil(destroy$) - проверенное решение.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "take(1) завершает подписку после первого значения - это не решение для автоматической отписки при ngOnDestroy. Многие Observable требуют long-lived подписок (events, route params), которые должны жить весь lifecycle компонента.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Принципы SOLID - применение Dependency Injection и Single Responsibility в архитектуре Angular сервисов",
          "competency": "Базовая теория программирования, ООП",
          "questions": [
            {
              "question": "Почему нарушение Single Responsibility в Angular сервисе усложняет его тестирование?",
              "correct_answer": "Приходится создавать множество моков для несвязанных зависимостей, тесты становятся хрупкими и сложными в поддержке",
              "var_1": "Приходится создавать множество моков для несвязанных зависимостей, тесты становятся хрупкими и сложными в поддержке",
              "var_2": "Тестирование усложняется из-за того, что Angular TestBed не поддерживает инъекцию сервисов с более чем пятью зависимостями одновременно",
              "var_3": "Сервис с нарушением SRP требует перезапуска всего тестового модуля при каждом тесте, что значительно замедляет выполнение тестов",
              "var_4": "Angular не может отследить изменения в сервисе с множеством обязанностей, что приводит к непредсказуемому поведению в zone.js во время тестов",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это корректный ответ: сервис с множеством обязанностей имеет много несвязанных зависимостей, что требует создания множества моков для каждого теста, делая тесты сложными, хрупкими и трудными в поддержке.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Angular TestBed не имеет ограничений на количество зависимостей в сервисе. Это полностью выдуманное техническое ограничение, которого не существует.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Нарушение SRP не требует обязательного перезапуска TestBed при каждом тесте. Перезапуск зависит от конфигурации тестов, а не от количества ответственностей сервиса.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Zone.js отслеживает асинхронные операции, а не количество обязанностей сервиса. Нарушение SRP не влияет на механизм change detection и работу zone.js напрямую.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой рефакторинг следует применить к Angular-сервису, который одновременно выполняет HTTP-запросы, кэширует данные и форматирует их для отображения?",
              "correct_answer": "Разделить на три отдельных сервиса (ApiService, CacheService, DataFormatterService), внедряя зависимости через DI для соблюдения Single Responsibility Principle.",
              "var_1": "Создать абстрактный базовый класс с методами для HTTP, кэширования и форматирования, от которого наследовать конкретные сервисы для каждого типа данных в приложении.",
              "var_2": "Использовать декоратор @Injectable с providedIn: 'any' для автоматического разделения ответственности между разными модулями Angular через механизм ленивой загрузки.",
              "var_3": "Объединить все функции в один универсальный сервис с использованием паттерна Facade, что упростит архитектуру и уменьшит количество инъекций зависимостей в компонентах приложения.",
              "var_4": "Разделить на три отдельных сервиса (ApiService, CacheService, DataFormatterService), внедряя зависимости через DI для соблюдения Single Responsibility Principle.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Наследование от базового класса с множественной ответственностью не решает проблему нарушения SRP. Это переносит все три ответственности в базовый класс, что противоречит принципу Single Responsibility.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "providedIn: 'any' создает отдельный экземпляр сервиса для каждого ленивого модуля, но не разделяет ответственности. Это опция провайдинга, не имеющая отношения к SRP.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Facade скрывает сложность, но не решает проблему нарушения SRP. Сервис по-прежнему будет иметь множественные ответственности, что усложняет тестирование и поддержку.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Правильное применение SRP и DI: каждый сервис имеет одну четкую ответственность (HTTP-запросы, кэширование, форматирование), что делает код тестируемым, поддерживаемым и расширяемым.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Stash - управление незакоммиченными изменениями при переключении между задачами",
          "competency": "Знание Git",
          "questions": [
            {
              "question": "Почему git stash сохраняет изменения в стеке, а не в одном слоте?",
              "correct_answer": "Стек позволяет накапливать несколько наборов изменений и возвращаться к ним в нужном порядке при работе над разными задачами",
              "var_1": "Стек нужен для автоматической очистки старых изменений по принципу LIFO когда память заканчивается",
              "var_2": "Стек позволяет накапливать несколько наборов изменений и возвращаться к ним в нужном порядке при работе над разными задачами",
              "var_3": "Стек выбран для совместимости с командой git pop которая требует стековую структуру данных для работы",
              "var_4": "Стек используется потому что Git внутри работает как стековая машина и все операции выполняются через стек",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Git stash не очищает автоматически старые изменения при нехватке памяти. Все stash'и сохраняются до тех пор, пока пользователь явно не удалит их командами drop, clear или pop. Принцип LIFO используется только для удобства работы, а не для управления памятью.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Стек позволяет сохранять множество независимых наборов изменений (stash@{0}, stash@{1}, и т.д.) и применять их в нужном порядке. Это особенно полезно при частом переключении между задачами, когда нужно временно отложить текущую работу.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Логика перевернута: не стек выбран для совместимости с командой pop, а наоборот - команда называется pop именно потому, что stash использует стековую структуру. Команда pop не требует стековую структуру для работы, это просто соглашение об именовании.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Git не является стековой машиной. Это распределенная система контроля версий, которая использует DAG (направленный ациклический граф) для хранения истории коммитов. Stash использует стек как удобную структуру данных для хранения изменений, но это не связано с внутренней архитектурой Git.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой командой вы сохраните текущие незакоммиченные изменения в stash, включая неотслеживаемые файлы, перед срочным переключением на другую ветку?",
              "correct_answer": "git stash push -u или git stash --include-untracked, это сохранит и tracked, и untracked файлы в stash.",
              "var_1": "git stash -a сохраняет только untracked файлы, для tracked используется git stash push.",
              "var_2": "git stash save --all сохраняет все файлы включая игнорируемые, а для untracked нужно использовать отдельную команду git add.",
              "var_3": "git stash push сохраняет все изменения автоматически, включая untracked файлы, дополнительные флаги не требуются.",
              "var_4": "git stash push -u или git stash --include-untracked, это сохранит и tracked, и untracked файлы в stash.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Флаг -a (--all) сохраняет ВСЕ файлы включая игнорируемые, а не только untracked. Также git stash push сохраняет tracked файлы без дополнительных команд",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "git stash save устаревшая команда. Флаг --all сохраняет включая ignored файлы, но утверждение про отдельную команду git add неверно - untracked файлы не требуют git add для stash",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "git stash push по умолчанию НЕ сохраняет неотслеживаемые (untracked) файлы. Для их включения требуется флаг -u или --include-untracked",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Команда git stash push -u (или полная форма --include-untracked) корректно сохраняет как отслеживаемые, так и неотслеживаемые файлы в stash",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "FormArray - динамическое управление вложенными структурами форм с добавлением и удалением элементов",
          "competency": "Формы (Template/Reactive, валидаторы)",
          "questions": [
            {
              "question": "Почему при удалении элемента из FormArray необходимо использовать метод removeAt вместо splice?",
              "correct_answer": "Метод removeAt автоматически обновляет состояние валидации формы и уведомляет подписчиков об изменениях через Observable",
              "var_1": "Метод splice работает только с обычными массивами, а FormArray требует специальных методов для иммутабельности",
              "var_2": "Метод removeAt автоматически обновляет состояние валидации формы и уведомляет подписчиков об изменениях через Observable",
              "var_3": "Метод removeAt сохраняет индексы оставшихся элементов без смещения, что важно для корректного отслеживания",
              "var_4": "Метод splice не поддерживается в Angular для работы с FormArray из-за ограничений TypeScript",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Неверно. FormArray не требует иммутабельности - это мутабельная структура. Метод splice технически работает, но не уведомляет систему форм об изменениях и не обновляет валидацию.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Верно. removeAt корректно обновляет внутреннее состояние FormArray, пересчитывает валидацию всей формы, эмитит события valueChanges и statusChanges, что критично для реактивных форм.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Неверно. И removeAt, и splice смещают индексы оставшихся элементов после удаления. Разница не в сохранении индексов, а в управлении реактивным состоянием формы.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Неверно. Метод splice поддерживается, так как FormArray наследует от Array. Проблема не в TypeScript или поддержке метода, а в том, что splice не триггерит обновления Angular форм.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как правильно удалить элемент из FormArray по индексу при клике на кнопку удаления в шаблоне?",
              "correct_answer": "Вызвать метод removeAt(index) на экземпляре FormArray, передав индекс элемента: this.formArray.removeAt(i), где i получен через let i = index в ngFor.",
              "var_1": "Вызвать delete this.formArray.controls[index], затем обновить форму через updateValueAndValidity() для синхронизации.",
              "var_2": "Вызвать метод removeAt(index) на экземпляре FormArray, передав индекс элемента: this.formArray.removeAt(i), где i получен через let i = index в ngFor.",
              "var_3": "Применить filter для создания нового массива без удалённого элемента и переназначить его в FormArray.controls.",
              "var_4": "Использовать метод splice(index, 1) напрямую на FormArray для удаления элемента, как в обычном массиве JavaScript.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Оператор delete создаст undefined элемент в массиве controls вместо удаления, нарушив структуру FormArray. updateValueAndValidity() не исправит это, т.к. не удаляет элементы.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "removeAt(index) — правильный метод Angular API для удаления элемента из FormArray. Он корректно обновляет внутреннее состояние, триггерит события и пересчитывает валидацию.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Прямое переназначение FormArray.controls нарушает инкапсуляцию и внутреннее состояние FormArray. Это приведет к потере связей с валидаторами, подписками и родительской формой.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Метод splice() изменит массив controls, но не обновит внутреннее состояние FormArray (valueChanges, statusChanges, валидацию). FormArray требует использования специальных методов API.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Санитизация контента - создание кастомных директив и pipes для безопасного рендеринга HTML с настраиваемыми правилами",
          "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
          "questions": [
            {
              "question": "Почему при создании кастомного pipe для рендеринга HTML необходимо использовать DomSanitizer вместо прямой вставки контента?",
              "correct_answer": "Angular по умолчанию блокирует потенциально опасный HTML, DomSanitizer позволяет контролируемо пометить контент как доверенный после проверки",
              "var_1": "DomSanitizer необходим для преобразования HTML в виртуальный DOM Angular, без него контент не сможет корректно отобразиться в компонентах и шаблонах приложения",
              "var_2": "DomSanitizer автоматически шифрует весь HTML-контент перед отправкой в браузер, что защищает данные от перехвата при передаче по сети и повышает общую безопасность",
              "var_3": "Angular по умолчанию блокирует потенциально опасный HTML, DomSanitizer позволяет контролируемо пометить контент как доверенный после проверки",
              "var_4": "Прямая вставка HTML работает только в development режиме, а DomSanitizer обеспечивает совместимость с production сборкой Angular и оптимизирует производительность",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Angular не использует виртуальный DOM (это концепция React). DomSanitizer не преобразует HTML в какую-то специальную структуру - он только проверяет и помечает контент как безопасный или очищает его.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "DomSanitizer не шифрует контент и не связан с сетевой безопасностью. Его задача - защита от XSS атак путем санитизации или явного обхода встроенной защиты Angular для доверенного контента.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Angular действительно автоматически блокирует небезопасный контент (XSS защита). DomSanitizer позволяет явно пометить проверенный контент как безопасный через методы sanitize() или bypassSecurityTrust*().",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Режим сборки (dev/prod) не влияет на работу HTML вставки. DomSanitizer не связан с оптимизацией производительности или совместимостью между режимами - это инструмент безопасности.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой метод DomSanitizer следует использовать в кастомном pipe для безопасного рендеринга пользовательского HTML-контента с сохранением разрешённых тегов?",
              "correct_answer": "Метод bypassSecurityTrustHtml(), но перед его вызовом необходимо предварительно очистить HTML через DOMPurify или собственный whitelist-фильтр тегов и атрибутов.",
              "var_1": "Метод sanitize() с контекстом SecurityContext.HTML автоматически обеспечивает полную защиту от XSS-атак и сохраняет все безопасные теги без необходимости дополнительной фильтрации через внешние библиотеки.",
              "var_2": "Метод bypassSecurityTrustHtml(), но перед его вызовом необходимо предварительно очистить HTML через DOMPurify или собственный whitelist-фильтр тегов и атрибутов.",
              "var_3": "Метод bypassSecurityTrustResourceUrl() универсален для любого HTML-контента и автоматически фильтрует опасные теги через встроенный whitelist.",
              "var_4": "Метод bypassSecurityTrustHtml() полностью безопасен сам по себе, так как Angular внутренне применяет санитизацию ко всему переданному контенту, и дополнительная очистка избыточна и снижает производительность.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "sanitize() с SecurityContext.HTML действительно защищает от XSS, но он удаляет многие теги и атрибуты по строгому whitelist Angular. Для сохранения разрешённых тегов с настраиваемыми правилами нужна дополнительная библиотека (DOMPurify) или собственная фильтрация перед bypass.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный подход: bypassSecurityTrustHtml() отключает встроенную санитизацию Angular, поэтому для безопасного рендеринга пользовательского HTML с настраиваемыми правилами необходима предварительная очистка через DOMPurify или собственный whitelist-фильтр перед bypass.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "bypassSecurityTrustResourceUrl() предназначен для URL ресурсов (iframe src, object data), а не для HTML-контента. Он не фильтрует HTML-теги и не имеет встроенного whitelist для контента. Для HTML используется bypassSecurityTrustHtml().",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "bypassSecurityTrustHtml() ОТКЛЮЧАЕТ встроенную санитизацию Angular и помечает контент как безопасный без какой-либо очистки. Это опасно для пользовательского контента - необходима предварительная санитизация через DOMPurify или whitelist-фильтр.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Синхронизация состояния signal-сервисов с API - обработка загрузки данных, кэширование ответов и управление состояниями loading/error/success",
          "competency": "Состояние приложения (signals services)",
          "questions": [
            {
              "question": "Какое преимущество дают отдельные сигналы для loading/error/success по сравнению с одним объектом состояния?",
              "correct_answer": "Компоненты подписываются только на нужные изменения, избегая лишних перерисовок",
              "var_1": "Отдельные сигналы требуют меньше памяти чем один объект с несколькими полями",
              "var_2": "Отдельные сигналы позволяют Angular автоматически оптимизировать change detection без zone.js и OnPush стратегии",
              "var_3": "Разделение сигналов упрощает тестирование, так как каждый сигнал можно мокировать независимо от других",
              "var_4": "Компоненты подписываются только на нужные изменения, избегая лишних перерисовок",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Неверно. Отдельные сигналы фактически занимают больше памяти, чем один объект, так как каждый signal - это отдельная структура данных с внутренними механизмами отслеживания зависимостей. Преимущество signals не в экономии памяти, а в granular reactivity.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Неверно. Signals позволяют оптимизировать change detection, но это работает независимо от zone.js и OnPush - эти механизмы относятся к старому подходу. Signals сами по себе обеспечивают fine-grained reactivity, но не 'автоматически' без правильного использования в компонентах.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Неверно. Тестирование не становится проще - как отдельные сигналы, так и поля объекта можно мокировать независимо. В случае объекта можно замокировать весь объект или его отдельные поля. Это не является преимуществом отдельных сигналов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Верно. Signals в Angular обеспечивают fine-grained reactivity - компоненты реагируют только на изменения конкретных сигналов, которые они используют. При одном объекте состояния изменение любого поля триггерит перерисовку всех компонентов, использующих этот объект.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую структуру signal-состояния вы бы реализовали в сервисе для корректного отображения spinner, данных и ошибок при загрузке с API?",
              "correct_answer": "Создать computed signal объединяющий состояния: { data: signal<T|null>, loading: signal<boolean>, error: signal<string|null> }, либо единый signal с union-типом состояний Loading|Success|Error.",
              "var_1": "Хранить loading и error в отдельных BehaviorSubject, а данные в signal, синхронизируя их через tap оператор RxJS при каждом запросе к API.",
              "var_2": "Использовать один signal<any> для всех состояний и проверять тип данных через typeof/instanceof при отображении в шаблоне компонента.",
              "var_3": "Создать computed signal объединяющий состояния: { data: signal<T|null>, loading: signal<boolean>, error: signal<string|null> }, либо единый signal с union-типом состояний Loading|Success|Error.",
              "var_4": "Создать effect который автоматически устанавливает loading=true при любом изменении data signal и сбрасывает его через setTimeout после рендеринга.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Смешивание BehaviorSubject (RxJS) для части состояния и signals для другой части создает несогласованность. Либо использовать signals полностью, либо RxJS полностью. Гибридный подход усложняет поддержку и синхронизацию.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Хранение разных типов состояний в одном signal<any> с проверкой через typeof/instanceof - это антипаттерн. Теряется типизация TypeScript, усложняется отладка и нарушается принцип разделения ответственности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный подход для Angular signals: либо несколько отдельных signals (data, loading, error) объединенных через computed, либо один signal с union-типом состояний (Loading|Success<T>|Error). Оба варианта обеспечивают типобезопасность и удобное управление состоянием.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Effect не должен использоваться для управления состоянием загрузки. setTimeout после рендеринга - антипаттерн. Loading должен устанавливаться перед запросом и сбрасываться после получения ответа, а не реагировать на изменения data.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Централизованная обработка ошибок - маппинг HTTP-статусов на пользовательские сообщения через ErrorHandler",
          "competency": "HTTP/интерцепторы/типизация API",
          "questions": [
            {
              "question": "Почему для централизованной обработки HTTP-ошибок предпочтительнее использовать интерцептор, а не переопределение глобального ErrorHandler?",
              "correct_answer": "Интерцептор перехватывает ошибки на уровне HTTP до их распространения, позволяя трансформировать ответ и сохранить контекст запроса",
              "var_1": "ErrorHandler автоматически перезагружает страницу при HTTP-ошибках, что нарушает SPA-поведение, тогда как интерцептор позволяет обрабатывать ошибки без перезагрузки",
              "var_2": "Глобальный ErrorHandler не поддерживает асинхронную обработку ошибок и не может работать с Observable, что делает его непригодным для HTTP-запросов",
              "var_3": "Интерцептор перехватывает ошибки на уровне HTTP до их распространения, позволяя трансформировать ответ и сохранить контекст запроса",
              "var_4": "Интерцептор работает быстрее ErrorHandler, так как обрабатывает ошибки в отдельном потоке без блокировки основного приложения",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "ErrorHandler не перезагружает страницу автоматически при HTTP-ошибках. Это неверное утверждение. ErrorHandler просто логирует ошибки в консоль по умолчанию и не влияет на поведение SPA. Перезагрузка страницы не является стандартным поведением.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "ErrorHandler поддерживает асинхронную обработку и может работать с Observable. Можно инжектить HttpClient в кастомный ErrorHandler и выполнять асинхронные операции. Проблема в том, что ErrorHandler ловит все ошибки приложения, а не только HTTP, теряя специфичный контекст.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Интерцептор действительно перехватывает HTTP-ошибки на уровне HttpClient до их распространения в компоненты, позволяя трансформировать ответ, сохранять контекст запроса (URL, headers, params) и обрабатывать ошибки специфично для HTTP-слоя.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Интерцепторы не работают в отдельном потоке и не имеют преимуществ в скорости. Оба механизма выполняются синхронно в основном потоке JavaScript. Преимущество интерцептора в специфичности к HTTP-контексту, а не в производительности.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как в Angular ErrorHandler реализовать маппинг HTTP-статуса 403 на понятное пользователю сообщение о запрете доступа?",
              "correct_answer": "Проверить в handleError, является ли ошибка HttpErrorResponse со статусом 403, и вызвать NotificationService с сообщением 'Доступ запрещён' или показать модальное окно авторизации.",
              "var_1": "Проверить в handleError, является ли ошибка HttpErrorResponse со статусом 403, и вызвать NotificationService с сообщением 'Доступ запрещён' или показать модальное окно авторизации.",
              "var_2": "Использовать HTTP_INTERCEPTORS для перехвата статуса 403 и автоматически перенаправить пользователя на страницу логина через Router.navigate.",
              "var_3": "Переопределить метод handleError и выбросить новое исключение с текстом 'Доступ запрещён', которое браузер автоматически покажет пользователю.",
              "var_4": "Добавить декоратор @CatchError(403) к методам сервиса и Angular автоматически преобразует ошибки в пользовательские сообщения через DI.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный подход: в ErrorHandler.handleError проверяем тип ошибки (HttpErrorResponse), её статус (403) и через инжектированный NotificationService или модальное окно показываем понятное сообщение пользователю.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Вопрос касается ErrorHandler, а не HTTP_INTERCEPTORS. Хотя интерцептор может обрабатывать 403, это другой механизм. К тому же автоматический редирект не является маппингом на 'понятное сообщение'.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Выброс нового исключения в handleError не приведёт к автоматическому показу сообщения пользователю браузером. Нужно явно использовать сервис уведомлений или UI-компонент для отображения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "В Angular не существует декоратора @CatchError. Это выдуманная функциональность. Обработка ошибок в ErrorHandler требует явной реализации метода handleError.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Resolvers - параллельная загрузка данных через forkJoin с обработкой частичных ошибок и fallback-стратегиями",
          "competency": "Роутинг (standalone, guards, resolvers)",
          "questions": [
            {
              "question": "Почему для обработки частичных ошибок в resolver предпочтительнее catchError внутри каждого запроса forkJoin, а не один общий обработчик?",
              "correct_answer": "Общий catchError прервёт весь forkJoin при первой ошибке, а индивидуальные позволяют вернуть fallback-значения для неудавшихся запросов, сохранив успешные результаты",
              "var_1": "Общий catchError применяется только для синхронных операций, а для асинхронных запросов в forkJoin требуются индивидуальные обработчики",
              "var_2": "Индивидуальные catchError внутри forkJoin работают быстрее, так как Angular оптимизирует параллельную обработку ошибок, снижая нагрузку на change detection и улучшая производительность",
              "var_3": "Индивидуальные catchError позволяют Angular правильно типизировать результат, а общий обработчик нарушает вывод типов",
              "var_4": "Общий catchError прервёт весь forkJoin при первой ошибке, а индивидуальные позволяют вернуть fallback-значения для неудавшихся запросов, сохранив успешные результаты",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Полностью неверно. catchError работает одинаково для синхронных и асинхронных операций в RxJS. Это не имеет никакого отношения к различию между общим и индивидуальным подходом. Проблема в поведении forkJoin, а не в природе операций.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Неверно. Индивидуальные catchError не влияют на производительность или оптимизацию Angular. Change detection не связан с обработкой ошибок в RxJS операторах. Причина использования индивидуальных catchError — функциональное поведение forkJoin, который прерывается при первой ошибке.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Это неверно. Типизация не является причиной выбора между индивидуальными и общим catchError. TypeScript корректно выводит типы в обоих случаях. Реальная причина — поведение forkJoin при ошибках (прерывание всего потока).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это абсолютно верно. forkJoin завершается с ошибкой при первом failed Observable, если не обработать ошибки индивидуально. Индивидуальные catchError позволяют вернуть fallback-значения (например, null или пустой массив) для неудавшихся запросов, при этом сохраняя успешные результаты от других запросов.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой RxJS оператор использовать внутри forkJoin для обработки ошибок отдельного запроса без прерывания всей параллельной загрузки данных в resolver?",
              "correct_answer": "Оператор catchError внутри каждого Observable в forkJoin, возвращающий fallback-значение (например, of(null) или of(defaultData)) для обработки частичных ошибок.",
              "var_1": "Оператор catchError внутри каждого Observable в forkJoin, возвращающий fallback-значение (например, of(null) или of(defaultData)) для обработки частичных ошибок.",
              "var_2": "Оператор throwError с последующим switchMap для преобразования ошибки в альтернативный поток данных в resolver.",
              "var_3": "Оператор retry с указанием количества попыток внутри каждого Observable в forkJoin, который автоматически повторяет запросы при ошибках и только потом прерывает загрузку данных.",
              "var_4": "Оператор finalize внутри каждого Observable в forkJoin, который выполняет cleanup-логику и позволяет перехватить ошибку перед её распространением на остальные потоки.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "catchError внутри каждого Observable перехватывает ошибку и возвращает fallback-значение (of(null), of(defaultData)), превращая ошибочный поток в успешный. Это позволяет forkJoin завершиться успешно даже при ошибках в отдельных запросах.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "throwError генерирует ошибку, а не обрабатывает её. switchMap в данном контексте не помогает обработать ошибки внутри forkJoin - ошибка всё равно прервёт выполнение. Это неправильный подход для обработки частичных ошибок.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "retry повторяет запрос при ошибке, но не предотвращает прерывание forkJoin. Если после всех попыток ошибка остаётся, forkJoin всё равно прервётся. Это не решает проблему частичных ошибок, а лишь откладывает её.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "finalize выполняется после завершения потока (успешного или с ошибкой), но не перехватывает и не обрабатывает ошибку. Он нужен для cleanup-логики, но не предотвращает прерывание forkJoin при ошибке в одном из потоков.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Управление подписками - применение Subject, takeUntil и Subscription для предотвращения утечек памяти в компонентах",
          "competency": "RxJS (операторы, пайплайны, управление подписками)",
          "questions": [
            {
              "question": "Почему паттерн с takeUntil и Subject предпочтительнее ручного отписывания через массив Subscription?",
              "correct_answer": "Один Subject централизованно завершает все подписки в ngOnDestroy, уменьшая дублирование кода и риск пропустить отписку",
              "var_1": "Один Subject централизованно завершает все подписки в ngOnDestroy, уменьшая дублирование кода и риск пропустить отписку",
              "var_2": "takeUntil создаёт новый поток для каждой подписки, что позволяет Angular оптимизировать change detection более эффективно",
              "var_3": "Массив Subscription не поддерживает асинхронные операции, в отличие от Subject который работает с async пайпом",
              "var_4": "Subject автоматически очищает память при завершении компонента без необходимости вызова ngOnDestroy, что делает код более производительным",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение. Паттерн takeUntil с Subject позволяет централизованно управлять всеми подписками через один вызов destroy$.next() в ngOnDestroy, что делает код чище и снижает вероятность забыть отписаться от какого-то Observable.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "takeUntil не создаёт новый поток для каждой подписки, а использует один Subject для завершения всех Observable. Angular change detection не зависит от способа управления подписками.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Массив Subscription полностью поддерживает асинхронные операции через метод unsubscribe(). Async pipe — это отдельный механизм для автоматической отписки в шаблонах, не связанный напрямую с Subject.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Subject НЕ очищает память автоматически. Необходимо вызывать destroy$.next() и destroy$.complete() в ngOnDestroy вручную. Оба подхода требуют явного вызова логики очистки в хуке жизненного цикла.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой паттерн с takeUntil и Subject наиболее эффективен для автоматической отписки от всех подписок при уничтожении компонента?",
              "correct_answer": "Создать private destroy$ = new Subject<void>(), добавить .pipe(takeUntil(this.destroy$)) к каждой подписке и вызвать destroy$.next(); destroy$.complete() в ngOnDestroy.",
              "var_1": "Создать private destroy$ = new BehaviorSubject<boolean>(false), добавить .pipe(takeWhile(() => !this.destroy$.value)) к каждой подписке и вызвать destroy$.next(true) в ngOnDestroy для отписки от всех потоков.",
              "var_2": "Создать массив subscriptions: Subscription[] = [], добавлять каждую подписку через push и в ngOnDestroy вызвать subscriptions.unsubscribe() напрямую без forEach для очистки всех подписок.",
              "var_3": "Создать private destroy$ = new Subject<void>(), добавить .pipe(takeUntil(this.destroy$)) к каждой подписке и вызвать destroy$.next(); destroy$.complete() в ngOnDestroy.",
              "var_4": "Создать private destroy$ = new ReplaySubject<void>(1), добавить .pipe(takeUntil(this.destroy$)) к каждой подписке и вызвать только destroy$.complete() в ngOnDestroy без вызова next() для завершения.",
              "correct_position": 3,
              "fixes_applied": 1,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "takeWhile проверяет значение при каждой эмиссии источника, но не отписывается немедленно при изменении условия. Подписки останутся активными до следующей эмиссии, что может вызвать утечки и ошибки при обращении к уничтоженному компоненту.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Валидный подход: явное управление подписками через массив и ручная отписка в ngOnDestroy. Работает корректно, хотя требует больше кода чем паттерн с takeUntil.",
                "was_replaced": true,
                "original_before_fix": "Создать массив subscriptions: Subscription[] = [], добавлять каждую подписку через push и в ngOnDestroy вызвать subscriptions.forEach(sub => sub.unsubscribe()) для очистки всех подписок."
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Классический и наиболее эффективный паттерн: Subject<void>() с takeUntil корректно завершает все подписки при вызове next(), а complete() освобождает ресурсы самого Subject. Минимальный overhead по памяти.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "ReplaySubject(1) будет хранить значение в памяти даже после complete(). Также takeUntil требует вызова next() для срабатывания - без next() подписки не завершатся, только complete() не триггерит takeUntil.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "HTTP методы и идемпотентность - корректное применение GET, POST, PUT, DELETE и PATCH при разработке сервисов с учетом retry-логики",
          "competency": "Понимание принципов работы сетевых протоколов, знание HTTP",
          "questions": [
            {
              "question": "Почему безопасно автоматически повторять неудачные GET-запросы, но не POST-запросы?",
              "correct_answer": "GET безопасен и не изменяет состояние, POST может создать дубликаты",
              "var_1": "POST содержит тело запроса большого размера, что создает нагрузку на сервер при повторах",
              "var_2": "GET безопасен и не изменяет состояние, POST может создать дубликаты",
              "var_3": "GET быстрее обрабатывается сервером, POST занимает больше времени",
              "var_4": "GET кэшируется браузером автоматически, а POST требует подтверждения пользователя для повторной отправки",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Размер тела запроса и нагрузка на сервер не являются причиной небезопасности повторов POST. Проблема в неидемпотентности - повторные POST создают побочные эффекты (дубликаты ресурсов).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "GET является безопасным (safe) и идемпотентным методом по спецификации HTTP - он не должен изменять состояние сервера. POST не идемпотентен, каждый повтор может создать новый ресурс (дубликат).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Скорость обработки не является причиной безопасности повторов. Оба метода могут обрабатываться с разной скоростью в зависимости от бизнес-логики, а безопасность повторов зависит от идемпотентности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Кэширование не является причиной безопасности повторов. Безопасность повторов связана с идемпотентностью метода, а не с механизмами кэширования браузера.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой HTTP метод безопасно использовать в retry-логике для создания заказа, чтобы избежать дублирования при сетевых сбоях?",
              "correct_answer": "POST с идемпотентным ключом (idempotency key), который гарантирует, что повторные запросы не создадут дубликаты заказов.",
              "var_1": "PUT с указанием идентификатора ресурса, так как этот метод идемпотентен по спецификации и автоматически предотвращает любые дубликаты при повторных запросах.",
              "var_2": "POST без дополнительных механизмов, так как современные серверы автоматически отслеживают повторные запросы и игнорируют дублирующиеся операции.",
              "var_3": "GET с параметрами создания заказа в query string, поскольку GET является безопасным методом и его можно повторять без побочных эффектов на сервере.",
              "var_4": "POST с идемпотентным ключом (idempotency key), который гарантирует, что повторные запросы не создадут дубликаты заказов.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "PUT идемпотентен, но для создания заказа его использование некорректно - при создании мы не знаем ID заказа заранее. PUT предназначен для полной замены существующего ресурса.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Популярное заблуждение. POST не идемпотентен, серверы не отслеживают автоматически повторные запросы - это требует явной реализации (например, через idempotency key).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "GET не должен использоваться для операций с побочными эффектами (создание ресурсов). GET - безопасный метод только для чтения данных, не для изменения состояния сервера.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "POST с idempotency key - правильное решение. Ключ идемпотентности позволяет серверу идентифицировать повторные запросы и не создавать дубликаты заказов при retry.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Effect API - управление побочными эффектами и синхронизация с внешними источниками данных",
          "competency": "Signals API (signal/computed/effect)",
          "questions": [
            {
              "question": "Почему effect автоматически отслеживает только те сигналы, которые были прочитаны во время его выполнения?",
              "correct_answer": "Angular использует ленивое отслеживание зависимостей, регистрируя только реально прочитанные сигналы для оптимизации производительности и избежания лишних перерасчётов",
              "var_1": "Angular использует ленивое отслеживание зависимостей, регистрируя только реально прочитанные сигналы для оптимизации производительности и избежания лишних перерасчётов",
              "var_2": "Angular кэширует список зависимостей при первом запуске effect и больше не обновляет его для стабильности поведения приложения",
              "var_3": "Effect отслеживает все сигналы, объявленные в компоненте, независимо от их использования, потому что компилятор статически анализирует код и заранее определяет все возможные зависимости",
              "var_4": "Angular требует явной регистрации всех сигналов в специальном массиве зависимостей при создании effect, аналогично useEffect в React, что обеспечивает предсказуемость и контроль над реактивностью",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это верный ответ. Angular использует динамическое отслеживание зависимостей: когда effect выполняется, он регистрирует только те сигналы, которые реально были прочитаны, что оптимизирует производительность",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Effect не кэширует список зависимостей после первого запуска. Он динамически пересчитывает зависимости при каждом выполнении, отслеживая актуально прочитанные сигналы",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Effect не отслеживает все сигналы в компоненте. Он использует динамическое отслеживание только тех сигналов, к которым происходит обращение во время выполнения, а не статический анализ компилятора",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "В Angular Signals API effect не требует явного массива зависимостей. Он автоматически отслеживает сигналы через механизм реактивного контекста, в отличие от React useEffect",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как правильно отписаться от WebSocket-соединения при уничтожении компонента, если подписка создана внутри effect?",
              "correct_answer": "Использовать onCleanup callback: effect((onCleanup) => { const ws = connect(); onCleanup(() => ws.close()); })",
              "var_1": "Обернуть WebSocket в takeUntilDestroyed() внутри effect для автоматической отписки",
              "var_2": "Вызвать destroyRef.onDestroy() внутри effect для автоматического закрытия WebSocket при уничтожении",
              "var_3": "Использовать onCleanup callback: effect((onCleanup) => { const ws = connect(); onCleanup(() => ws.close()); })",
              "var_4": "Использовать ngOnDestroy для вызова unsubscribe() и хранить ссылку на effect в переменной класса для последующей очистки",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "takeUntilDestroyed() - это RxJS оператор для Observable, а не для WebSocket API. WebSocket не является Observable из коробки и не может использовать RxJS операторы напрямую",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "destroyRef.onDestroy() не вызывается внутри effect - это метод для регистрации колбэков уничтожения компонента, а не механизм очистки самого effect",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "onCleanup - правильный механизм для очистки ресурсов в effect. Колбэк вызывается при повторном запуске effect или его уничтожении, что идеально для закрытия WebSocket",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Effect не имеет метода unsubscribe(). Effect автоматически управляется Angular и не требует ручной отписки через ngOnDestroy. Это путаница с RxJS подписками",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "OnPush стратегия - реализация компонентов с immutable данными и ручным управлением change detection для списков с 1000+ элементами",
          "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for, OnPush)",
          "questions": [
            {
              "question": "Почему при OnPush стратегии изменение элемента массива через push() не вызывает перерисовку компонента?",
              "correct_answer": "OnPush сравнивает ссылки на объекты, а push() мутирует массив без изменения его ссылки",
              "var_1": "Метод push() работает асинхронно и не попадает в цикл change detection",
              "var_2": "Push() не поддерживается Angular для отслеживания изменений",
              "var_3": "OnPush сравнивает ссылки на объекты, а push() мутирует массив без изменения его ссылки",
              "var_4": "OnPush блокирует все операции с массивами в шаблоне, пока не будет вызван detectChanges() вручную",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Push() - синхронный метод JavaScript, который выполняется немедленно в текущем потоке выполнения. Он не работает асинхронно и попадает в тот же цикл выполнения. Проблема не в асинхронности, а в том, что OnPush не видит изменения ссылки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Push() - стандартный метод JavaScript массивов, полностью поддерживается Angular. Angular не блокирует или ограничивает использование методов массивов. Проблема не в поддержке метода, а в механизме обнаружения изменений.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. OnPush стратегия использует поверхностное сравнение (shallow comparison) входных данных по ссылкам. Метод push() мутирует существующий массив, добавляя элемент, но ссылка на массив остается той же самой, поэтому Angular не обнаруживает изменение.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "OnPush не блокирует операции с массивами в шаблоне. Стратегия OnPush влияет только на условия запуска change detection, но не блокирует операции. Массивы работают нормально, проблема в отслеживании изменений по ссылке.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как правильно обновить один элемент в списке из 1000+ объектов в OnPush компоненте, чтобы Angular обнаружил изменение?",
              "correct_answer": "Создать новый массив с новым объектом через spread-оператор или map, сохраняя immutability: items = items.map(item => item.id === id ? {...item, ...changes} : item).",
              "var_1": "Изменить свойство объекта напрямую items[index].property = value и вызвать changeDetectorRef.detectChanges() после изменения - OnPush сам отследит мутацию после явного запуска проверки изменений.",
              "var_2": "Использовать trackBy функцию в @for цикле, которая автоматически определит изменённый элемент и обновит только его, без необходимости создавать новый массив или запускать change detection вручную.",
              "var_3": "Обернуть изменение в NgZone.run() для принудительного запуска change detection, после чего мутировать объект напрямую в массиве.",
              "var_4": "Создать новый массив с новым объектом через spread-оператор или map, сохраняя immutability: items = items.map(item => item.id === id ? {...item, ...changes} : item).",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "detectChanges() запустит проверку изменений, но OnPush не обнаружит мутацию внутри объекта, так как сравнивает ссылки. Даже после явного вызова detectChanges() изменение не будет детектировано, потому что ссылка на Input не изменилась.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "trackBy оптимизирует рендеринг DOM, но не решает проблему обнаружения изменений в OnPush. OnPush проверяет изменения только при смене ссылки на массив или событиях, trackBy не триггерит change detection автоматически.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "NgZone.run() запустит change detection, но OnPush стратегия не обнаружит изменения при мутации объекта внутри массива, так как ссылка на массив остаётся той же. OnPush требует смены ссылки на объект/массив.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный подход для OnPush. Создание нового массива через map с spread-оператором изменяет ссылку на массив, что триггерит change detection в OnPush компоненте. Immutability гарантирует, что Angular обнаружит изменение.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Standalone компоненты - миграция NgModule-структуры с сохранением иерархии провайдеров",
          "competency": "Архитектура Angular (DI, standalone)",
          "questions": [
            {
              "question": "Почему при миграции на standalone важно правильно размещать провайдеры в иерархии Routes?",
              "correct_answer": "Неправильное размещение нарушит область видимости и переопределение зависимостей",
              "var_1": "Routes автоматически наследуют все провайдеры от корневого AppComponent",
              "var_2": "Неправильное размещение нарушит область видимости и переопределение зависимостей",
              "var_3": "Провайдеры в Routes влияют только на производительность загрузки",
              "var_4": "Размещение провайдеров в Routes определяет порядок инициализации модулей",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Routes не наследуют автоматически все провайдеры от AppComponent. В Angular существует иерархия инжекторов: каждый уровень роутинга может иметь свой собственный набор провайдеров. Дочерние роуты видят провайдеры родительских, но не наоборот. Это не автоматическое наследование всего от корня.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. При миграции на standalone критически важно правильно размещать провайдеры в иерархии Routes, так как это напрямую определяет область видимости сервисов (scope), их время жизни и возможность переопределения на разных уровнях роутинга. Неправильное размещение приведет к нарушению логики DI.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Провайдеры в Routes влияют не только на производительность, но прежде всего на область видимости DI (Dependency Injection), время жизни сервисов и возможность их переопределения в дочерних роутах. Это ключевой аспект архитектуры приложения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "В standalone архитектуре нет модулей в классическом понимании. Провайдеры в Routes не определяют порядок инициализации модулей, а создают инжекторы для конкретных роутов и их дочерних элементов. Важна именно иерархия инжекторов.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как при миграции на standalone компоненты сохранить иерархию провайдеров, которая была определена в feature NgModule?",
              "correct_answer": "Использовать Route providers в lazy-loaded маршрутах или создать environment injector через createEnvironmentInjector для сохранения области видимости сервисов.",
              "var_1": "Перенести все провайдеры из NgModule в массив providers корневого компонента приложения, Angular автоматически восстановит иерархию.",
              "var_2": "Использовать Route providers в lazy-loaded маршрутах или создать environment injector через createEnvironmentInjector для сохранения области видимости сервисов.",
              "var_3": "Добавить viewProviders в каждый standalone компонент для имитации модульной области видимости сервисов.",
              "var_4": "Использовать декоратор @Injectable с providedIn: 'any' для всех сервисов feature-модуля, что автоматически создаст отдельный инстанс для каждого lazy-loaded компонента.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Перенос всех провайдеров в корневой компонент не сохранит иерархию - все сервисы станут singleton на уровне приложения, а не feature-модуля. Angular не восстанавливает иерархию автоматически.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Route providers позволяют определить провайдеры на уровне маршрута при lazy loading, создавая область видимости аналогичную NgModule. createEnvironmentInjector также позволяет создать отдельную иерархию инжекторов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "viewProviders создают область видимости только для view (шаблона) компонента и его дочерних элементов, но не имитируют модульную область видимости. К тому же viewProviders не доступны для content children.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "providedIn: 'any' создаёт отдельный инстанс для каждого lazy-loaded модуля, но это устаревший подход для NgModule, а не решение для standalone компонентов. Не работает с lazy-loaded компонентами напрямую.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Lazy loading модулей - конфигурация loadChildren и preloading стратегий в роутинге",
          "competency": "Angular CLI/сборка/конфиги",
          "questions": [
            {
              "question": "Почему PreloadAllModules стратегия может негативно влиять на производительность мобильных устройств?",
              "correct_answer": "Загружает все модули в фоне, расходуя мобильный трафик и память даже для неиспользуемых маршрутов",
              "var_1": "Увеличивает время компиляции JIT на устройстве, замедляя запуск приложения",
              "var_2": "Блокирует основной поток JavaScript во время предзагрузки модулей, что приводит к зависанию интерфейса на слабых устройствах",
              "var_3": "Загружает модули синхронно вместо асинхронной загрузки, блокируя рендеринг страницы",
              "var_4": "Загружает все модули в фоне, расходуя мобильный трафик и память даже для неиспользуемых маршрутов",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "В production сборках Angular использует AOT компиляцию, модули уже скомпилированы. JIT компиляция на устройстве не происходит",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Предзагрузка модулей происходит асинхронно в фоне и не блокирует основной поток JavaScript, не вызывая зависаний UI",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "PreloadAllModules использует асинхронную загрузку модулей в фоне после инициализации приложения, не блокируя рендеринг",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "PreloadAllModules действительно загружает все lazy модули в фоновом режиме после начальной загрузки, что расходует трафик и память пользователя даже для модулей, которые он может никогда не посетить. Особенно критично на мобильных устройствах с ограниченным трафиком и памятью",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую preloading стратегию вы примените для предзагрузки только тех модулей, маршруты которых помечены флагом preload: true?",
              "correct_answer": "Нужно создать кастомную PreloadingStrategy, реализующую интерфейс PreloadingStrategy, проверяющую route.data['preload'] и вызывающую load() для помеченных маршрутов.",
              "var_1": "Использовать встроенную стратегию PreloadAllModules и добавить в route.data флаг preload: true, она автоматически учитывает эти флаги.",
              "var_2": "Применить PreloadAllModules и добавить canLoad guard, который блокирует загрузку модулей без флага preload: true, это стандартный подход Angular.",
              "var_3": "Нужно создать кастомную PreloadingStrategy, реализующую интерфейс PreloadingStrategy, проверяющую route.data['preload'] и вызывающую load() для помеченных маршрутов.",
              "var_4": "Достаточно указать preload: true в data маршрута и использовать SelectivePreloadingStrategy из @angular/router, она проверяет этот флаг.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "PreloadAllModules загружает ВСЕ lazy-loaded модули без учета каких-либо флагов в route.data. Она не проверяет preload: true автоматически.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "canLoad guard блокирует загрузку модуля полностью, даже при навигации, и не используется для preloading. PreloadAllModules загружает все модули независимо от guards.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это корректный подход: создать класс, реализующий PreloadingStrategy с методом preload(), который проверяет route.data['preload'] и решает, вызывать ли load().",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "SelectivePreloadingStrategy не существует как встроенная стратегия в @angular/router. В Angular есть только PreloadAllModules и NoPreloading из коробки.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "CDK Virtual Scroll - реализация виртуального скроллинга для больших списков и таблиц",
          "competency": "Производительность (CD, trackBy, bundle анализ)",
          "questions": [
            {
              "question": "Почему CDK Virtual Scroll значительно улучшает производительность при рендеринге больших списков?",
              "correct_answer": "Он рендерит только видимые элементы в viewport, а не весь список, минимизируя количество DOM-узлов",
              "var_1": "Он кэширует все DOM-элементы в памяти и мгновенно показывает их при скролле",
              "var_2": "Он использует Web Workers для параллельного рендеринга всех элементов списка, разгружая основной поток браузера",
              "var_3": "Он рендерит только видимые элементы в viewport, а не весь список, минимизируя количество DOM-узлов",
              "var_4": "Он применяет lazy loading для загрузки данных списка по частям",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "CDK Virtual Scroll не кэширует все DOM-элементы - это противоречило бы идее оптимизации. Он переиспользует ограниченный набор DOM-узлов для отображения разных элементов данных.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "CDK Virtual Scroll не использует Web Workers. Он работает в основном потоке, но оптимизирует рендеринг за счет ограничения количества DOM-элементов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это основной принцип работы виртуального скроллинга - рендеринг только видимых элементов плюс небольшой буфер, что радикально сокращает количество DOM-узлов и улучшает производительность.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "CDK Virtual Scroll не занимается загрузкой данных - это ответственность разработчика. Он работает только с рендерингом уже загруженных данных.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой подход следует применить при использовании CDK Virtual Scroll с элементами списка, имеющими разную высоту?",
              "correct_answer": "Реализовать собственную VirtualScrollStrategy или использовать экспериментальную AutoSizeVirtualScrollStrategy из @angular/cdk-experimental.",
              "var_1": "Установить CSS свойство height: auto для виртуального контейнера и добавить директиву cdkVirtualScrollDynamicSize.",
              "var_2": "Реализовать собственную VirtualScrollStrategy или использовать экспериментальную AutoSizeVirtualScrollStrategy из @angular/cdk-experimental.",
              "var_3": "Использовать стандартный FixedSizeVirtualScrollStrategy с указанием максимальной высоты элемента и настройкой буферных зон для предзагрузки контента.",
              "var_4": "Задать фиксированную высоту itemSize равную среднему значению высот всех элементов списка.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Директивы cdkVirtualScrollDynamicSize не существует в CDK. Height: auto на контейнере нарушит работу виртуального скроллинга, который требует явного указания размеров viewport для корректных расчетов видимой области.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это корректный подход. Стандартные стратегии CDK работают только с фиксированными размерами. Для элементов с разной высотой нужна кастомная VirtualScrollStrategy или можно использовать AutoSizeVirtualScrollStrategy из @angular/cdk-experimental, которая измеряет реальные размеры элементов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "FixedSizeVirtualScrollStrategy по определению работает только с элементами фиксированной высоты. Указание максимальной высоты не решит проблему динамических размеров - стратегия не будет корректно рассчитывать позиции элементов с разной высотой.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Использование среднего значения высоты не решает проблему динамических высот. FixedSizeVirtualScrollStrategy требует фиксированной высоты для корректных расчетов позиций элементов, средняя высота приведет к визуальным артефактам и неправильному позиционированию.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Рефакторинг компонентной архитектуры - разделение на smart/dumb компоненты с выносом бизнес-логики в сервисы",
          "competency": "Навыки проведения рефакторинга и code review",
          "questions": [
            {
              "question": "Почему вынос бизнес-логики из компонентов в сервисы упрощает unit-тестирование?",
              "correct_answer": "Сервисы тестируются изолированно без создания DOM и зависимостей компонента",
              "var_1": "Сервисы тестируются изолированно без создания DOM и зависимостей компонента",
              "var_2": "Сервисы используют встроенный TestBed Angular, который быстрее работает с бизнес-логикой",
              "var_3": "Сервисы автоматически генерируют mock-данные для тестов без необходимости ручной настройки",
              "var_4": "Компоненты после выноса логики в сервисы не требуют тестирования вообще, только сервисы",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это верно. Сервисы - это обычные TypeScript классы, которые можно тестировать изолированно, просто создав экземпляр класса и замокав зависимости. Не нужно создавать DOM, компилировать шаблоны и работать с жизненным циклом компонента.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "TestBed используется для тестирования как компонентов, так и сервисов, и не имеет специальных оптимизаций для бизнес-логики. Это общий инструмент Angular для тестирования.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Сервисы не генерируют mock-данные автоматически. Mock-данные и mock-зависимости нужно создавать вручную или использовать библиотеки для моков.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Компоненты всё равно требуют тестирования, даже после выноса бизнес-логики. Нужно тестировать взаимодействие с сервисами, отображение данных, обработку событий UI и биндинги.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой признак в существующем Angular-компоненте указывает на необходимость рефакторинга путём выделения dumb-компонента?",
              "correct_answer": "Повторяющаяся разметка отображения данных смешана с HTTP-запросами, подписками на store и бизнес-логикой в одном компоненте.",
              "var_1": "Наличие OnPush стратегии обнаружения изменений в компоненте является главным признаком того, что его необходимо разделить на отдельные dumb-компоненты.",
              "var_2": "Повторяющаяся разметка отображения данных смешана с HTTP-запросами, подписками на store и бизнес-логикой в одном компоненте.",
              "var_3": "Компонент использует сервисы через dependency injection, что автоматически означает необходимость выделения презентационного dumb-компонента.",
              "var_4": "Компонент содержит слишком много Input-декораторов и Output-событий, что указывает на необходимость объединения логики в один smart-компонент для упрощения.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "OnPush стратегия - это результат хорошей архитектуры, а не причина для рефакторинга. OnPush как раз применяется к dumb-компонентам после их выделения, а не является признаком необходимости разделения.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это классический признак god-компонента, требующего рефакторинга. Смешение презентационной логики (разметка) с бизнес-логикой (HTTP, store, обработка данных) - прямое указание на необходимость выделить dumb-компонент для отображения и smart для логики.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Использование DI и сервисов - нормальная практика в Angular. Не каждый компонент с сервисами нуждается в выделении dumb-компонента. Важно ЧТО делают эти сервисы и КАК смешана логика, а не сам факт их использования.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Множество Input/Output как раз характерно для dumb-компонентов. Предложение объединить логику в один smart-компонент противоречит принципу разделения - это движение в обратном направлении от правильной архитектуры.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        }
      ]
    },
    "senior": {
      "themes": [
        {
          "theme": "CSS Grid и Flexbox - построение сложных адаптивных layout систем с минимальным использованием медиа-запросов",
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "questions": [
            {
              "question": "Почему комбинация auto-fill/auto-fit с minmax() в Grid позволяет избежать медиа-запросов для адаптивности?",
              "correct_answer": "Браузер автоматически рассчитывает количество колонок на основе доступного пространства и заданных минимальных/максимальных размеров элементов",
              "var_1": "Auto-fill и auto-fit генерируют медиа-запросы автоматически на этапе компиляции CSS, что упрощает написание адаптивных стилей",
              "var_2": "Minmax() задаёт жёсткие брейкпоинты внутри CSS, которые работают аналогично медиа-запросам, но записываются в более компактном синтаксисе Grid-разметки",
              "var_3": "Эти функции отключают адаптивное поведение браузера и заставляют элементы масштабироваться пропорционально, сохраняя исходное количество колонок при любом размере экрана",
              "var_4": "Браузер автоматически рассчитывает количество колонок на основе доступного пространства и заданных минимальных/максимальных размеров элементов",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Auto-fill и auto-fit не генерируют медиа-запросы ни на каком этапе. Это runtime-механизмы браузера для динамического расчета layout, работающие на чистом CSS без компиляции или генерации дополнительного кода.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Minmax() не задает брейкпоинты. Это функция, определяющая диапазон размеров для колонок. В отличие от медиа-запросов, которые реагируют на размер viewport, minmax() работает с доступным пространством контейнера.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Это полностью неверно. Auto-fill/auto-fit не отключают адаптивность, а наоборот - создают её. Количество колонок динамически изменяется в зависимости от доступного пространства, а не остается фиксированным.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Браузер динамически вычисляет, сколько колонок помещается в контейнер, учитывая минимальный размер из minmax(). При изменении ширины контейнера количество колонок автоматически пересчитывается без медиа-запросов.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как с помощью CSS Grid создать адаптивную галерею карточек, которая автоматически подстраивает количество колонок под ширину контейнера без медиа-запросов?",
              "correct_answer": "Использовать grid-template-columns: repeat(auto-fit, minmax(min-value, 1fr)), где auto-fit автоматически заполняет доступное пространство, а minmax задаёт минимальную ширину карточки и гибкий максимум.",
              "var_1": "Задать display: grid с grid-template-columns: auto auto auto и flex-wrap: wrap, что создаёт автоматическое перераспределение карточек при изменении ширины контейнера.",
              "var_2": "Применить grid-auto-columns: minmax(200px, auto) вместе с grid-auto-flow: column, что позволяет браузеру самостоятельно вычислять оптимальное количество колонок.",
              "var_3": "Использовать grid-template-columns: repeat(auto-fill, 1fr), который автоматически распределяет колонки равномерно и подстраивает их количество под ширину экрана.",
              "var_4": "Использовать grid-template-columns: repeat(auto-fit, minmax(min-value, 1fr)), где auto-fit автоматически заполняет доступное пространство, а minmax задаёт минимальную ширину карточки и гибкий максимум.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "flex-wrap - это свойство Flexbox, несовместимое с Grid. grid-template-columns: auto auto auto задаёт фиксированное количество колонок (3), что не обеспечивает адаптивность.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "grid-auto-columns с grid-auto-flow: column создаёт горизонтальную прокрутку, а не адаптивное перераспределение карточек по строкам. Колонки не переносятся автоматически.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "repeat(auto-fill, 1fr) не работает корректно - браузер не может вычислить сколько колонок создать, так как 1fr - относительная единица без фиксированного минимума. Требуется minmax() с абсолютным значением.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это корректное решение: repeat(auto-fit, minmax()) создаёт адаптивную сетку, где auto-fit автоматически подстраивает количество колонок, а minmax устанавливает минимальную и максимальную ширину карточек.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "WeakMap и WeakSet - управление кэшированием динамически загружаемых компонентов без утечек памяти",
          "competency": "Знание языка программирования JavaScript",
          "questions": [
            {
              "question": "Почему WeakMap предпочтительнее Map для кэширования динамически загружаемых Angular-компонентов, которые могут быть уничтожены?",
              "correct_answer": "WeakMap хранит слабые ссылки на ключи-объекты, позволяя сборщику мусора автоматически удалять уничтоженные компоненты и связанный кэш без явной очистки.",
              "var_1": "WeakMap работает быстрее Map для объектных ключей, что критично для производительности при частой загрузке и выгрузке компонентов.",
              "var_2": "WeakMap предотвращает дублирование компонентов в кэше, автоматически заменяя старые версии новыми при повторной загрузке модуля.",
              "var_3": "WeakMap автоматически синхронизирует кэш с жизненным циклом Angular, вызывая ngOnDestroy при удалении ключей из коллекции.",
              "var_4": "WeakMap хранит слабые ссылки на ключи-объекты, позволяя сборщику мусора автоматически удалять уничтоженные компоненты и связанный кэш без явной очистки.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "WeakMap не обязательно быстрее Map. Основное преимущество WeakMap - это управление памятью через слабые ссылки, а не производительность операций. Более того, WeakMap имеет ограниченный API без методов итерации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "WeakMap не предотвращает дублирование и не заменяет автоматически старые версии новыми. Это обычная коллекция ключ-значение, где замена происходит только при явной перезаписи по тому же ключу.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "WeakMap не интегрирован с жизненным циклом Angular и не вызывает ngOnDestroy. Это две независимые системы - WeakMap работает на уровне JS сборщика мусора, а ngOnDestroy - это хук Angular.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это верный ответ. WeakMap действительно хранит слабые ссылки на ключи, что позволяет сборщику мусора автоматически очищать память от уничтоженных компонентов и связанного с ними кэша без необходимости явной очистки.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как правильно организовать кэширование экземпляров динамически загружаемых Angular-компонентов с помощью WeakMap, чтобы избежать утечек памяти при их уничтожении?",
              "correct_answer": "Использовать instance компонента как ключ WeakMap и явно удалять запись через DestroyRef/ngOnDestroy, так как Angular может держать внутренние ссылки на ComponentRef.",
              "var_1": "Использовать instance компонента как ключ WeakMap и явно удалять запись через DestroyRef/ngOnDestroy, так как Angular может держать внутренние ссылки на ComponentRef.",
              "var_2": "Хранить компоненты в WeakSet по их селектору, WeakSet автоматически очистит записи когда сборщик мусора удалит DOM-элементы.",
              "var_3": "Использовать ComponentRef как ключ WeakMap - при вызове destroy() ссылка автоматически удалится из кэша без дополнительных действий.",
              "var_4": "Использовать Map с ViewContainerRef как ключом и очищать кэш в OnPush стратегии, так как она контролирует жизненный цикл.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный подход - использовать instance компонента как ключ WeakMap и явно удалять через DestroyRef/ngOnDestroy, так как Angular держит внутренние ссылки на ComponentRef, что может препятствовать автоматической очистке.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "WeakSet требует объекты как значения, а селектор - это строка. Кроме того, WeakSet/WeakMap работают с JavaScript-объектами, а не с DOM-элементами напрямую, и не отслеживают их жизненный цикл.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "ComponentRef не гарантирует автоматическое удаление из WeakMap при destroy(), так как Angular может держать внутренние ссылки на ComponentRef для своих нужд, что предотвращает сборку мусора.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Map (не WeakMap) не предотвращает утечки памяти, а OnPush стратегия относится к Change Detection, а не к управлению жизненным циклом компонентов. ViewContainerRef также может иметь долгоживущие ссылки.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Utility Types и Type Manipulation - построение сложных типовых систем для State Management и API моделей",
          "competency": "Знание языка программирования TypeScript",
          "questions": [
            {
              "question": "Почему при типизации Redux-подобного store рекомендуется использовать discriminated unions вместо обычных union types для описания actions?",
              "correct_answer": "Discriminated unions позволяют TypeScript автоматически сужать типы payload в reducer через switch по общему дискриминанту, обеспечивая exhaustiveness checking и type-safe доступ к данным каждого action.",
              "var_1": "Discriminated unions обеспечивают лучшую производительность runtime проверок типов в reducer, так как switch по строковому литералу быстрее чем instanceof проверки для обычных union types.",
              "var_2": "Discriminated unions используются потому, что они позволяют TypeScript автоматически генерировать action creators и reducer boilerplate код, значительно сокращая количество ручного кода и исключая необходимость писать отдельные типы для каждого action в приложении.",
              "var_3": "Discriminated unions нужны для того, чтобы Redux DevTools корректно отображал типы actions в инспекторе состояния, поскольку обычные union types не сериализуются правильно и теряют информацию о конкретном типе action при логировании.",
              "var_4": "Discriminated unions позволяют TypeScript автоматически сужать типы payload в reducer через switch по общему дискриминанту, обеспечивая exhaustiveness checking и type-safe доступ к данным каждого action.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Discriminated unions - это compile-time конструкция TypeScript, которая не влияет на runtime производительность. После компиляции остается обычный JavaScript код. Switch по строковым литералам не связан с выбором discriminated unions vs обычных union types.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Discriminated unions не генерируют автоматически action creators и boilerplate код. Это чисто типовая конструкция TypeScript для type narrowing. Генерация кода требует дополнительных библиотек или утилит.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Redux DevTools работает с обычными JavaScript объектами и не зависит от типов TypeScript. Discriminated unions - это compile-time конструкция, которая не влияет на runtime сериализацию или отображение в DevTools.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Discriminated unions с общим дискриминантом (обычно поле 'type') позволяют TypeScript автоматически сужать типы в каждой ветке switch/if, обеспечивая type-safe доступ к payload и exhaustiveness checking.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как реализовать базовый Utility Type DeepReadonly<T>, который рекурсивно делает readonly вложенные объекты в state дереве Redux/NgRx?",
              "correct_answer": "type DeepReadonly<T> = T extends (...args: any[]) => any ? T : T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } : T",
              "var_1": "type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K] }",
              "var_2": "type DeepReadonly<T> = T extends object ? { [K in keyof T]: DeepReadonly<T[K]> } : T extends Primitive ? Readonly<T> : T",
              "var_3": "type DeepReadonly<T> = T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } : T extends Function ? T : Readonly<T>",
              "var_4": "type DeepReadonly<T> = T extends (...args: any[]) => any ? T : T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } : T",
              "correct_position": 4,
              "fixes_applied": 1,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Не проверяет тип T на верхнем уровне - примитивы вызовут ошибку при попытке keyof. Также не обрабатывает функции и массивы корректно",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: Корректная реализация: проверяет объекты, рекурсивно применяет DeepReadonly к свойствам с readonly модификатором, примитивы возвращает без изменений",
                "was_replaced": true,
                "original_before_fix": "type DeepReadonly<T> = T extends object ? Readonly<{ [K in keyof T]: DeepReadonly<T[K]> }> : T"
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Неверный порядок проверок: функции проверяются после объектов, но Function extends object === true, поэтому функции будут обработаны неверно. Лишний Readonly в конце",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Корректно проверяет функции первым условием (сохраняя их неизменными), затем обрабатывает объекты рекурсивно с readonly, и примитивы возвращает как есть",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Паттерны проектирования - реализация Singleton, Factory и Observer в Angular DI и RxJS-потоках",
          "competency": "Базовая теория программирования, ООП",
          "questions": [
            {
              "question": "Почему Angular-сервисы с providedIn: 'root' являются реализацией паттерна Singleton, а не просто обычными классами?",
              "correct_answer": "DI-контейнер создаёт единственный экземпляр сервиса на уровне корневого инжектора и переиспользует его для всех зависимостей в приложении",
              "var_1": "TypeScript автоматически делает класс Singleton при добавлении декоратора @Injectable с любыми параметрами",
              "var_2": "Сервис становится Singleton благодаря тому, что Angular компилирует класс в статический объект на этапе AOT-компиляции приложения",
              "var_3": "DI-контейнер создаёт единственный экземпляр сервиса на уровне корневого инжектора и переиспользует его для всех зависимостей в приложении",
              "var_4": "Декоратор providedIn: 'root' автоматически применяет модификатор static ко всем методам класса, что позволяет вызывать их без создания экземпляра",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "TypeScript не делает класс Singleton автоматически. Декоратор @Injectable сам по себе только помечает класс как injectable, Singleton создаётся DI-механизмом Angular.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "AOT-компиляция не превращает класс в статический объект. Singleton реализуется через DI-контейнер в runtime, а не на этапе компиляции.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это корректное описание Singleton в Angular: корневой инжектор создаёт один экземпляр сервиса при первом запросе и затем переиспользует его для всех компонентов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "providedIn: 'root' не применяет модификатор static к методам класса. Singleton работает через создание одного экземпляра класса, а не через статические методы.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как реализовать паттерн Factory для создания различных HTTP-интерцепторов в Angular, чтобы выбор конкретного интерцептора зависел от конфигурации окружения?",
              "correct_answer": "Создать фабричный сервис, возвращающий нужный класс интерцептора по environment-конфигу, и зарегистрировать через multi-провайдер HTTP_INTERCEPTORS с useFactory.",
              "var_1": "Реализовать switch-case внутри единого интерцептора, проверяя environment в методе intercept() и возвращая разные Observable.",
              "var_2": "Создать фабричный сервис, возвращающий нужный класс интерцептора по environment-конфигу, и зарегистрировать через multi-провайдер HTTP_INTERCEPTORS с useFactory.",
              "var_3": "Использовать декоратор @Injectable с параметром providedIn: 'factory' и передать environment напрямую в конструктор интерцептора.",
              "var_4": "Создать абстрактный класс интерцептора и наследовать его в каждом окружении, регистрируя через useClass с условием в app.module.ts.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "Это не паттерн Factory, а Strategy или условная логика внутри одного класса. Factory подразумевает создание разных объектов/классов, а не ветвление логики внутри одного.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это корректная реализация паттерна Factory в Angular. Фабричный сервис выбирает нужный класс интерцептора на основе environment, а useFactory с multi: true позволяет зарегистрировать его как HTTP-интерцептор. Это идиоматичный подход для Angular DI.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "В Angular не существует параметра providedIn: 'factory'. Существуют только 'root', 'platform', 'any' и модульные ссылки. Это неверный синтаксис.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Использование useClass с условием в модуле - это условная регистрация, но не паттерн Factory. Factory создает объекты динамически через фабричную функцию, а не через статические условия при конфигурации модуля.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Git reflog - восстановление потерянных коммитов и веток после неудачного rebase",
          "competency": "Знание Git",
          "questions": [
            {
              "question": "Почему git reflog способен найти коммиты после hard reset, хотя они недоступны из истории веток?",
              "correct_answer": "Reflog хранит локальный журнал всех перемещений HEAD независимо от достижимости коммитов из веток, до очистки сборщиком мусора.",
              "var_1": "Reflog синхронизируется с удалённым репозиторием, поэтому коммиты восстанавливаются из облачного хранилища.",
              "var_2": "Git хранит все коммиты в stash по умолчанию, откуда reflog их извлекает при необходимости.",
              "var_3": "Reflog автоматически создаёт резервные копии всех коммитов в специальной директории .git/backup, которая не очищается при hard reset.",
              "var_4": "Reflog хранит локальный журнал всех перемещений HEAD независимо от достижимости коммитов из веток, до очистки сборщиком мусора.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Reflog — это локальный журнал, который не синхронизируется с удалённым репозиторием. Он хранится только локально в .git/logs/",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Stash — это отдельный механизм для временного сохранения изменений. Коммиты не хранятся в stash по умолчанию, reflog работает независимо от stash",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Не существует директории .git/backup для автоматического резервного копирования. Reflog хранит записи в .git/logs/, а сами объекты коммитов остаются в .git/objects/",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Reflog ведёт локальный журнал всех изменений HEAD (и других ссылок), сохраняя хеши коммитов даже когда они становятся недостижимы из веток. Объекты коммитов остаются в .git/objects/ до запуска git gc",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую команду использовать для поиска состояния HEAD перед неудачным interactive rebase feature-ветки?",
              "correct_answer": "git reflog или git reflog show HEAD, затем найти запись 'rebase (start)' и восстановить через git reset --hard HEAD@{n}",
              "var_1": "git reflog или git reflog show HEAD, затем найти запись 'rebase (start)' и восстановить через git reset --hard HEAD@{n}",
              "var_2": "git log --walk-reflogs --oneline, затем найти запись 'checkout: moving from' и восстановить через git cherry-pick указанного коммита",
              "var_3": "git fsck --lost-found для поиска потерянных коммитов, затем восстановить через git checkout найденного хеша",
              "var_4": "git stash list для поиска автоматически сохранённого состояния перед rebase, затем восстановить через git stash apply stash@{n} --index",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "git reflog показывает историю перемещений HEAD, включая начало rebase. Запись 'rebase (start)' указывает на состояние до rebase, которое можно восстановить через git reset --hard HEAD@{n}",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "git log --walk-reflogs показывает reflog в формате лога, но cherry-pick не восстанавливает ветку целиком, а копирует отдельные коммиты. Для восстановления нужен git reset --hard",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "git fsck --lost-found ищет недостижимые объекты, но это сложный путь. Для восстановления после rebase достаточно reflog, который проще и быстрее показывает историю HEAD",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "git stash не сохраняет автоматически состояние перед rebase. Stash используется для временного сохранения незакоммиченных изменений вручную, не для восстановления после rebase",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Custom валидаторы - проектирование типизированной библиотеки асинхронных и кросс-полевых валидаторов",
          "competency": "Формы (Template/Reactive, валидаторы)",
          "questions": [
            {
              "question": "Почему типизированные кросс-полевые валидаторы в Angular требуют generic-параметризации на уровне FormGroup, а не отдельных контролов?",
              "correct_answer": "Кросс-полевые валидаторы работают с несколькими связанными полями одновременно, поэтому им нужен доступ к типизированной структуре всей группы для безопасного обращения к зависимым контролам.",
              "var_1": "Кросс-полевые валидаторы работают с несколькими связанными полями одновременно, поэтому им нужен доступ к типизированной структуре всей группы для безопасного обращения к зависимым контролам.",
              "var_2": "Generic-параметризация на уровне FormGroup нужна для оптимизации change detection, так как Angular отслеживает изменения на уровне группы, а не отдельных полей.",
              "var_3": "FormGroup-параметризация позволяет валидатору подписаться на valueChanges всей формы одной подпиской, что эффективнее множественных подписок на отдельные контролы.",
              "var_4": "Типизация группы нужна потому что Angular использует Proxy для перехвата обращений к контролам, и TypeScript требует generic для корректной работы декораторов валидаторов.",
              "correct_position": 1,
              "fixes_applied": 1,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Кросс-полевые валидаторы действительно требуют типизации FormGroup, чтобы TypeScript мог статически проверить доступ к нескольким связанным полям (например, password и confirmPassword), обеспечивая type-safety при обращении к .get() или .value.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Generic-параметризация никак не связана с оптимизацией change detection. Change detection работает одинаково для типизированных и нетипизированных форм — это механизм runtime, а generic-параметры существуют только на этапе компиляции TypeScript.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Типизация FormGroup не имеет отношения к подпискам на valueChanges. Кросс-полевой валидатор может подписаться на valueChanges группы независимо от наличия generic-параметров — это runtime-функциональность, не связанная с типизацией.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Заменён. Оригинал был верным: TypeScript действительно требует общий generic-контейнер для вывода типов связанных полей. Без типизации на уровне FormGroup<T> компилятор не сможет вывести типы отдельных контролов и их взаимосвязи, что делает невозможным type-safe доступ к зависимым полям.",
                "was_replaced": true,
                "original_before_fix": "Типизация на уровне группы требуется из-за ограничений TypeScript, который не поддерживает вывод типов для связанных контролов без общего generic-контейнера."
              }
            },
            {
              "question": "Как спроектировать типизированный асинхронный кросс-полевой валидатор для проверки уникальности комбинации email и organizationId с debounce и отменой предыдущих запросов?",
              "correct_answer": "Создать AsyncValidatorFn, принимающий AbstractControl<{email: string, organizationId: string}>, использовать switchMap для отмены предыдущих запросов, debounceTime для задержки, возвращать Observable<ValidationErrors | null> с типизированным ключом ошибки.",
              "var_1": "Создать AsyncValidatorFn, принимающий AbstractControl<{email: string, organizationId: string}>, использовать switchMap для отмены предыдущих запросов, debounceTime для задержки, возвращать Observable<ValidationErrors | null> с типизированным ключом ошибки.",
              "var_2": "Создать синхронный Validator, который внутри подписывается на HTTP-сервис через subscribe(), использовать setTimeout для debounce, сохранять результат в локальную переменную и возвращать ValidationErrors.",
              "var_3": "Создать директиву валидатора с @Input для конфигурации, использовать exhaustMap для гарантии завершения запросов, ReplaySubject для кэширования, возвращать Observable<boolean> с преобразованием в ошибки.",
              "var_4": "Использовать ValidatorFn с Promise.all для параллельных запросов на проверку email и organizationId отдельно, объединять результаты через mergeMap, применять distinctUntilChanged для оптимизации.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Правильный подход: AsyncValidatorFn с типизированным AbstractControl, switchMap отменяет предыдущие запросы при новых изменениях, debounceTime задерживает запросы, возвращается Observable<ValidationErrors | null> с типизированной ошибкой — стандартный контракт для асинхронных валидаторов в Angular.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Это антипаттерн. Синхронный Validator не может корректно работать с асинхронными операциями через subscribe(). Для асинхронной проверки нужен AsyncValidator/AsyncValidatorFn, возвращающий Observable или Promise. setTimeout вместо debounceTime — плохая практика для RxJS.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "exhaustMap не подходит для валидаторов с debounce, т.к. он игнорирует новые значения до завершения текущего запроса. Нужен switchMap для отмены предыдущих. Также валидатор должен возвращать Observable<ValidationErrors | null>, а не Observable<boolean>. Директива — не лучший подход для асинхронных валидаторов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "ValidatorFn — это синхронный валидатор, он не может работать с Promise. Для асинхронных операций нужен AsyncValidatorFn. Promise.all с mergeMap — неправильная комбинация операторов. Задача требует проверки комбинации полей вместе, а не по отдельности.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Angular Security Context - разработка кастомных санитайзеров и bypass-механизмов для защиты от DOM-based XSS и prototype pollution",
          "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
          "questions": [
            {
              "question": "Почему Angular требует использования SecurityContext при создании кастомного санитайзера вместо простой строковой фильтрации?",
              "correct_answer": "SecurityContext определяет контекст использования данных (HTML, URL, Style), позволяя применять специфичные правила санитизации для каждого типа DOM-вставки и предотвращая контекстно-зависимые XSS-атаки",
              "var_1": "SecurityContext определяет контекст использования данных (HTML, URL, Style), позволяя применять специфичные правила санитизации для каждого типа DOM-вставки и предотвращая контекстно-зависимые XSS-атаки",
              "var_2": "SecurityContext нужен исключительно для типизации данных в TypeScript, чтобы компилятор мог проверять корректность типов на этапе сборки и предотвращать runtime-ошибки при вставке значений в шаблон, а не для безопасности как таковой",
              "var_3": "Строковая фильтрация недостаточна потому что Angular требует единого API для всех операций с DOM, а SecurityContext просто стандартизирует интерфейс взаимодействия с DomSanitizer",
              "var_4": "SecurityContext используется для оптимизации производительности санитизации, позволяя Angular кэшировать результаты очистки для повторно используемых строк и избегать повторной обработки одинаковых значений",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. SecurityContext действительно определяет контекст использования данных (HTML, URL, Style, Script, Resource URL), что позволяет Angular применять специфичные правила санитизации для каждого типа DOM-вставки и предотвращать контекстно-зависимые XSS-атаки, которые невозможно предотвратить простой строковой фильтрацией.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "SecurityContext не предназначен для типизации TypeScript. Это runtime-механизм Angular для определения контекста использования данных (HTML, URL, Style, Script, Resource URL), который применяет специфичные правила санитизации для предотвращения XSS-атак в различных контекстах DOM.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "SecurityContext не просто стандартизирует интерфейс. Его ключевая роль - определение контекста использования данных для применения правильных правил санитизации. Без понимания контекста (HTML vs URL vs Style) невозможно корректно очистить данные от XSS-угроз, так как разные контексты требуют разных подходов к санитизации.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "SecurityContext не используется для оптимизации производительности через кэширование. Его основная цель - определение контекста использования данных для применения контекстно-зависимых правил санитизации и предотвращения XSS-атак.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как реализовать кастомный санитайзер для Rich Text Editor, который разрешает безопасные HTML-теги (b, i, p), но блокирует опасные атрибуты типа onerror и javascript: в href?",
              "correct_answer": "Создать Pipe с DomSanitizer, парсить HTML через DOMParser, рекурсивно обходить ноды, удалять запрещённые атрибуты (on*, javascript:), оставлять whitelist тегов, возвращать через bypassSecurityTrustHtml.",
              "var_1": "Создать Pipe с DomSanitizer, парсить HTML через DOMParser, рекурсивно обходить ноды, удалять запрещённые атрибуты (on*, javascript:), оставлять whitelist тегов, возвращать через bypassSecurityTrustHtml.",
              "var_2": "Создать директиву с ElementRef, использовать nativeElement.innerHTML для вставки контента, применить CSS-правило pointer-events: none для блокировки событий, добавить sanitize: true в конфигурацию компонента для автоматической очистки опасных атрибутов браузером.",
              "var_3": "Настроить Content Security Policy в meta-теге, добавить директиву unsafe-inline для стилей, полагаться на встроенную защиту браузера от XSS, использовать innerHTML напрямую без парсинга DOM, так как CSP автоматически блокирует все опасные атрибуты и javascript: ссылки.",
              "var_4": "Использовать регулярные выражения для фильтрации HTML-строки напрямую, удалять теги через replace(/\\<script\\>/gi, ''), проверять наличие onclick через indexOf, затем передавать результат в innerHTML компонента без дополнительной санитизации через DomSanitizer.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это правильный подход: DOMParser безопасно парсит HTML в DOM-дерево, рекурсивный обход позволяет проверить все ноды и атрибуты, whitelist тегов и удаление опасных атрибутов (on*, javascript:) обеспечивает защиту, а bypassSecurityTrustHtml корректно возвращает санитизированный контент.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "pointer-events: none не блокирует события типа onerror или onload, которые срабатывают автоматически. Настройки sanitize: true в конфигурации компонента не существует в Angular. nativeElement.innerHTML без санитизации создаёт XSS-уязвимость.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "CSP не блокирует автоматически опасные атрибуты вроде onerror или javascript: в href. CSP контролирует источники загрузки ресурсов, но не санитизирует DOM. unsafe-inline делает CSP менее безопасным. innerHTML без санитизации создаёт XSS-уязвимость.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Регулярные выражения недостаточны для парсинга HTML - их легко обойти через вариации написания (OnClick, on%63lick, и т.д.). Этот подход не учитывает множество векторов атак и не является безопасным решением для санитизации HTML.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Оптимизация производительности signals - применение untracked, batching и стратегий минимизации перерисовок",
          "competency": "Состояние приложения (signals services)",
          "questions": [
            {
              "question": "Почему использование untracked внутри computed предотвращает лишние пересчёты при изменении определённых зависимостей?",
              "correct_answer": "untracked читает signal без регистрации зависимости в reactive graph, поэтому изменения этого signal не триггерят пересчёт computed",
              "var_1": "untracked кэширует значение signal на момент первого вызова computed и возвращает его при последующих обращениях, избегая повторных вычислений при изменениях",
              "var_2": "untracked помечает signal как низкоприоритетный в reactive graph, поэтому его изменения обрабатываются только при явном запросе значения computed",
              "var_3": "untracked откладывает регистрацию зависимости до следующего цикла change detection, что позволяет batch-ить несколько изменений в одно обновление computed",
              "var_4": "untracked читает signal без регистрации зависимости в reactive graph, поэтому изменения этого signal не триггерят пересчёт computed",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "untracked не кэширует значения signal. Он читает актуальное значение в момент вызова, но не регистрирует зависимость в reactive graph.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "untracked не помечает signal как низкоприоритетный и не использует систему приоритетов. Он полностью исключает регистрацию зависимости, а не откладывает обработку.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "untracked не откладывает регистрацию зависимости и не связан с батчингом изменений. Он просто предотвращает регистрацию зависимости при чтении signal.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильное объяснение. untracked() позволяет прочитать значение signal без создания reactive dependency, поэтому изменения этого signal не будут триггерить пересчёт computed.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой подход следует применить для предотвращения создания ненужной зависимости при логировании значения signal внутри effect?",
              "correct_answer": "Использовать untracked(() => signal()) для чтения значения без создания реактивной зависимости, чтобы effect не перезапускался при изменении логируемого signal.",
              "var_1": "Вызвать signal.value напрямую вместо signal(), так как прямой доступ к value не регистрирует реактивную зависимость в effect.",
              "var_2": "Обернуть весь effect в setTimeout для асинхронного выполнения логирования, что позволит отложить чтение signal и избежать создания зависимости в текущем цикле реактивности.",
              "var_3": "Использовать computed(() => signal()) как промежуточный слой для логирования, поскольку computed кэширует значение и предотвращает лишние вызовы effect при повторном чтении.",
              "var_4": "Использовать untracked(() => signal()) для чтения значения без создания реактивной зависимости, чтобы effect не перезапускался при изменении логируемого signal.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "В Angular signals нет свойства .value для прямого доступа. Signal всегда вызывается как функция signal(), и любой вызов внутри effect создаёт реактивную зависимость.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "setTimeout не предотвращает создание зависимости. Если signal() вызывается внутри effect (даже в setTimeout), зависимость всё равно регистрируется в момент выполнения колбэка в контексте effect.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "computed() не предотвращает создание зависимости в effect. Наоборот, чтение computed внутри effect создаёт зависимость от этого computed, который в свою очередь зависит от исходного signal, что не решает проблему.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "untracked() — это правильный способ читать signal без создания реактивной зависимости. Он специально предназначен для таких случаев, как логирование, где не нужно перезапускать effect.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Request Deduplication и Caching - имплементация механизмов дедупликации параллельных запросов через RxJS shareReplay и кеширования с TTL стратегиями",
          "competency": "HTTP/интерцепторы/типизация API",
          "questions": [
            {
              "question": "Почему использование shareReplay(1) без параметра refCount может привести к утечкам памяти при дедупликации HTTP-запросов?",
              "correct_answer": "Без refCount:true подписка на источник сохраняется навсегда, даже когда все подписчики отписались, удерживая Observable и закешированные данные в памяти.",
              "var_1": "shareReplay(1) сохраняет последнее значение бесконечно, но память освобождается автоматически при unsubscribe всех подписчиков.",
              "var_2": "Параметр bufferSize:1 создаёт внутренний буфер, который не очищается сборщиком мусора из-за циклических ссылок в RxJS.",
              "var_3": "Без refCount:true подписка на источник сохраняется навсегда, даже когда все подписчики отписались, удерживая Observable и закешированные данные в памяти.",
              "var_4": "Без refCount:true каждый новый подписчик создаёт отдельный HTTP-запрос, что приводит к дублированию данных в памяти.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Это неверно: без refCount:true память НЕ освобождается автоматически при unsubscribe всех подписчиков. Подписка на источник остаётся активной, удерживая данные в памяти - именно в этом и заключается утечка.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "bufferSize:1 сам по себе не создаёт утечек из-за циклических ссылок. Буфер управляется RxJS корректно, проблема не в сборщике мусора, а в том, что без refCount подписка на источник остаётся активной даже после отписки всех подписчиков.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение утечки памяти: shareReplay(1) без refCount:true создаёт подписку на источник, которая никогда не отменяется, даже когда все внешние подписчики отписались. Это удерживает Observable chain и закешированные данные в памяти навсегда.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Это противоположность реальности: shareReplay как раз предотвращает создание дублирующих запросов, делая Observable multicast. Без refCount проблема в том, что подписка на источник не отменяется, а не в дублировании запросов.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как реализовать кеширование HTTP-запросов с TTL через интерцептор для дедупликации параллельных запросов к одному endpoint и автоматической инвалидации по истечении времени?",
              "correct_answer": "Создать сервис-кеш с Map, хранящей Observable через shareReplay({bufferSize: 1, refCount: false}), с timestamp для каждого ключа. В интерцепторе проверять наличие и актуальность записи по TTL, при истечении удалять и выполнять новый запрос.",
              "var_1": "Использовать HTTP_INTERCEPTORS с локальным кешем в виде WeakMap для автоматической очистки памяти, где ключом является объект Request. Применять shareReplay({bufferSize: 1, refCount: true}) для автоматического завершения потока при отписке всех подписчиков, что обеспечит естественную инвалидацию кеша без TTL.",
              "var_2": "Реализовать кеширование через AsyncPipe напрямую в шаблонах компонентов, сохраняя результаты запросов в BehaviorSubject. TTL реализуется через setTimeout, который вызывает next(null) для очистки. Интерцептор не требуется, так как Angular автоматически дедуплицирует запросы при использовании OnPush стратегии.",
              "var_3": "Создать сервис-кеш с Map, хранящей Observable через shareReplay({bufferSize: 1, refCount: false}), с timestamp для каждого ключа. В интерцепторе проверять наличие и актуальность записи по TTL, при истечении удалять и выполнять новый запрос.",
              "var_4": "Создать декоратор @Cacheable с параметром TTL для методов сервиса, использующий metadata reflection для хранения кеша. В интерцепторе проверять наличие декоратора и применять catchError для повторного запроса при истечении TTL, используя shareReplay без параметров для базового кеширования.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "WeakMap не подходит для HTTP кеширования, так как ключи (Request объекты) будут разными для каждого запроса, даже к одному endpoint. refCount: true автоматически завершает поток, что сломает кеширование для последующих подписчиков. Нет механизма TTL.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Angular не дедуплицирует запросы автоматически при OnPush стратегии - это заблуждение. Кеширование через компоненты нарушает принцип разделения ответственности. BehaviorSubject в шаблонах не обеспечивает дедупликацию параллельных запросов на уровне HTTP.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Правильный подход: Map с ключами-URL, shareReplay с refCount: false сохраняет Observable для всех подписчиков, timestamp позволяет проверять TTL, интерцептор координирует проверку и инвалидацию. Обеспечивает дедупликацию и кеширование с TTL.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "catchError не подходит для управления TTL - он обрабатывает ошибки, а не время жизни кеша. shareReplay без параметров (по умолчанию refCount: false) будет держать подписку вечно. Декораторы усложняют архитектуру без явных преимуществ для HTTP интерцептора.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Guards система - построение цепочки функциональных guards с кешированием результатов и обработкой асинхронных зависимостей",
          "competency": "Роутинг (standalone, guards, resolvers)",
          "questions": [
            {
              "question": "Почему кеширование результатов guards между последовательными проверками требует учёта инвалидации при изменении состояния аутентификации?",
              "correct_answer": "Закешированный положительный результат guard станет невалидным после logout, что создаст уязвимость доступа к защищённым маршрутам.",
              "var_1": "Инвалидация нужна для синхронизации кеша guards с жизненным циклом компонентов маршрута.",
              "var_2": "Закешированный положительный результат guard станет невалидным после logout, что создаст уязвимость доступа к защищённым маршрутам.",
              "var_3": "Кеширование guards требует инвалидации потому что Angular автоматически очищает кеш при каждой смене роута, и без ручного контроля данные будут теряться.",
              "var_4": "Кеширование без инвалидации приводит к утечкам памяти, так как устаревшие результаты накапливаются в памяти приложения.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Инвалидация кеша guards не связана напрямую с жизненным циклом компонентов маршрута. Guards выполняются ДО создания компонентов и их жизненный цикл независим. Основная причина инвалидации - изменение состояния аутентификации/авторизации, которое влияет на корректность закешированных решений о доступе.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это верно. Закешированный результат успешной проверки guard (например, canActivate вернул true для аутентифицированного пользователя) останется в кеше после logout. Без инвалидации пользователь сможет получить доступ к защищённым маршрутам используя устаревший положительный результат, что создаёт критическую уязвимость безопасности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Angular НЕ очищает автоматически кеш guards при смене роута. Кеширование guards - это кастомная логика разработчика, Angular не предоставляет встроенного механизма автоматической очистки. Проблема инвалидации связана с безопасностью, а не с автоматическим поведением фреймворка.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Хотя плохо спроектированное кеширование теоретически может привести к утечкам памяти, это не главная причина необходимости инвалидации при изменении состояния аутентификации. Основная проблема - безопасность: устаревшие результаты дают неправильные разрешения доступа, а не накапливаются в памяти. Обычно кеш guards имеет ограниченный размер по количеству маршрутов.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как реализовать кеширование результатов функционального guard между навигациями, чтобы избежать повторных HTTP-запросов к API проверки прав доступа?",
              "correct_answer": "Использовать сервис с BehaviorSubject/signal для хранения состояния авторизации, комбинируя с shareReplay(1) для HTTP-запросов и проверяя кеш перед выполнением запроса в guard через inject().",
              "var_1": "Реализовать кеширование через декоратор @Cacheable на методе guard, который автоматически сохраняет результаты в Map по ключу маршрута и возвращает закешированное значение при повторных навигациях без дополнительной логики.",
              "var_2": "Применить RouteReuseStrategy для кеширования состояния guards вместе с компонентами, что автоматически предотвращает повторные проверки при возврате на маршрут.",
              "var_3": "Использовать localStorage для сохранения результатов проверки прав доступа, считывая данные синхронно в начале выполнения guard и обновляя их после каждого успешного HTTP-запроса, что позволяет избежать повторных обращений к серверу.",
              "var_4": "Использовать сервис с BehaviorSubject/signal для хранения состояния авторизации, комбинируя с shareReplay(1) для HTTP-запросов и проверяя кеш перед выполнением запроса в guard через inject().",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Функциональные guards - это функции, к ним нельзя применить декораторы (декораторы применимы только к классам и их членам). Также декоратор @Cacheable не существует в Angular из коробки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "RouteReuseStrategy управляет переиспользованием компонентов, а не результатов guards. Guards выполняются при каждой навигации независимо от стратегии переиспользования компонентов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "localStorage не подходит для кеширования между навигациями в рамках одной сессии - это для персистентного хранения между перезагрузками. Также синхронное чтение блокирует поток, а данные могут устареть.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это правильный подход: сервис с BehaviorSubject/signal хранит состояние авторизации, shareReplay(1) кеширует Observable HTTP-запроса, а в guard через inject() проверяется кеш перед выполнением запроса, что предотвращает дублирование.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Управление подписками - паттерны автоматической отписки через takeUntil, takeWhile и кастомные операторы для предотвращения memory leaks",
          "competency": "RxJS (операторы, пайплайны, управление подписками)",
          "questions": [
            {
              "question": "Почему при использовании takeUntil источник завершения должен располагаться последним в цепочке операторов?",
              "correct_answer": "Операторы после takeUntil продолжат работать и могут создать подписки, которые не будут автоматически отписаны при эмите завершающего сигнала.",
              "var_1": "Операторы до takeUntil не получат завершающий сигнал и будут удерживать ссылки на Observable, что приведёт к memory leaks.",
              "var_2": "Это требование Angular style guide для улучшения читаемости кода и соблюдения единого стандарта в проектах команды.",
              "var_3": "Операторы после takeUntil продолжат работать и могут создать подписки, которые не будут автоматически отписаны при эмите завершающего сигнала.",
              "var_4": "TakeUntil перехватывает поток данных, и операторы до него не смогут обработать последнее значение перед завершением потока.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Операторы до takeUntil получат завершающий сигнал (complete), когда takeUntil завершит поток. Проблема не в операторах до takeUntil, а в операторах после него. Операторы до takeUntil корректно завершаются вместе с потоком.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Это не просто стилистическое требование для читаемости. Размещение takeUntil в конце - это технически обоснованное требование для предотвращения утечек памяти, а не convention для единообразия кода. Неправильное размещение приведёт к реальным проблемам с памятью.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Если takeUntil расположен не в конце цепочки, операторы после него создадут новые подписки на результирующий Observable. Когда завершающий сигнал эмитится, takeUntil завершит свой поток, но операторы после него уже создали свои внутренние подписки, которые не будут автоматически отписаны, что приведёт к утечкам памяти.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "TakeUntil не перехватывает поток данных в смысле блокировки значений до него. Операторы до takeUntil нормально обрабатывают все значения. TakeUntil просто завершает поток, когда notifier эмитит значение. Проблема не в обработке последнего значения операторами до takeUntil.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую проблему создаёт использование takeUntil в начале pipe вместо конца, и как это влияет на предотвращение memory leaks?",
              "correct_answer": "Операторы после takeUntil (switchMap, mergeMap) держат внутренние подписки, которые не отпишутся. takeUntil должен быть последним оператором для корректной очистки всех подписок.",
              "var_1": "takeUntil в начале pipe вызывает синтаксическую ошибку TypeScript, поскольку оператор требует предварительной инициализации потока данных. Порядок операторов строго регламентирован спецификацией RxJS для корректной типизации.",
              "var_2": "takeUntil в начале pipe блокирует прохождение событий к последующим операторам, но сами подписки создаются корректно и очищаются при destroy компонента.",
              "var_3": "Операторы после takeUntil (switchMap, mergeMap) держат внутренние подписки, которые не отпишутся. takeUntil должен быть последним оператором для корректной очистки всех подписок.",
              "var_4": "Расположение takeUntil в начале pipe приводит к многократному срабатыванию complete callback, что создаёт дублирование логики очистки ресурсов. Memory leaks возникают из-за повторных вызовов finalize.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "takeUntil не вызывает синтаксических ошибок TypeScript независимо от позиции в pipe. RxJS не имеет строгих ограничений на порядок операторов с точки зрения компиляции. Проблема связана с логикой выполнения, а не с типизацией.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "takeUntil в начале не блокирует прохождение событий к последующим операторам до момента срабатывания notifier. Проблема в том, что последующие операторы (особенно switchMap, mergeMap) создают вложенные подписки ПОСЛЕ takeUntil, которые не будут очищены.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение проблемы. Операторы высшего порядка (switchMap, mergeMap, exhaustMap и т.д.), расположенные после takeUntil, создают внутренние подписки на вложенные Observable, которые не будут автоматически отменены при срабатывании takeUntil, что приводит к memory leaks.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "takeUntil не вызывает многократное срабатывание complete callback независимо от позиции. Проблема не в дублировании finalize, а в том, что операторы после takeUntil могут создавать подписки, которые не будут отменены.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "HTTP retry и error handling - проектирование backoff стратегий с экспоненциальной задержкой и circuit breaker паттерна для обработки временных сбоев сети",
          "competency": "Понимание принципов работы сетевых протоколов, знание HTTP",
          "questions": [
            {
              "question": "Почему экспоненциальная задержка между retry-попытками эффективнее фиксированной при массовых сбоях сервера?",
              "correct_answer": "Она распределяет нагрузку во времени, предотвращая thundering herd эффект, когда множество клиентов одновременно повторяют запросы и перегружают восстанавливающийся сервер",
              "var_1": "Она позволяет клиенту быстрее определить точное время восстановления сервера, постепенно увеличивая интервалы опроса и анализируя паттерны ответов для предсказания оптимального момента следующего запроса",
              "var_2": "Она распределяет нагрузку во времени, предотвращая thundering herd эффект, когда множество клиентов одновременно повторяют запросы и перегружают восстанавливающийся сервер",
              "var_3": "Экспоненциальная задержка снижает потребление памяти на клиенте за счёт уменьшения количества активных соединений в очереди ожидания, что особенно критично для мобильных устройств с ограниченными ресурсами",
              "var_4": "Она гарантирует, что каждый следующий запрос будет обработан с более высоким приоритетом на сервере, так как серверы автоматически повышают приоритет для запросов с большими интервалами между попытками",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Экспоненциальная задержка не предназначена для предсказания времени восстановления сервера. Клиент не анализирует паттерны ответов для определения оптимального момента - это было бы излишне сложно. Цель проще - дать серверу время на восстановление и избежать перегрузки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. Экспоненциальная задержка действительно предотвращает thundering herd эффект, когда после сбоя все клиенты одновременно пытаются переподключиться. Увеличивающиеся интервалы распределяют запросы во времени, давая серверу время восстановиться без повторной перегрузки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Экспоненциальная задержка не связана с управлением памятью клиента. Активные соединения в очереди ожидания не уменьшаются от типа задержки - соединение либо активно, либо закрыто. Основная цель - распределение нагрузки на сервер, а не оптимизация ресурсов клиента.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Серверы не повышают автоматически приоритет запросов на основе интервалов между retry-попытками. Приоритизация запросов (если существует) основана на других факторах (тип запроса, SLA, заголовки), но не на времени между попытками клиента.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как бы вы реализовали переход circuit breaker из состояния 'open' обратно в 'closed' при восстановлении внешнего API в Angular-приложении?",
              "correct_answer": "Через промежуточное состояние 'half-open': после таймаута в 'open' пропускается один тестовый запрос, при успехе — переход в 'closed' и сброс счётчика ошибок, при неудаче — возврат в 'open' с увеличенным таймаутом.",
              "var_1": "Через промежуточное состояние 'half-open': после таймаута в 'open' пропускается один тестовый запрос, при успехе — переход в 'closed' и сброс счётчика ошибок, при неудаче — возврат в 'open' с увеличенным таймаутом.",
              "var_2": "Через постепенное увеличение пропускной способности: после таймаута circuit breaker начинает пропускать запросы с линейно возрастающим процентом (10%, 20%, 30%), и только при достижении 100% успешных ответов происходит полный переход в состояние 'closed' со сбросом метрик.",
              "var_3": "Через автоматический переход в 'closed' по истечении фиксированного таймаута: после заданного периода ожидания в состоянии 'open' circuit breaker автоматически переключается в 'closed' и возобновляет все запросы без предварительной проверки, сбрасывая счётчик ошибок до нуля.",
              "var_4": "Через внешний health-check endpoint: отдельный сервис периодически опрашивает статус API, и при получении успешного ответа от health endpoint circuit breaker немедленно переключается из 'open' в 'closed', минуя промежуточные состояния и сбрасывая счётчики.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": true,
                "reason": "Это корректная и наиболее распространённая реализация паттерна circuit breaker. Состояние 'half-open' позволяет безопасно проверить восстановление сервиса одним тестовым запросом перед полным возобновлением трафика, что предотвращает перегрузку нестабильного API.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Описанный механизм постепенного увеличения пропускной способности больше похож на throttling или rate limiting, а не на классический circuit breaker. Стандартный паттерн использует состояния (closed/open/half-open), а не процентное распределение трафика.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Автоматический переход напрямую в 'closed' без проверки работоспособности API опасен - это может привести к немедленной перегрузке всё ещё нестабильного сервиса. Классический паттерн circuit breaker требует проверки перед полным восстановлением.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Хотя health-check может быть полезным дополнением, немедленный переход из 'open' в 'closed' минуя 'half-open' состояние нарушает безопасность паттерна. Health endpoint может быть доступен, когда основное API всё ещё нестабильно.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Signal equality functions - создание custom comparators для предотвращения лишних обновлений в сложных структурах данных",
          "competency": "Signals API (signal/computed/effect)",
          "questions": [
            {
              "question": "Почему использование shallow comparison по умолчанию в signals может приводить к избыточным перерисовкам при работе с объектами?",
              "correct_answer": "Каждый новый объект с идентичными свойствами имеет уникальную ссылку, поэтому === всегда возвращает false, даже если данные не изменились.",
              "var_1": "Angular намеренно использует строгое сравнение для обеспечения иммутабельности данных, что вызывает принудительные обновления.",
              "var_2": "Signals кэшируют предыдущее значение неправильно, что приводит к ложным срабатываниям при любом доступе.",
              "var_3": "Каждый новый объект с идентичными свойствами имеет уникальную ссылку, поэтому === всегда возвращает false, даже если данные не изменились.",
              "var_4": "Shallow comparison проверяет только первый уровень вложенности объекта, поэтому изменения во вложенных свойствах не обнаруживаются и триггерят полное обновление.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Хотя Angular действительно использует строгое сравнение (===) по умолчанию, это не намеренное решение для обеспечения иммутабельности. Это просто стандартное поведение JavaScript, которое может быть переопределено через custom equality functions.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Это неверно. Signals корректно кэшируют предыдущее значение. Проблема не в механизме кэширования, а в способе сравнения значений (по ссылке вместо по содержимому).",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение проблемы. По умолчанию signals используют === для сравнения, что сравнивает ссылки объектов, а не их содержимое. Даже если два объекта имеют идентичные свойства, они будут разными ссылками, что приведет к обновлению signal и перерисовке.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Это неверное понимание термина 'shallow comparison'. По умолчанию signals используют не shallow comparison (сравнение первого уровня свойств), а строгое сравнение по ссылке (===). Shallow comparison как раз решал бы часть проблем, сравнивая свойства первого уровня.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую custom equality function вы реализуете для signal, хранящего массив объектов с id, чтобы избежать перерендера при получении идентичных данных с сервера?",
              "correct_answer": "Функцию, сравнивающую массивы по длине и id каждого элемента: (a, b) => a.length === b.length && a.every((item, i) => item.id === b[i].id), либо глубокое сравнение релевантных полей через JSON.stringify или lodash.isEqual.",
              "var_1": "Функцию, которая всегда возвращает false: (a, b) => false, чтобы гарантировать обновление сигнала при каждом ответе сервера. Это предотвратит устаревание данных и обеспечит консистентность UI.",
              "var_2": "Функцию проверки ссылочного равенства массивов через Object.is(), так как Angular автоматически кэширует данные с сервера и повторный запрос вернёт тот же объект в памяти.",
              "var_3": "Функцию, сравнивающую массивы по длине и id каждого элемента: (a, b) => a.length === b.length && a.every((item, i) => item.id === b[i].id), либо глубокое сравнение релевантных полей через JSON.stringify или lodash.isEqual.",
              "var_4": "Достаточно использовать стандартную equality function сигнала (===), добавив trackBy функцию в шаблоне для @for, которая предотвратит перерендер компонентов даже при изменении ссылки на массив.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Функция, возвращающая false, заставит signal обновляться ВСЕГДА, даже при идентичных данных. Это противоположно цели - избежать лишних обновлений. Приведёт к избыточным перерендерам, а не предотвратит их.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Angular НЕ кэширует автоматически данные с сервера на уровне объектов в памяти. HTTP запросы возвращают новые объекты (десериализация JSON), поэтому Object.is() всегда вернёт false для разных ответов, даже с идентичными данными.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это корректный подход для custom equality function в signal. Сравнение по длине массива и id элементов (или глубокое сравнение полей) позволяет определить семантическую идентичность данных, предотвращая обновление signal при получении идентичных данных с новой ссылкой.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "trackBy в @for решает проблему перерендера ЭЛЕМЕНТОВ списка при изменении массива, но НЕ предотвращает обновление самого signal. Если signal обновится (из-за === сравнения ссылок), все зависимые computed/effect всё равно выполнятся, даже с trackBy.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Жизненный цикл компонентов - глубокое использование хуков для управления динамической композицией через ViewContainerRef и ComponentRef",
          "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for, OnPush)",
          "questions": [
            {
              "question": "Почему при динамическом создании компонента через ViewContainerRef.createComponent хуки ngOnChanges не вызываются автоматически при изменении @Input свойств?",
              "correct_answer": "Angular отслеживает изменения @Input только через шаблонные привязки, а при императивном создании свойства устанавливаются напрямую, минуя механизм change detection для входных данных.",
              "var_1": "ngOnChanges требует наличия декоратора @Input с установленным флагом trackChanges: true, который по умолчанию отключен при динамическом создании компонентов через ViewContainerRef.createComponent.",
              "var_2": "Angular отслеживает изменения @Input только через шаблонные привязки, а при императивном создании свойства устанавливаются напрямую, минуя механизм change detection для входных данных.",
              "var_3": "Динамически созданные компоненты работают в режиме OnPush по умолчанию, что блокирует автоматический вызов ngOnChanges.",
              "var_4": "ViewContainerRef создаёт компоненты вне основного дерева change detection, поэтому Angular не может отслеживать их @Input свойства до ручного присоединения.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "В Angular не существует флага trackChanges: true для декоратора @Input. Это выдуманный API. ngOnChanges работает автоматически для всех @Input свойств при обнаружении изменений через шаблонные привязки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение. ngOnChanges вызывается только когда Angular обнаруживает изменения через механизм шаблонных привязок. При императивном присваивании значений напрямую к свойствам ComponentRef.instance (например, componentRef.instance.myInput = value), Angular не отслеживает эти изменения как @Input изменения, поэтому ngOnChanges не срабатывает автоматически.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "OnPush стратегия не блокирует ngOnChanges. Динамически созданные компоненты не работают в режиме OnPush по умолчанию, и OnPush влияет только на запуск change detection, но не на вызов хука ngOnChanges при изменении @Input.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "ViewContainerRef.createComponent создаёт компоненты внутри дерева change detection, а не вне его. Компонент автоматически присоединяется к дереву. Проблема не в отслеживании компонента, а в том, что прямое присваивание свойств не триггерит механизм ngOnChanges.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какой хук жизненного цикла необходимо использовать для корректного уничтожения динамически созданных через ViewContainerRef компонентов при удалении родительского компонента?",
              "correct_answer": "ngOnDestroy — но Angular автоматически очищает ViewContainerRef. Ручной вызов destroy()/clear() нужен только для компонентов, созданных вне шаблона или с особой логикой.",
              "var_1": "ngOnDestroy — но Angular автоматически очищает ViewContainerRef. Ручной вызов destroy()/clear() нужен только для компонентов, созданных вне шаблона или с особой логикой.",
              "var_2": "ngOnChanges — при изменении входных данных нужно проверять и очищать ViewContainerRef через clear(), поскольку Angular не отслеживает зависимости динамически созданных компонентов от родителя.",
              "var_3": "ngAfterViewInit — необходимо вручную отслеживать все созданные ComponentRef и вызывать destroy() в этом хуке, так как Angular не управляет жизненным циклом динамических компонентов автоматически.",
              "var_4": "ngDoCheck — требуется реализовать ручную проверку и вызов destroy() для каждого ComponentRef, так как ViewContainerRef не связан с механизмом автоматической очистки Angular.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "ngOnDestroy — правильный хук для очистки ресурсов. Angular автоматически уничтожает компоненты в ViewContainerRef при уничтожении родителя, ручной вызов нужен только для особых случаев.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "ngOnChanges срабатывает при изменении @Input(), но не является хуком для очистки ресурсов при уничтожении компонента. Очистка ViewContainerRef должна происходить в ngOnDestroy.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "ngAfterViewInit — хук инициализации view, а не уничтожения. Он срабатывает после создания представления, а не при удалении компонента. Angular автоматически очищает ViewContainerRef.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "ngDoCheck срабатывает на каждом цикле обнаружения изменений, что неэффективно и неправильно для очистки ресурсов. ViewContainerRef автоматически управляется Angular при уничтожении.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Tree-shaking оптимизация - анализ и рефакторинг providedIn конфигураций для минимизации bundle size",
          "competency": "Архитектура Angular (DI, standalone)",
          "questions": [
            {
              "question": "Почему providedIn: 'root' обеспечивает лучший tree-shaking по сравнению с регистрацией сервиса в массиве providers модуля?",
              "correct_answer": "Angular анализирует импорты: неиспользуемый сервис с providedIn удаляется, а providers модуля включаются всегда целиком.",
              "var_1": "При использовании providedIn сервис компилируется отдельным чанком, а providers модуля объединяются в общий бандл без возможности разделения.",
              "var_2": "providedIn: 'root' регистрирует сервис лениво при первом обращении, тогда как providers модуля инициализируют все сервисы при загрузке.",
              "var_3": "Angular анализирует импорты: неиспользуемый сервис с providedIn удаляется, а providers модуля включаются всегда целиком.",
              "var_4": "providedIn: 'root' создаёт singleton на уровне платформы, что позволяет Webpack анализировать зависимости более эффективно через метаданные.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Сервисы с providedIn не компилируются отдельными чанками автоматически. Tree-shaking работает за счет устранения неиспользуемого кода, а не разделения на чанки.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Ленивая инициализация не является причиной лучшего tree-shaking. Оба подхода создают сервисы при первом обращении. Tree-shaking происходит на этапе сборки, а не рантайма.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение. Компилятор Angular может удалить неиспользуемый сервис с providedIn, так как он регистрируется декларативно. Providers модуля являются частью модуля и включаются вместе с ним.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "providedIn: 'root' не связан с анализом Webpack через метаданные. Tree-shaking работает на уровне компилятора Angular, а singleton создается на уровне инжектора, не платформы.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую стратегию providedIn следует применить для сервиса аналитики, используемого только в lazy-loaded AdminModule, чтобы он не попал в основной бандл?",
              "correct_answer": "Убрать providedIn и добавить сервис в providers массив AdminModule — это гарантирует tree-shaking и загрузку только с lazy-модулем.",
              "var_1": "Убрать providedIn и добавить сервис в providers массив AdminModule — это гарантирует tree-shaking и загрузку только с lazy-модулем.",
              "var_2": "Использовать providedIn: 'any' — это гарантирует изоляцию сервиса в lazy-loaded модуле.",
              "var_3": "Указать providedIn: AdminModule — это создаст отдельный чанк и загрузит сервис только при навигации к админке.",
              "var_4": "Использовать providedIn: 'root' с условием isAdmin — Angular автоматически выполнит tree-shaking и удалит сервис из бандла неиспользуемых модулей.",
              "correct_position": 1,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": true,
                "reason": "Удаление providedIn и добавление сервиса в providers массив lazy-loaded модуля гарантирует, что сервис будет загружен только с этим модулем и не попадёт в основной бандл. Это классический и надёжный подход для изоляции зависимостей.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "providedIn: 'any' создаёт отдельный экземпляр сервиса для каждого lazy-loaded модуля, но не гарантирует tree-shaking и не предотвращает попадание кода в основной бандл, если на сервис есть ссылки из eager-loaded компонентов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "providedIn: AdminModule — синтаксически некорректен. Angular не поддерживает прямую ссылку на модуль в providedIn (можно использовать только 'root', 'platform', 'any' или forwardRef). Это вызовет ошибку компиляции.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "providedIn: 'root' регистрирует сервис глобально в root injector, поэтому он попадёт в основной бандл независимо от условий внутри сервиса. Tree-shaking не работает на уровне условной логики внутри сервиса.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Module Federation - конфигурация динамической загрузки микрофронтендов и shared dependencies",
          "competency": "Angular CLI/сборка/конфиги",
          "questions": [
            {
              "question": "Почему при использовании singleton: true для shared зависимостей в Module Federation может возникнуть runtime ошибка несовместимости версий?",
              "correct_answer": "Webpack загружает только одну версию библиотеки, и если requiredVersion хоста и remote несовместимы, strictVersion выбрасывает ошибку вместо тихой загрузки неподходящей версии.",
              "var_1": "Ошибка возникает потому что singleton: true отключает lazy loading для shared зависимостей, и при асинхронной загрузке микрофронтендов происходит race condition между версиями библиотек.",
              "var_2": "Webpack загружает только одну версию библиотеки, и если requiredVersion хоста и remote несовместимы, strictVersion выбрасывает ошибку вместо тихой загрузки неподходящей версии.",
              "var_3": "При singleton: true Webpack принудительно кэширует библиотеку в глобальном скоупе, и если remote загружается раньше хоста, то кэш перезаписывается, вызывая конфликт из-за неправильного порядка инициализации модулей.",
              "var_4": "Singleton режим создаёт единственный инстанс библиотеки, и если версии отличаются, Angular DI не может разрешить зависимости между модулями.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Singleton: true не отключает lazy loading для shared зависимостей. Race condition между версиями также не является причиной ошибки - singleton как раз предотвращает загрузку нескольких версий.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение: singleton: true заставляет Webpack использовать только одну версию библиотеки, и при несовместимости requiredVersion между хостом и remote, strictVersion (по умолчанию true для singleton) выбрасывает runtime ошибку.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Webpack не перезаписывает кэш при загрузке remote раньше хоста. Singleton гарантирует использование одной версии, но проблема не в порядке инициализации или перезаписи кэша, а в несовместимости версий.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "Angular DI способен разрешать зависимости между модулями даже при разных версиях библиотек. Проблема не в механизме DI, а в том, что Module Federation с singleton принудительно использует только одну версию.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Как настроить shared dependency в Module Federation, чтобы избежать дублирования Angular-библиотеки между host и remote приложениями при разных minor-версиях?",
              "correct_answer": "Использовать singleton: true, strictVersion: false и указать requiredVersion с диапазоном версий (например, '^14.0.0') в shared конфигурации.",
              "var_1": "Использовать shareAll() без дополнительных параметров, полагаясь на автоматическое разрешение версий webpack.",
              "var_2": "Указать eager: true для всех Angular-библиотек и установить requiredVersion: 'latest', чтобы автоматически синхронизировать версии между host и remote при каждой загрузке.",
              "var_3": "Использовать singleton: true, strictVersion: false и указать requiredVersion с диапазоном версий (например, '^14.0.0') в shared конфигурации.",
              "var_4": "Настроить strictVersion: true и singleton: true без указания requiredVersion, чтобы Module Federation самостоятельно определял совместимость версий в runtime.",
              "correct_position": 3,
              "fixes_applied": 0,
              "question_was_fixed": true,
              "var_1_info": {
                "is_correct": false,
                "reason": "shareAll() шарит все зависимости из package.json без оптимизации. При разных minor-версиях Angular может загрузить обе версии, что приведёт к дублированию и конфликтам.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "eager: true загружает библиотеку сразу, блокируя асинхронность Module Federation. requiredVersion: 'latest' не является валидным semver и не синхронизирует версии автоматически.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": true,
                "reason": "singleton: true гарантирует одну инстанцию библиотеки. strictVersion: false позволяет использовать разные minor-версии. requiredVersion с диапазоном ('^14.0.0') определяет совместимые версии согласно semver.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "strictVersion: true без requiredVersion приведёт к ошибкам при несовпадении версий. Module Federation не определяет совместимость автоматически без указания диапазона версий.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Bundle optimization - проектирование code-splitting архитектуры с lazy loading и preloading стратегиями",
          "competency": "Производительность (CD, trackBy, bundle анализ)",
          "questions": [
            {
              "question": "Почему preloading стратегия PreloadAllModules может негативно влиять на производительность мобильных устройств с ограниченным трафиком?",
              "correct_answer": "Она загружает все lazy-модули сразу после инициализации приложения, расходуя мобильный трафик на возможно ненужные пользователю функции.",
              "var_1": "PreloadAllModules вызывает множественные синхронные HTTP-запросы, которые блокируют основной поток рендеринга и создают задержки в интерфейсе на слабых процессорах.",
              "var_2": "Она загружает все lazy-модули сразу после инициализации приложения, расходуя мобильный трафик на возможно ненужные пользователю функции.",
              "var_3": "PreloadAllModules кэширует все модули в localStorage мобильного устройства, что приводит к исчерпанию доступной памяти браузера и вызывает краши приложения.",
              "var_4": "Она увеличивает время первичной загрузки приложения, блокируя отображение первого экрана до полной загрузки всех модулей.",
              "correct_position": 2,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "PreloadAllModules загружает модули асинхронно в фоне после инициализации, не блокирует основной поток и не создает синхронных запросов, блокирующих рендеринг.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": true,
                "reason": "Это правильный ответ. PreloadAllModules автоматически загружает все lazy-модули после инициализации, расходуя трафик пользователя на модули, которые могут никогда не понадобиться, что критично для мобильных устройств с ограниченным или платным трафиком.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "PreloadAllModules не использует localStorage для кэширования - модули кэшируются стандартным HTTP-кэшем браузера. Это не вызывает крашей из-за исчерпания памяти localStorage.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": false,
                "reason": "PreloadAllModules не блокирует первичную загрузку - она начинает загружать lazy-модули только ПОСЛЕ инициализации приложения и отображения первого экрана, работая в фоне.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую preloading стратегию вы бы реализовали для приложения, где 80% пользователей после логина переходят на dashboard, но модуль dashboard весит 500KB?",
              "correct_answer": "Кастомную PreloadingStrategy с предзагрузкой dashboard после idle состояния браузера через requestIdleCallback, либо предзагрузку по data-атрибуту preload:true в роуте с приоритетом для критичных модулей.",
              "var_1": "Использовать NoPreloading стратегию и загружать dashboard модуль через динамический import() непосредственно в компоненте логина после успешной авторизации, что гарантирует загрузку только нужного модуля без лишних сетевых запросов.",
              "var_2": "PreloadAllModules стратегия из @angular/router, которая автоматически загрузит dashboard сразу после инициализации приложения, что оптимально для часто используемых модулей - Angular сам определит приоритет загрузки основываясь на размере бандла.",
              "var_3": "Разбить dashboard на микро-модули по 50KB каждый с помощью webpack splitChunks и использовать QuicklinkStrategy для предзагрузки видимых ссылок, так Angular оптимизирует загрузку автоматически на основе viewport.",
              "var_4": "Кастомную PreloadingStrategy с предзагрузкой dashboard после idle состояния браузера через requestIdleCallback, либо предзагрузку по data-атрибуту preload:true в роуте с приоритетом для критичных модулей.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "NoPreloading с динамическим import() в компоненте логина технически работает, но это не оптимально - пользователь будет ждать загрузки 500KB после авторизации. Лучше предзагрузить модуль заранее в idle-время.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "PreloadAllModules загружает ВСЕ lazy модули, а не только dashboard. Это расточительно и может замедлить начальную загрузку. Angular НЕ определяет приоритет автоматически на основе размера - это заблуждение. Нужна селективная стратегия.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "QuicklinkStrategy предзагружает ссылки, видимые в viewport, но это не решает проблему 500KB dashboard модуля, который нужен 80% пользователей сразу после логина. Splitchunks полезен, но стратегия не оптимальна для данного сценария.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Кастомная PreloadingStrategy с requestIdleCallback оптимальна - предзагружает dashboard после авторизации в idle-время, не блокируя UI. Data-атрибут preload позволяет гибко управлять приоритетами. Идеальное решение для тяжелого часто-используемого модуля.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        },
        {
          "theme": "Code review производительности приложения - анализ Change Detection стратегий и выявление bottlenecks через профилирование",
          "competency": "Навыки проведения рефакторинга и code review",
          "questions": [
            {
              "question": "Почему использование OnPush стратегии без учёта мутабельности объектов приводит к неожиданным проблемам при отображении данных?",
              "correct_answer": "OnPush проверяет изменения по ссылке, а мутация объекта сохраняет ссылку, поэтому Angular не обнаруживает изменение и не обновляет представление.",
              "var_1": "OnPush требует использования исключительно примитивных типов данных, поэтому передача объектов любого вида автоматически отключает механизм отслеживания изменений.",
              "var_2": "Мутация объектов при OnPush вызывает утечки памяти, так как Angular создаёт дополнительные подписки на каждое изменение свойств.",
              "var_3": "OnPush автоматически отслеживает все изменения внутри объектов через deep comparison, но мутабельность вызывает конфликты с внутренним кэшем компонента и блокирует рендеринг.",
              "var_4": "OnPush проверяет изменения по ссылке, а мутация объекта сохраняет ссылку, поэтому Angular не обнаруживает изменение и не обновляет представление.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "OnPush не требует использования исключительно примитивных типов. Он работает с любыми типами данных, включая объекты и массивы. Механизм отслеживания изменений не отключается при передаче объектов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Мутация объектов при OnPush не вызывает утечки памяти. Angular не создаёт дополнительные подписки на изменения свойств объектов — это не является механизмом работы Change Detection.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "OnPush НЕ использует deep comparison — это было бы крайне затратно по производительности. Он использует именно shallow comparison (сравнение по ссылке). Нет никакого внутреннего кэша компонента, который блокирует рендеринг.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это корректное объяснение. OnPush использует shallow comparison (проверку по ссылке). При мутации объекта ссылка остаётся прежней, поэтому Angular не детектирует изменение и не запускает Change Detection.",
                "was_replaced": false,
                "original_before_fix": null
              }
            },
            {
              "question": "Какую стратегию Change Detection и дополнительные оптимизации вы примените при code review компонента, отображающего список из 10000 элементов с частым обновлением данных?",
              "correct_answer": "OnPush стратегию с trackBy в ngFor, виртуальный скроллинг через CDK Virtual Scroll, иммутабельные данные и детач компонентов вне viewport для минимизации проверок.",
              "var_1": "OnPush стратегию без trackBy, так как Angular автоматически оптимизирует ngFor для больших списков, дополнительно включить enableProdMode.",
              "var_2": "OnPush с trackBy и ручным вызовом markForCheck() для каждого обновлённого элемента, пагинация вместо виртуализации для простоты реализации.",
              "var_3": "Default стратегию с setTimeout для разбивки обновлений на чанки, кэширование DOM-элементов и ручной вызов detectChanges() после операций.",
              "var_4": "OnPush стратегию с trackBy в ngFor, виртуальный скроллинг через CDK Virtual Scroll, иммутабельные данные и детач компонентов вне viewport для минимизации проверок.",
              "correct_position": 4,
              "fixes_applied": 0,
              "question_was_fixed": false,
              "var_1_info": {
                "is_correct": false,
                "reason": "Angular НЕ оптимизирует ngFor автоматически для больших списков без trackBy - это популярное заблуждение. Без trackBy Angular пересоздаёт все DOM-элементы при обновлении массива. enableProdMode не решает проблему производительности рендеринга 10000 элементов.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_2_info": {
                "is_correct": false,
                "reason": "Вызов markForCheck() для каждого из 10000 элементов создаст огромный overhead. Пагинация вместо виртуализации означает, что в DOM все равно будут 10000 элементов (просто скрытых), что не решает проблему производительности рендеринга.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_3_info": {
                "is_correct": false,
                "reason": "Default стратегия проверяет все компоненты при каждом change detection cycle, что катастрофически неэффективно для 10000 элементов. setTimeout и ручной detectChanges() - это костыли, не решающие корневую проблему производительности.",
                "was_replaced": false,
                "original_before_fix": null
              },
              "var_4_info": {
                "is_correct": true,
                "reason": "Это оптимальное решение для senior-уровня: OnPush минимизирует проверки, trackBy предотвращает пересоздание DOM, CDK Virtual Scroll рендерит только видимые элементы, иммутабельность обеспечивает корректную работу OnPush, детач компонентов дополнительно снижает нагрузку.",
                "was_replaced": false,
                "original_before_fix": null
              }
            }
          ]
        }
      ]
    }
  }
}