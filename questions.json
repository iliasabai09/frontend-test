{
  "profile": "Frontend Developer (Angular)",
  "levels": {
    "junior": {
      "themes": [
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "HTML5 семантические теги - использование header, nav, main, section, article для структуры страницы по макету",
          "questions": [
            {
              "question": "[HTML5 семантические теги] Какое утверждение наиболее корректно?",
              "var_1": "HTML5 семантические теги: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "HTML5 семантические теги всегда ускоряет приложение независимо от контекста и реализации.",
              "var_3": "HTML5 семантические теги работает только в IE11 и устарело.",
              "var_4": "HTML5 семантические теги относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 1,
              "correct_answer": "HTML5 семантические теги: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[HTML5 семантические теги] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: HTML5 семантические теги - использование header, nav, main, section, article для структуры страницы по макету",
              "var_1": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_2": "Использовать HTML5 семантические теги по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 2,
              "correct_answer": "Использовать HTML5 семантические теги по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "CSS Flexbox - выравнивание элементов формы и создание адаптивных раскладок компонентов",
          "questions": [
            {
              "question": "[CSS Flexbox] Какое утверждение наиболее корректно?",
              "var_1": "CSS Flexbox всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "CSS Flexbox работает только в IE11 и устарело.",
              "var_3": "CSS Flexbox: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "CSS Flexbox заменяет необходимость тестирования и code review.",
              "correct_position": 3,
              "correct_answer": "CSS Flexbox: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[CSS Flexbox] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: CSS Flexbox - выравнивание элементов формы и создание адаптивных раскладок компонентов",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Использовать CSS Flexbox по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 3,
              "correct_answer": "Использовать CSS Flexbox по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "Tailwind утилитарные классы - применение spacing, typography и color для верстки по дизайн-системе",
          "questions": [
            {
              "question": "[Tailwind утилитарные классы] Какое утверждение наиболее корректно?",
              "var_1": "Tailwind утилитарные классы: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Tailwind утилитарные классы используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Tailwind утилитарные классы относится только к стилям CSS и не применяется в логике приложения.",
              "var_4": "Tailwind утилитарные классы работает только в IE11 и устарело.",
              "correct_position": 1,
              "correct_answer": "Tailwind утилитарные классы: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Tailwind утилитарные классы] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Tailwind утилитарные классы - применение spacing, typography и color для верстки по дизайн-системе",
              "var_1": "Использовать Tailwind утилитарные классы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 1,
              "correct_answer": "Использовать Tailwind утилитарные классы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "HTML5 формы - разметка input полей с типами email, password, checkbox и атрибутами валидации",
          "questions": [
            {
              "question": "[HTML5 формы] Какое утверждение наиболее корректно?",
              "var_1": "HTML5 формы гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_2": "HTML5 формы запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "HTML5 формы заменяет необходимость тестирования и code review.",
              "var_4": "HTML5 формы: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "HTML5 формы: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[HTML5 формы] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: HTML5 формы - разметка input полей с типами email, password, checkbox и атрибутами валидации",
              "var_1": "Использовать HTML5 формы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 1,
              "correct_answer": "Использовать HTML5 формы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету",
          "questions": [
            {
              "question": "[CSS Grid] Какое утверждение наиболее корректно?",
              "var_1": "CSS Grid работает только в IE11 и устарело.",
              "var_2": "CSS Grid используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "CSS Grid запрещено использовать вместе с TypeScript strict mode.",
              "var_4": "CSS Grid: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "CSS Grid: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[CSS Grid] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Использовать CSS Grid по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "correct_position": 3,
              "correct_answer": "Использовать CSS Grid по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "Tailwind responsive модификаторы - адаптация верстки под mobile, tablet и desktop breakpoints",
          "questions": [
            {
              "question": "[Tailwind responsive модификаторы] Какое утверждение наиболее корректно?",
              "var_1": "Tailwind responsive модификаторы работает только в IE11 и устарело.",
              "var_2": "Tailwind responsive модификаторы заменяет необходимость тестирования и code review.",
              "var_3": "Tailwind responsive модификаторы всегда ускоряет приложение независимо от контекста и реализации.",
              "var_4": "Tailwind responsive модификаторы: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Tailwind responsive модификаторы: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Tailwind responsive модификаторы] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Tailwind responsive модификаторы - адаптация верстки под mobile, tablet и desktop breakpoints",
              "var_1": "Использовать Tailwind responsive модификаторы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 1,
              "correct_answer": "Использовать Tailwind responsive модификаторы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "CSS позиционирование - размещение модальных окон, всплывающих подсказок и оверлеев",
          "questions": [
            {
              "question": "[CSS позиционирование] Какое утверждение наиболее корректно?",
              "var_1": "CSS позиционирование всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "CSS позиционирование относится только к стилям CSS и не применяется в логике приложения.",
              "var_3": "CSS позиционирование работает только в IE11 и устарело.",
              "var_4": "CSS позиционирование: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "CSS позиционирование: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[CSS позиционирование] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: CSS позиционирование - размещение модальных окон, всплывающих подсказок и оверлеев",
              "var_1": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Использовать CSS позиционирование по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать CSS позиционирование по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Типы данных JavaScript - работа с примитивами и объектами при обработке данных из API",
          "questions": [
            {
              "question": "[Типы данных JavaScript] Какое утверждение наиболее корректно?",
              "var_1": "Типы данных JavaScript всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "Типы данных JavaScript запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "Типы данных JavaScript: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Типы данных JavaScript используется только для серверного рендеринга и не влияет на клиентский код.",
              "correct_position": 3,
              "correct_answer": "Типы данных JavaScript: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Типы данных JavaScript] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Типы данных JavaScript - работа с примитивами и объектами при обработке данных из API",
              "var_1": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_2": "Использовать Типы данных JavaScript по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 2,
              "correct_answer": "Использовать Типы данных JavaScript по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Массивы - методы перебора и трансформации для отображения списков в компонентах",
          "questions": [
            {
              "question": "[Массивы] Какое утверждение наиболее корректно?",
              "var_1": "Массивы всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "Массивы: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Массивы заменяет необходимость тестирования и code review.",
              "var_4": "Массивы используется только для серверного рендеринга и не влияет на клиентский код.",
              "correct_position": 2,
              "correct_answer": "Массивы: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Массивы] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Массивы - методы перебора и трансформации для отображения списков в компонентах",
              "var_1": "Использовать Массивы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 1,
              "correct_answer": "Использовать Массивы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Объекты - деструктуризация и spread оператор для работы с данными форм",
          "questions": [
            {
              "question": "[Объекты] Какое утверждение наиболее корректно?",
              "var_1": "Объекты всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "Объекты: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Объекты относится только к стилям CSS и не применяется в логике приложения.",
              "var_4": "Объекты гарантирует автоматическое исправление ошибок без участия разработчика.",
              "correct_position": 2,
              "correct_answer": "Объекты: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Объекты] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Объекты - деструктуризация и spread оператор для работы с данными форм",
              "var_1": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Использовать Объекты по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Объекты по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Функции - стрелочные функции и колбэки для обработки событий в шаблонах",
          "questions": [
            {
              "question": "[Функции] Какое утверждение наиболее корректно?",
              "var_1": "Функции запрещено использовать вместе с TypeScript strict mode.",
              "var_2": "Функции всегда ускоряет приложение независимо от контекста и реализации.",
              "var_3": "Функции: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Функции относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 3,
              "correct_answer": "Функции: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Функции] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Функции - стрелочные функции и колбэки для обработки событий в шаблонах",
              "var_1": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_2": "Использовать Функции по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 2,
              "correct_answer": "Использовать Функции по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Условные операторы - реализация условного отображения элементов UI",
          "questions": [
            {
              "question": "[Условные операторы] Какое утверждение наиболее корректно?",
              "var_1": "Условные операторы гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_2": "Условные операторы запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "Условные операторы заменяет необходимость тестирования и code review.",
              "var_4": "Условные операторы: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Условные операторы: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Условные операторы] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Условные операторы - реализация условного отображения элементов UI",
              "var_1": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Использовать Условные операторы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Условные операторы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Строки - методы обработки и форматирования текстовых данных для вывода",
          "questions": [
            {
              "question": "[Строки] Какое утверждение наиболее корректно?",
              "var_1": "Строки используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_2": "Строки всегда ускоряет приложение независимо от контекста и реализации.",
              "var_3": "Строки: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Строки относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 3,
              "correct_answer": "Строки: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Строки] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Строки - методы обработки и форматирования текстовых данных для вывода",
              "var_1": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Использовать Строки по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Строки по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Операторы сравнения и логические операторы - валидация данных форм на клиенте",
          "questions": [
            {
              "question": "[Операторы сравнения и логические операторы] Какое утверждение наиболее корректно?",
              "var_1": "Операторы сравнения и логические операторы относится только к стилям CSS и не применяется в логике приложения.",
              "var_2": "Операторы сравнения и логические операторы используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Операторы сравнения и логические операторы: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Операторы сравнения и логические операторы заменяет необходимость тестирования и code review.",
              "correct_position": 3,
              "correct_answer": "Операторы сравнения и логические операторы: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Операторы сравнения и логические операторы] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Операторы сравнения и логические операторы - валидация данных форм на клиенте",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Использовать Операторы сравнения и логические операторы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 2,
              "correct_answer": "Использовать Операторы сравнения и логические операторы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Типизация данных - объявление интерфейсов для моделей данных API",
          "questions": [
            {
              "question": "[Типизация данных] Какое утверждение наиболее корректно?",
              "var_1": "Типизация данных: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Типизация данных используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Типизация данных работает только в IE11 и устарело.",
              "var_4": "Типизация данных заменяет необходимость тестирования и code review.",
              "correct_position": 1,
              "correct_answer": "Типизация данных: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Типизация данных] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Типизация данных - объявление интерфейсов для моделей данных API",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Использовать Типизация данных по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 3,
              "correct_answer": "Использовать Типизация данных по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Типизация функций - аннотации параметров и возвращаемых значений в методах компонентов",
          "questions": [
            {
              "question": "[Типизация функций] Какое утверждение наиболее корректно?",
              "var_1": "Типизация функций заменяет необходимость тестирования и code review.",
              "var_2": "Типизация функций запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "Типизация функций: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Типизация функций всегда ускоряет приложение независимо от контекста и реализации.",
              "correct_position": 3,
              "correct_answer": "Типизация функций: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Типизация функций] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Типизация функций - аннотации параметров и возвращаемых значений в методах компонентов",
              "var_1": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_2": "Использовать Типизация функций по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "correct_position": 2,
              "correct_answer": "Использовать Типизация функций по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Дженерики - использование типизированных HttpClient запросов с Observable<T>",
          "questions": [
            {
              "question": "[Дженерики] Выбери наиболее корректное утверждение.\n\nТема: Дженерики - использование типизированных HttpClient запросов с Observable<T>",
              "var_1": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_2": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_3": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_4": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "correct_position": 4,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Дженерики] Практика: выбери лучший вариант действия.\n\nТема: Дженерики - использование типизированных HttpClient запросов с Observable<T>",
              "var_1": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_2": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_3": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_4": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "correct_position": 2,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Enum - создание перечислений для статусов, ролей и константных значений в формах",
          "questions": [
            {
              "question": "[Enum] Какое утверждение наиболее корректно?",
              "var_1": "Enum: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Enum относится только к стилям CSS и не применяется в логике приложения.",
              "var_3": "Enum используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_4": "Enum гарантирует автоматическое исправление ошибок без участия разработчика.",
              "correct_position": 1,
              "correct_answer": "Enum: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Enum] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Enum - создание перечислений для статусов, ролей и константных значений в формах",
              "var_1": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_2": "Использовать Enum по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 2,
              "correct_answer": "Использовать Enum по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Union и Literal типы - типизация состояний компонента и параметров конфигурации",
          "questions": [
            {
              "question": "[Union и Literal типы] Какое утверждение наиболее корректно?",
              "var_1": "Union и Literal типы работает только в IE11 и устарело.",
              "var_2": "Union и Literal типы заменяет необходимость тестирования и code review.",
              "var_3": "Union и Literal типы: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Union и Literal типы относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 3,
              "correct_answer": "Union и Literal типы: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Union и Literal типы] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Union и Literal типы - типизация состояний компонента и параметров конфигурации",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Использовать Union и Literal типы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "correct_position": 3,
              "correct_answer": "Использовать Union и Literal типы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Type Guards - проверка типов данных при обработке ответов API разных форматов",
          "questions": [
            {
              "question": "[Type Guards] Выбери наиболее корректное утверждение.\n\nТема: Type Guards - проверка типов данных при обработке ответов API разных форматов",
              "var_1": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_2": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_3": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "var_4": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "correct_position": 2,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Type Guards] Практика: выбери лучший вариант действия.\n\nТема: Type Guards - проверка типов данных при обработке ответов API разных форматов",
              "var_1": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_2": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_3": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_4": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "correct_position": 1,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Utility Types - применение Partial, Pick, Omit для работы с формами и DTO объектами",
          "questions": [
            {
              "question": "[Utility Types] Какое утверждение наиболее корректно?",
              "var_1": "Utility Types заменяет необходимость тестирования и code review.",
              "var_2": "Utility Types запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "Utility Types: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Utility Types относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 3,
              "correct_answer": "Utility Types: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Utility Types] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Utility Types - применение Partial, Pick, Omit для работы с формами и DTO объектами",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Использовать Utility Types по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 2,
              "correct_answer": "Использовать Utility Types по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "Типы данных и переменные - работа с примитивами и объектами при обработке данных из API",
          "questions": [
            {
              "question": "[Типы данных и переменные] Какое утверждение наиболее корректно?",
              "var_1": "Типы данных и переменные: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Типы данных и переменные используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Типы данных и переменные относится только к стилям CSS и не применяется в логике приложения.",
              "var_4": "Типы данных и переменные гарантирует автоматическое исправление ошибок без участия разработчика.",
              "correct_position": 1,
              "correct_answer": "Типы данных и переменные: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Типы данных и переменные] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Типы данных и переменные - работа с примитивами и объектами при обработке данных из API",
              "var_1": "Использовать Типы данных и переменные по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "correct_position": 1,
              "correct_answer": "Использовать Типы данных и переменные по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "Классы и объекты - создание TypeScript-классов для моделей данных компонентов",
          "questions": [
            {
              "question": "[Классы и объекты] Какое утверждение наиболее корректно?",
              "var_1": "Классы и объекты гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_2": "Классы и объекты запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "Классы и объекты используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_4": "Классы и объекты: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Классы и объекты: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Классы и объекты] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Классы и объекты - создание TypeScript-классов для моделей данных компонентов",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Использовать Классы и объекты по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 3,
              "correct_answer": "Использовать Классы и объекты по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "Инкапсуляция - использование модификаторов доступа в Angular-сервисах и компонентах",
          "questions": [
            {
              "question": "[Инкапсуляция] Какое утверждение наиболее корректно?",
              "var_1": "Инкапсуляция: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Инкапсуляция гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_3": "Инкапсуляция всегда ускоряет приложение независимо от контекста и реализации.",
              "var_4": "Инкапсуляция относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 1,
              "correct_answer": "Инкапсуляция: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Инкапсуляция] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Инкапсуляция - использование модификаторов доступа в Angular-сервисах и компонентах",
              "var_1": "Использовать Инкапсуляция по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 1,
              "correct_answer": "Использовать Инкапсуляция по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "Наследование классов - переиспользование логики через extends для базовых компонентов",
          "questions": [
            {
              "question": "[Наследование классов] Какое утверждение наиболее корректно?",
              "var_1": "Наследование классов всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "Наследование классов: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Наследование классов запрещено использовать вместе с TypeScript strict mode.",
              "var_4": "Наследование классов используется только для серверного рендеринга и не влияет на клиентский код.",
              "correct_position": 2,
              "correct_answer": "Наследование классов: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Наследование классов] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Наследование классов - переиспользование логики через extends для базовых компонентов",
              "var_1": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Использовать Наследование классов по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Наследование классов по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание Git",
          "theme": "Работа с ветками - создание feature-ветки для разработки нового Angular компонента",
          "questions": [
            {
              "question": "[Работа с ветками] Выбери наиболее корректное утверждение.\n\nТема: Работа с ветками - создание feature-ветки для разработки нового Angular компонента",
              "var_1": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_2": "rebase безопаснее merge, потому что никогда не переписывает историю.",
              "var_3": "reflog показывает только ветки на удаленном репозитории.",
              "var_4": "bisect нужен только для конфликтов слияния, а не для поиска регрессий.",
              "correct_position": 1,
              "correct_answer": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Работа с ветками] Практика: выбери лучший вариант действия.\n\nТема: Работа с ветками - создание feature-ветки для разработки нового Angular компонента",
              "var_1": "Всегда делай force-push в main после rebase — так история будет красивее.",
              "var_2": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_3": "Чтобы решить конфликт, просто удали конфликтные файлы.",
              "var_4": "Если потерял коммит, единственный путь — заново написать код.",
              "correct_position": 2,
              "correct_answer": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание Git",
          "theme": "Фиксация изменений - составление понятных commit-сообщений при изменении TypeScript кода",
          "questions": [
            {
              "question": "[Фиксация изменений] Выбери наиболее корректное утверждение.\n\nТема: Фиксация изменений - составление понятных commit-сообщений при изменении TypeScript кода",
              "var_1": "reflog показывает только ветки на удаленном репозитории.",
              "var_2": "rebase безопаснее merge, потому что никогда не переписывает историю.",
              "var_3": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_4": "bisect нужен только для конфликтов слияния, а не для поиска регрессий.",
              "correct_position": 3,
              "correct_answer": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Фиксация изменений] Практика: выбери лучший вариант действия.\n\nТема: Фиксация изменений - составление понятных commit-сообщений при изменении TypeScript кода",
              "var_1": "Чтобы решить конфликт, просто удали конфликтные файлы.",
              "var_2": "Если потерял коммит, единственный путь — заново написать код.",
              "var_3": "Всегда делай force-push в main после rebase — так история будет красивее.",
              "var_4": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "correct_position": 4,
              "correct_answer": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Знание Git",
          "theme": "Синхронизация с удаленным репозиторием - использование pull для получения обновлений перед началом работы",
          "questions": [
            {
              "question": "[Синхронизация с удаленным репозиторием] Выбери наиболее корректное утверждение.\n\nТема: Синхронизация с удаленным репозиторием - использование pull для получения обновлений перед началом работы",
              "var_1": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_2": "rebase безопаснее merge, потому что никогда не переписывает историю.",
              "var_3": "reflog показывает только ветки на удаленном репозитории.",
              "var_4": "bisect нужен только для конфликтов слияния, а не для поиска регрессий.",
              "correct_position": 1,
              "correct_answer": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Синхронизация с удаленным репозиторием] Практика: выбери лучший вариант действия.\n\nТема: Синхронизация с удаленным репозиторием - использование pull для получения обновлений перед началом работы",
              "var_1": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_2": "Всегда делай force-push в main после rebase — так история будет красивее.",
              "var_3": "Если потерял коммит, единственный путь — заново написать код.",
              "var_4": "Чтобы решить конфликт, просто удали конфликтные файлы.",
              "correct_position": 1,
              "correct_answer": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Формы (Template/Reactive, валидаторы)",
          "theme": "Reactive Forms - создание и конфигурация форм через FormBuilder и FormGroup",
          "questions": [
            {
              "question": "[Reactive Forms] Выбери наиболее корректное утверждение.\n\nТема: Reactive Forms - создание и конфигурация форм через FormBuilder и FormGroup",
              "var_1": "Reactive Forms не поддерживают асинхронную валидацию.",
              "var_2": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_3": "Template-driven формы быстрее и безопаснее Reactive, поэтому их всегда выбирают в enterprise.",
              "var_4": "FormArray нельзя использовать внутри FormGroup.",
              "correct_position": 2,
              "correct_answer": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Reactive Forms] Практика: выбери лучший вариант действия.\n\nТема: Reactive Forms - создание и конфигурация форм через FormBuilder и FormGroup",
              "var_1": "Проверяй уникальность email только на submit, без async validator.",
              "var_2": "Создай отдельный FormGroup на каждый input, чтобы было «модульно».",
              "var_3": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_4": "Для совпадения паролей сравнивай значения прямо в шаблоне через (input) и не трогай валидаторы.",
              "correct_position": 3,
              "correct_answer": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Формы (Template/Reactive, валидаторы)",
          "theme": "Template-driven Forms - работа с NgModel и директивами для двусторонней привязки данных",
          "questions": [
            {
              "question": "[Template] Выбери наиболее корректное утверждение.\n\nТема: Template-driven Forms - работа с NgModel и директивами для двусторонней привязки данных",
              "var_1": "Template-driven формы быстрее и безопаснее Reactive, поэтому их всегда выбирают в enterprise.",
              "var_2": "FormArray нельзя использовать внутри FormGroup.",
              "var_3": "Reactive Forms не поддерживают асинхронную валидацию.",
              "var_4": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "correct_position": 4,
              "correct_answer": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Template] Практика: выбери лучший вариант действия.\n\nТема: Template-driven Forms - работа с NgModel и директивами для двусторонней привязки данных",
              "var_1": "Проверяй уникальность email только на submit, без async validator.",
              "var_2": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_3": "Создай отдельный FormGroup на каждый input, чтобы было «модульно».",
              "var_4": "Для совпадения паролей сравнивай значения прямо в шаблоне через (input) и не трогай валидаторы.",
              "correct_position": 2,
              "correct_answer": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
          "theme": "XSS-защита в шаблонах - безопасный вывод пользовательских данных через interpolation и property binding",
          "questions": [
            {
              "question": "[XSS] Выбери наиболее корректное утверждение.\n\nТема: XSS-защита в шаблонах - безопасный вывод пользовательских данных через interpolation и property binding",
              "var_1": "CSP полностью заменяет санитизацию, поэтому DomSanitizer больше не нужен.",
              "var_2": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_3": "Angular не имеет защиты от XSS, поэтому нужно всегда использовать innerHTML и ручную фильтрацию.",
              "var_4": "Хранить токен в URL безопаснее, потому что его легко дебажить.",
              "correct_position": 2,
              "correct_answer": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[XSS] Практика: выбери лучший вариант действия.\n\nТема: XSS-защита в шаблонах - безопасный вывод пользовательских данных через interpolation и property binding",
              "var_1": "Передавай токен в query параметре при каждом запросе.",
              "var_2": "Всегда используй bypassSecurityTrustHtml для удобства отображения.",
              "var_3": "Отключи санитизацию в Angular настройках — это ускорит приложение.",
              "var_4": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "correct_position": 4,
              "correct_answer": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
          "theme": "Санитизация контента - применение DomSanitizer для очистки HTML, URL и стилей от вредоносного кода",
          "questions": [
            {
              "question": "[Санитизация контента] Выбери наиболее корректное утверждение.\n\nТема: Санитизация контента - применение DomSanitizer для очистки HTML, URL и стилей от вредоносного кода",
              "var_1": "Angular не имеет защиты от XSS, поэтому нужно всегда использовать innerHTML и ручную фильтрацию.",
              "var_2": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_3": "CSP полностью заменяет санитизацию, поэтому DomSanitizer больше не нужен.",
              "var_4": "Хранить токен в URL безопаснее, потому что его легко дебажить.",
              "correct_position": 2,
              "correct_answer": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Санитизация контента] Практика: выбери лучший вариант действия.\n\nТема: Санитизация контента - применение DomSanitizer для очистки HTML, URL и стилей от вредоносного кода",
              "var_1": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "var_2": "Всегда используй bypassSecurityTrustHtml для удобства отображения.",
              "var_3": "Отключи санитизацию в Angular настройках — это ускорит приложение.",
              "var_4": "Передавай токен в query параметре при каждом запросе.",
              "correct_position": 1,
              "correct_answer": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Состояние приложения (signals services)",
          "theme": "Signal-сервисы - создание базового сервиса с writable signals для хранения и обновления состояния",
          "questions": [
            {
              "question": "[Signal] Какое утверждение наиболее корректно?",
              "var_1": "Signal: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Signal заменяет необходимость тестирования и code review.",
              "var_3": "Signal работает только в IE11 и устарело.",
              "var_4": "Signal запрещено использовать вместе с TypeScript strict mode.",
              "correct_position": 1,
              "correct_answer": "Signal: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Signal] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Signal-сервисы - создание базового сервиса с writable signals для хранения и обновления состояния",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Использовать Signal по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Signal по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Состояние приложения (signals services)",
          "theme": "Computed signals - добавление производных вычислений для фильтрации и трансформации данных в сервисах",
          "questions": [
            {
              "question": "[Computed signals] Какое утверждение наиболее корректно?",
              "var_1": "Computed signals: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Computed signals запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "Computed signals всегда ускоряет приложение независимо от контекста и реализации.",
              "var_4": "Computed signals работает только в IE11 и устарело.",
              "correct_position": 1,
              "correct_answer": "Computed signals: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Computed signals] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Computed signals - добавление производных вычислений для фильтрации и трансформации данных в сервисах",
              "var_1": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Использовать Computed signals по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Computed signals по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "HTTP/интерцепторы/типизация API",
          "theme": "HttpClient - реализация базовых CRUD-операций с типизацией запросов и ответов",
          "questions": [
            {
              "question": "[HttpClient] Выбери наиболее корректное утверждение.\n\nТема: HttpClient - реализация базовых CRUD-операций с типизацией запросов и ответов",
              "var_1": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_2": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_3": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_4": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "correct_position": 2,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[HttpClient] Практика: выбери лучший вариант действия.\n\nТема: HttpClient - реализация базовых CRUD-операций с типизацией запросов и ответов",
              "var_1": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_2": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "var_3": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_4": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "correct_position": 4,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "HTTP/интерцепторы/типизация API",
          "theme": "HTTP интерцепторы - подключение готовых интерцепторов для добавления заголовков и обработки токенов",
          "questions": [
            {
              "question": "[HTTP интерцепторы] Выбери наиболее корректное утверждение.\n\nТема: HTTP интерцепторы - подключение готовых интерцепторов для добавления заголовков и обработки токенов",
              "var_1": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_2": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_3": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_4": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "correct_position": 3,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[HTTP интерцепторы] Практика: выбери лучший вариант действия.\n\nТема: HTTP интерцепторы - подключение готовых интерцепторов для добавления заголовков и обработки токенов",
              "var_1": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_2": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_3": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_4": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "correct_position": 1,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Роутинг (standalone, guards, resolvers)",
          "theme": "Guards - реализация CanActivate для проверки авторизации через AuthService",
          "questions": [
            {
              "question": "[Guards] Выбери наиболее корректное утверждение.\n\nТема: Guards - реализация CanActivate для проверки авторизации через AuthService",
              "var_1": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_2": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "var_3": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_4": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "correct_position": 4,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Guards] Практика: выбери лучший вариант действия.\n\nТема: Guards - реализация CanActivate для проверки авторизации через AuthService",
              "var_1": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_2": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_3": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_4": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "correct_position": 4,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Роутинг (standalone, guards, resolvers)",
          "theme": "Resolvers - предзагрузка данных перед отображением компонента через resolve",
          "questions": [
            {
              "question": "[Resolvers] Выбери наиболее корректное утверждение.\n\nТема: Resolvers - предзагрузка данных перед отображением компонента через resolve",
              "var_1": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_2": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "var_3": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_4": "Lazy loading невозможно использовать со standalone компонентами.",
              "correct_position": 3,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Resolvers] Практика: выбери лучший вариант действия.\n\nТема: Resolvers - предзагрузка данных перед отображением компонента через resolve",
              "var_1": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_2": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_3": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_4": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "correct_position": 3,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "RxJS (операторы, пайплайны, управление подписками)",
          "theme": "Управление подписками - использование async pipe для автоматической отписки в шаблонах",
          "questions": [
            {
              "question": "[Управление подписками] Выбери наиболее корректное утверждение.\n\nТема: Управление подписками - использование async pipe для автоматической отписки в шаблонах",
              "var_1": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_2": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "var_3": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "var_4": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "correct_position": 1,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Управление подписками] Практика: выбери лучший вариант действия.\n\nТема: Управление подписками - использование async pipe для автоматической отписки в шаблонах",
              "var_1": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "var_2": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "var_3": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_4": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "correct_position": 3,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "RxJS (операторы, пайплайны, управление подписками)",
          "theme": "Операторы трансформации данных - применение map и filter для обработки потоков из API",
          "questions": [
            {
              "question": "[Операторы трансформации данных] Выбери наиболее корректное утверждение.\n\nТема: Операторы трансформации данных - применение map и filter для обработки потоков из API",
              "var_1": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "var_2": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_3": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "var_4": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "correct_position": 2,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Операторы трансформации данных] Практика: выбери лучший вариант действия.\n\nТема: Операторы трансформации данных - применение map и filter для обработки потоков из API",
              "var_1": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "var_2": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "var_3": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "var_4": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "correct_position": 4,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Понимание принципов работы сетевых протоколов, знание HTTP",
          "theme": "HTTP методы - использование GET и POST запросов для CRUD операций в Angular сервисах",
          "questions": [
            {
              "question": "[HTTP методы] Выбери наиболее корректное утверждение.\n\nТема: HTTP методы - использование GET и POST запросов для CRUD операций в Angular сервисах",
              "var_1": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_2": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_3": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_4": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "correct_position": 1,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[HTTP методы] Практика: выбери лучший вариант действия.\n\nТема: HTTP методы - использование GET и POST запросов для CRUD операций в Angular сервисах",
              "var_1": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_2": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_3": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "var_4": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "correct_position": 1,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Понимание принципов работы сетевых протоколов, знание HTTP",
          "theme": "HTTP статус-коды - обработка ошибок 4xx и 5xx в subscribe блоке Observable",
          "questions": [
            {
              "question": "[HTTP статус] Выбери наиболее корректное утверждение.\n\nТема: HTTP статус-коды - обработка ошибок 4xx и 5xx в subscribe блоке Observable",
              "var_1": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_2": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_3": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_4": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "correct_position": 4,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[HTTP статус] Практика: выбери лучший вариант действия.\n\nТема: HTTP статус-коды - обработка ошибок 4xx и 5xx в subscribe блоке Observable",
              "var_1": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_2": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_3": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_4": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "correct_position": 1,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Signals API (signal/computed/effect)",
          "theme": "Signals API - создание и чтение signal() для хранения состояния компонента",
          "questions": [
            {
              "question": "[Signals API] Какое утверждение наиболее корректно?",
              "var_1": "Signals API используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_2": "Signals API всегда ускоряет приложение независимо от контекста и реализации.",
              "var_3": "Signals API гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_4": "Signals API: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Signals API: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Signals API] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Signals API - создание и чтение signal() для хранения состояния компонента",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Использовать Signals API по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 3,
              "correct_answer": "Использовать Signals API по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Signals API (signal/computed/effect)",
          "theme": "Computed signals - использование computed() для производных вычислений на основе signal()",
          "questions": [
            {
              "question": "[Computed signals] Какое утверждение наиболее корректно?",
              "var_1": "Computed signals: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Computed signals относится только к стилям CSS и не применяется в логике приложения.",
              "var_3": "Computed signals заменяет необходимость тестирования и code review.",
              "var_4": "Computed signals используется только для серверного рендеринга и не влияет на клиентский код.",
              "correct_position": 1,
              "correct_answer": "Computed signals: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Computed signals] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Computed signals - использование computed() для производных вычислений на основе signal()",
              "var_1": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Использовать Computed signals по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Computed signals по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for, OnPush)",
          "theme": "Жизненный цикл компонентов - использование ngOnInit и ngOnChanges для инициализации и реакции на изменение входных данных",
          "questions": [
            {
              "question": "[Жизненный цикл компонентов] Выбери наиболее корректное утверждение.\n\nТема: Жизненный цикл компонентов - использование ngOnInit и ngOnChanges для инициализации и реакции на изменение входных данных",
              "var_1": "OnPush заставляет Angular пересчитывать компонент чаще, чем Default, поэтому всегда ускоряет приложение.",
              "var_2": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_3": "OnPush автоматически делает все объекты immutable и предотвращает мутации.",
              "var_4": "OnPush отключает работу async pipe и RxJS подписок.",
              "correct_position": 2,
              "correct_answer": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Жизненный цикл компонентов] Практика: выбери лучший вариант действия.\n\nТема: Жизненный цикл компонентов - использование ngOnInit и ngOnChanges для инициализации и реакции на изменение входных данных",
              "var_1": "Поставь setTimeout вокруг обновления, чтобы Angular «заметил» изменения.",
              "var_2": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_3": "Вызывай detectChanges() в каждом ngOnChanges без условий — так надежнее.",
              "var_4": "Оставь мутации объектов как есть — OnPush сам увидит изменения внутри вложенных полей.",
              "correct_position": 2,
              "correct_answer": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for, OnPush)",
          "theme": "Встроенные директивы шаблонов - применение @if и @for для условного рендеринга и отображения списков данных",
          "questions": [
            {
              "question": "[Встроенные директивы шаблонов] Выбери наиболее корректное утверждение.\n\nТема: Встроенные директивы шаблонов - применение @if и @for для условного рендеринга и отображения списков данных",
              "var_1": "OnPush заставляет Angular пересчитывать компонент чаще, чем Default, поэтому всегда ускоряет приложение.",
              "var_2": "OnPush отключает работу async pipe и RxJS подписок.",
              "var_3": "OnPush автоматически делает все объекты immutable и предотвращает мутации.",
              "var_4": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "correct_position": 4,
              "correct_answer": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Встроенные директивы шаблонов] Практика: выбери лучший вариант действия.\n\nТема: Встроенные директивы шаблонов - применение @if и @for для условного рендеринга и отображения списков данных",
              "var_1": "Оставь мутации объектов как есть — OnPush сам увидит изменения внутри вложенных полей.",
              "var_2": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_3": "Вызывай detectChanges() в каждом ngOnChanges без условий — так надежнее.",
              "var_4": "Поставь setTimeout вокруг обновления, чтобы Angular «заметил» изменения.",
              "correct_position": 2,
              "correct_answer": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Архитектура Angular (DI, standalone)",
          "theme": "Dependency Injection - внедрение сервисов через constructor injection в компонентах",
          "questions": [
            {
              "question": "[Dependency Injection] Выбери наиболее корректное утверждение.\n\nТема: Dependency Injection - внедрение сервисов через constructor injection в компонентах",
              "var_1": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_2": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_3": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_4": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "correct_position": 1,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Dependency Injection] Практика: выбери лучший вариант действия.\n\nТема: Dependency Injection - внедрение сервисов через constructor injection в компонентах",
              "var_1": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_2": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_3": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_4": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "correct_position": 2,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Архитектура Angular (DI, standalone)",
          "theme": "Standalone-компоненты - создание и регистрация сервисов через providers в standalone-компонентах",
          "questions": [
            {
              "question": "[Standalone] Выбери наиболее корректное утверждение.\n\nТема: Standalone-компоненты - создание и регистрация сервисов через providers в standalone-компонентах",
              "var_1": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_2": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "var_3": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_4": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "correct_position": 3,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Standalone] Практика: выбери лучший вариант действия.\n\nТема: Standalone-компоненты - создание и регистрация сервисов через providers в standalone-компонентах",
              "var_1": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_2": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_3": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_4": "Используй window.location вместо Router.navigate, так надёжнее.",
              "correct_position": 1,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Angular CLI/сборка/конфиги",
          "theme": "Angular CLI - генерация структурных элементов проекта (компоненты, сервисы, модули)",
          "questions": [
            {
              "question": "[Angular CLI] Какое утверждение наиболее корректно?",
              "var_1": "Angular CLI используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_2": "Angular CLI заменяет необходимость тестирования и code review.",
              "var_3": "Angular CLI: это подход/механизм, который применяется в контексте «Angular CLI/сборка/конфиги» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Angular CLI запрещено использовать вместе с TypeScript strict mode.",
              "correct_position": 3,
              "correct_answer": "Angular CLI: это подход/механизм, который применяется в контексте «Angular CLI/сборка/конфиги» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Angular CLI] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Angular CLI - генерация структурных элементов проекта (компоненты, сервисы, модули)",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Использовать Angular CLI по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Angular CLI по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Angular CLI/сборка/конфиги",
          "theme": "Процесс сборки Angular - различия между development и production режимами",
          "questions": [
            {
              "question": "[Процесс сборки Angular] Какое утверждение наиболее корректно?",
              "var_1": "Процесс сборки Angular запрещено использовать вместе с TypeScript strict mode.",
              "var_2": "Процесс сборки Angular: это подход/механизм, который применяется в контексте «Angular CLI/сборка/конфиги» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Процесс сборки Angular работает только в IE11 и устарело.",
              "var_4": "Процесс сборки Angular заменяет необходимость тестирования и code review.",
              "correct_position": 2,
              "correct_answer": "Процесс сборки Angular: это подход/механизм, который применяется в контексте «Angular CLI/сборка/конфиги» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Процесс сборки Angular] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Процесс сборки Angular - различия между development и production режимами",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Использовать Процесс сборки Angular по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 3,
              "correct_answer": "Использовать Процесс сборки Angular по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Производительность (CD, trackBy, bundle анализ)",
          "theme": "Change Detection - применение OnPush стратегии в компонентах с Input свойствами",
          "questions": [
            {
              "question": "[Change Detection] Выбери наиболее корректное утверждение.\n\nТема: Change Detection - применение OnPush стратегии в компонентах с Input свойствами",
              "var_1": "OnPush заставляет Angular пересчитывать компонент чаще, чем Default, поэтому всегда ускоряет приложение.",
              "var_2": "OnPush отключает работу async pipe и RxJS подписок.",
              "var_3": "OnPush автоматически делает все объекты immutable и предотвращает мутации.",
              "var_4": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "correct_position": 4,
              "correct_answer": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Change Detection] Практика: выбери лучший вариант действия.\n\nТема: Change Detection - применение OnPush стратегии в компонентах с Input свойствами",
              "var_1": "Оставь мутации объектов как есть — OnPush сам увидит изменения внутри вложенных полей.",
              "var_2": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_3": "Вызывай detectChanges() в каждом ngOnChanges без условий — так надежнее.",
              "var_4": "Поставь setTimeout вокруг обновления, чтобы Angular «заметил» изменения.",
              "correct_position": 2,
              "correct_answer": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Производительность (CD, trackBy, bundle анализ)",
          "theme": "Оптимизация шаблонов - реализация trackBy функций для ngFor директив",
          "questions": [
            {
              "question": "[Оптимизация шаблонов] Какое утверждение наиболее корректно?",
              "var_1": "Оптимизация шаблонов: это подход/механизм, который применяется в контексте «Производительность (CD, trackBy, bundle анализ)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Оптимизация шаблонов работает только в IE11 и устарело.",
              "var_3": "Оптимизация шаблонов заменяет необходимость тестирования и code review.",
              "var_4": "Оптимизация шаблонов гарантирует автоматическое исправление ошибок без участия разработчика.",
              "correct_position": 1,
              "correct_answer": "Оптимизация шаблонов: это подход/механизм, который применяется в контексте «Производительность (CD, trackBy, bundle анализ)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Оптимизация шаблонов] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Оптимизация шаблонов - реализация trackBy функций для ngFor директив",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Использовать Оптимизация шаблонов по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Оптимизация шаблонов по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Навыки проведения рефакторинга и code review",
          "theme": "Code review - проверка TypeScript типизации и устранение any в компонентах",
          "questions": [
            {
              "question": "[Code review] Какое утверждение наиболее корректно?",
              "var_1": "Code review гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_2": "Code review всегда ускоряет приложение независимо от контекста и реализации.",
              "var_3": "Code review: это подход/механизм, который применяется в контексте «Навыки проведения рефакторинга и code review» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Code review работает только в IE11 и устарело.",
              "correct_position": 3,
              "correct_answer": "Code review: это подход/механизм, который применяется в контексте «Навыки проведения рефакторинга и code review» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Code review] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Code review - проверка TypeScript типизации и устранение any в компонентах",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Использовать Code review по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 3,
              "correct_answer": "Использовать Code review по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Навыки проведения рефакторинга и code review",
          "theme": "Рефакторинг кода - вынесение магических чисел и строк в константы",
          "questions": [
            {
              "question": "[Рефакторинг кода] Какое утверждение наиболее корректно?",
              "var_1": "Рефакторинг кода гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_2": "Рефакторинг кода работает только в IE11 и устарело.",
              "var_3": "Рефакторинг кода запрещено использовать вместе с TypeScript strict mode.",
              "var_4": "Рефакторинг кода: это подход/механизм, который применяется в контексте «Навыки проведения рефакторинга и code review» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Рефакторинг кода: это подход/механизм, который применяется в контексте «Навыки проведения рефакторинга и code review» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Рефакторинг кода] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Рефакторинг кода - вынесение магических чисел и строк в константы",
              "var_1": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Использовать Рефакторинг кода по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Рефакторинг кода по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        }
      ]
    },
    "middle": {
      "themes": [
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "Семантическая разметка HTML5 - структурирование сложных компонентов с использованием article, section, nav для доступности и SEO",
          "questions": [
            {
              "question": "[Семантическая разметка HTML5] Какое утверждение наиболее корректно?",
              "var_1": "Семантическая разметка HTML5 работает только в IE11 и устарело.",
              "var_2": "Семантическая разметка HTML5 всегда ускоряет приложение независимо от контекста и реализации.",
              "var_3": "Семантическая разметка HTML5: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Семантическая разметка HTML5 используется только для серверного рендеринга и не влияет на клиентский код.",
              "correct_position": 3,
              "correct_answer": "Семантическая разметка HTML5: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Семантическая разметка HTML5] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Семантическая разметка HTML5 - структурирование сложных компонентов с использованием article, section, nav для доступности и SEO",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Использовать Семантическая разметка HTML5 по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 3,
              "correct_answer": "Использовать Семантическая разметка HTML5 по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "CSS Grid и Flexbox - реализация адаптивных макетов многостраничных форм и визардов с динамической перестройкой",
          "questions": [
            {
              "question": "[CSS Grid и Flexbox] Какое утверждение наиболее корректно?",
              "var_1": "CSS Grid и Flexbox всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "CSS Grid и Flexbox гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_3": "CSS Grid и Flexbox работает только в IE11 и устарело.",
              "var_4": "CSS Grid и Flexbox: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "CSS Grid и Flexbox: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[CSS Grid и Flexbox] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: CSS Grid и Flexbox - реализация адаптивных макетов многостраничных форм и визардов с динамической перестройкой",
              "var_1": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Использовать CSS Grid и Flexbox по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 3,
              "correct_answer": "Использовать CSS Grid и Flexbox по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "Tailwind CSS утилиты - построение переиспользуемых компонентных классов через @apply и конфигурация кастомных токенов дизайна",
          "questions": [
            {
              "question": "[Tailwind CSS утилиты] Выбери наиболее корректное утверждение.\n\nТема: Tailwind CSS утилиты - построение переиспользуемых компонентных классов через @apply и конфигурация кастомных токенов дизайна",
              "var_1": "CSP полностью заменяет санитизацию, поэтому DomSanitizer больше не нужен.",
              "var_2": "Angular не имеет защиты от XSS, поэтому нужно всегда использовать innerHTML и ручную фильтрацию.",
              "var_3": "Хранить токен в URL безопаснее, потому что его легко дебажить.",
              "var_4": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "correct_position": 4,
              "correct_answer": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Tailwind CSS утилиты] Практика: выбери лучший вариант действия.\n\nТема: Tailwind CSS утилиты - построение переиспользуемых компонентных классов через @apply и конфигурация кастомных токенов дизайна",
              "var_1": "Всегда используй bypassSecurityTrustHtml для удобства отображения.",
              "var_2": "Передавай токен в query параметре при каждом запросе.",
              "var_3": "Отключи санитизацию в Angular настройках — это ускорит приложение.",
              "var_4": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "correct_position": 4,
              "correct_answer": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "CSS-анимации и transitions - создание плавных микроинтеракций для состояний загрузки, успеха и ошибок в формах",
          "questions": [
            {
              "question": "[CSS] Какое утверждение наиболее корректно?",
              "var_1": "CSS используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_2": "CSS запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "CSS: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "CSS относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 3,
              "correct_answer": "CSS: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[CSS] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: CSS-анимации и transitions - создание плавных микроинтеракций для состояний загрузки, успеха и ошибок в формах",
              "var_1": "Использовать CSS по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "correct_position": 1,
              "correct_answer": "Использовать CSS по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "Адаптивная верстка - применение breakpoints и стратегий mobile-first для корректного отображения UI на различных устройствах",
          "questions": [
            {
              "question": "[Адаптивная верстка] Какое утверждение наиболее корректно?",
              "var_1": "Адаптивная верстка заменяет необходимость тестирования и code review.",
              "var_2": "Адаптивная верстка используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Адаптивная верстка относится только к стилям CSS и не применяется в логике приложения.",
              "var_4": "Адаптивная верстка: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Адаптивная верстка: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Адаптивная верстка] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Адаптивная верстка - применение breakpoints и стратегий mobile-first для корректного отображения UI на различных устройствах",
              "var_1": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_2": "Использовать Адаптивная верстка по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 2,
              "correct_answer": "Использовать Адаптивная верстка по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "CSS Custom Properties - организация темизации и динамическое переключение цветовых схем через CSS-переменные",
          "questions": [
            {
              "question": "[CSS Custom Properties] Какое утверждение наиболее корректно?",
              "var_1": "CSS Custom Properties работает только в IE11 и устарело.",
              "var_2": "CSS Custom Properties запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "CSS Custom Properties: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "CSS Custom Properties относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 3,
              "correct_answer": "CSS Custom Properties: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[CSS Custom Properties] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: CSS Custom Properties - организация темизации и динамическое переключение цветовых схем через CSS-переменные",
              "var_1": "Использовать CSS Custom Properties по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "correct_position": 1,
              "correct_answer": "Использовать CSS Custom Properties по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "Accessibility в HTML и CSS - использование ARIA-атрибутов, focus-управления и контрастности для создания доступных форм и элементов управления",
          "questions": [
            {
              "question": "[Accessibility в HTML и CSS] Какое утверждение наиболее корректно?",
              "var_1": "Accessibility в HTML и CSS заменяет необходимость тестирования и code review.",
              "var_2": "Accessibility в HTML и CSS используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Accessibility в HTML и CSS: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Accessibility в HTML и CSS всегда ускоряет приложение независимо от контекста и реализации.",
              "correct_position": 3,
              "correct_answer": "Accessibility в HTML и CSS: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Accessibility в HTML и CSS] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Accessibility в HTML и CSS - использование ARIA-атрибутов, focus-управления и контрастности для создания доступных форм и элементов управления",
              "var_1": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Использовать Accessibility в HTML и CSS по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "correct_position": 3,
              "correct_answer": "Использовать Accessibility в HTML и CSS по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Асинхронное программирование - управление Promise chains и async/await для обработки последовательных HTTP-запросов",
          "questions": [
            {
              "question": "[Асинхронное программирование] Выбери наиболее корректное утверждение.\n\nТема: Асинхронное программирование - управление Promise chains и async/await для обработки последовательных HTTP-запросов",
              "var_1": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_2": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_3": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_4": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "correct_position": 1,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Асинхронное программирование] Практика: выбери лучший вариант действия.\n\nТема: Асинхронное программирование - управление Promise chains и async/await для обработки последовательных HTTP-запросов",
              "var_1": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_2": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_3": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "var_4": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "correct_position": 4,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Прототипное наследование - применение prototype и конструкторов для создания переиспользуемых паттернов в Angular сервисах",
          "questions": [
            {
              "question": "[Прототипное наследование] Какое утверждение наиболее корректно?",
              "var_1": "Прототипное наследование относится только к стилям CSS и не применяется в логике приложения.",
              "var_2": "Прототипное наследование всегда ускоряет приложение независимо от контекста и реализации.",
              "var_3": "Прототипное наследование: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Прототипное наследование используется только для серверного рендеринга и не влияет на клиентский код.",
              "correct_position": 3,
              "correct_answer": "Прототипное наследование: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Прототипное наследование] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Прототипное наследование - применение prototype и конструкторов для создания переиспользуемых паттернов в Angular сервисах",
              "var_1": "Использовать Прототипное наследование по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "correct_position": 1,
              "correct_answer": "Использовать Прототипное наследование по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Замыкания и область видимости - использование closures для инкапсуляции состояния в фабричных функциях и callback'ах",
          "questions": [
            {
              "question": "[Замыкания и область видимости] Какое утверждение наиболее корректно?",
              "var_1": "Замыкания и область видимости всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "Замыкания и область видимости: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Замыкания и область видимости используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_4": "Замыкания и область видимости относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 2,
              "correct_answer": "Замыкания и область видимости: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Замыкания и область видимости] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Замыкания и область видимости - использование closures для инкапсуляции состояния в фабричных функциях и callback'ах",
              "var_1": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Использовать Замыкания и область видимости по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Замыкания и область видимости по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Методы массивов - комбинирование map/filter/reduce для трансформации данных перед отображением в компонентах",
          "questions": [
            {
              "question": "[Методы массивов] Какое утверждение наиболее корректно?",
              "var_1": "Методы массивов: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Методы массивов запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "Методы массивов работает только в IE11 и устарело.",
              "var_4": "Методы массивов гарантирует автоматическое исправление ошибок без участия разработчика.",
              "correct_position": 1,
              "correct_answer": "Методы массивов: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Методы массивов] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Методы массивов - комбинирование map/filter/reduce для трансформации данных перед отображением в компонентах",
              "var_1": "Использовать Методы массивов по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 1,
              "correct_answer": "Использовать Методы массивов по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Event Loop и микрозадачи - понимание порядка выполнения промисов и setTimeout для отладки асинхронных проблем в Angular",
          "questions": [
            {
              "question": "[Event Loop и микрозадачи] Какое утверждение наиболее корректно?",
              "var_1": "Event Loop и микрозадачи: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Event Loop и микрозадачи гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_3": "Event Loop и микрозадачи всегда ускоряет приложение независимо от контекста и реализации.",
              "var_4": "Event Loop и микрозадачи работает только в IE11 и устарело.",
              "correct_position": 1,
              "correct_answer": "Event Loop и микрозадачи: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Event Loop и микрозадачи] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Event Loop и микрозадачи - понимание порядка выполнения промисов и setTimeout для отладки асинхронных проблем в Angular",
              "var_1": "Использовать Event Loop и микрозадачи по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 1,
              "correct_answer": "Использовать Event Loop и микрозадачи по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Функции высшего порядка - создание переиспользуемых утилит для throttle/debounce и композиции валидаторов форм",
          "questions": [
            {
              "question": "[Функции высшего порядка] Выбери наиболее корректное утверждение.\n\nТема: Функции высшего порядка - создание переиспользуемых утилит для throttle/debounce и композиции валидаторов форм",
              "var_1": "Template-driven формы быстрее и безопаснее Reactive, поэтому их всегда выбирают в enterprise.",
              "var_2": "FormArray нельзя использовать внутри FormGroup.",
              "var_3": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_4": "Reactive Forms не поддерживают асинхронную валидацию.",
              "correct_position": 3,
              "correct_answer": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Функции высшего порядка] Практика: выбери лучший вариант действия.\n\nТема: Функции высшего порядка - создание переиспользуемых утилит для throttle/debounce и композиции валидаторов форм",
              "var_1": "Для совпадения паролей сравнивай значения прямо в шаблоне через (input) и не трогай валидаторы.",
              "var_2": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_3": "Создай отдельный FormGroup на каждый input, чтобы было «модульно».",
              "var_4": "Проверяй уникальность email только на submit, без async validator.",
              "correct_position": 2,
              "correct_answer": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "WeakMap и WeakSet - применение для кэширования данных компонентов без утечек памяти при динамическом создании элементов",
          "questions": [
            {
              "question": "[WeakMap и WeakSet] Какое утверждение наиболее корректно?",
              "var_1": "WeakMap и WeakSet всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "WeakMap и WeakSet: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "WeakMap и WeakSet запрещено использовать вместе с TypeScript strict mode.",
              "var_4": "WeakMap и WeakSet работает только в IE11 и устарело.",
              "correct_position": 2,
              "correct_answer": "WeakMap и WeakSet: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[WeakMap и WeakSet] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: WeakMap и WeakSet - применение для кэширования данных компонентов без утечек памяти при динамическом создании элементов",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Использовать WeakMap и WeakSet по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 3,
              "correct_answer": "Использовать WeakMap и WeakSet по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Generics - применение для типизации RxJS операторов и Observable потоков в Angular сервисах",
          "questions": [
            {
              "question": "[Generics] Выбери наиболее корректное утверждение.\n\nТема: Generics - применение для типизации RxJS операторов и Observable потоков в Angular сервисах",
              "var_1": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "var_2": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "var_3": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_4": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "correct_position": 3,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Generics] Практика: выбери лучший вариант действия.\n\nТема: Generics - применение для типизации RxJS операторов и Observable потоков в Angular сервисах",
              "var_1": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_2": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "var_3": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "var_4": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "correct_position": 1,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Utility Types - использование Pick, Omit, Partial для работы с моделями данных API и форм",
          "questions": [
            {
              "question": "[Utility Types] Какое утверждение наиболее корректно?",
              "var_1": "Utility Types работает только в IE11 и устарело.",
              "var_2": "Utility Types заменяет необходимость тестирования и code review.",
              "var_3": "Utility Types: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Utility Types используется только для серверного рендеринга и не влияет на клиентский код.",
              "correct_position": 3,
              "correct_answer": "Utility Types: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Utility Types] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Utility Types - использование Pick, Omit, Partial для работы с моделями данных API и форм",
              "var_1": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Использовать Utility Types по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Utility Types по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Type Guards и Narrowing - проверка типов при обработке WebSocket сообщений и HTTP ответов",
          "questions": [
            {
              "question": "[Type Guards и Narrowing] Выбери наиболее корректное утверждение.\n\nТема: Type Guards и Narrowing - проверка типов при обработке WebSocket сообщений и HTTP ответов",
              "var_1": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_2": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_3": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_4": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "correct_position": 4,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Type Guards и Narrowing] Практика: выбери лучший вариант действия.\n\nТема: Type Guards и Narrowing - проверка типов при обработке WebSocket сообщений и HTTP ответов",
              "var_1": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_2": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_3": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "var_4": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "correct_position": 1,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Mapped Types и Template Literal Types - создание типобезопасных конфигураций для роутинга и состояния",
          "questions": [
            {
              "question": "[Mapped Types и Template Literal Types] Выбери наиболее корректное утверждение.\n\nТема: Mapped Types и Template Literal Types - создание типобезопасных конфигураций для роутинга и состояния",
              "var_1": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_2": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_3": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "var_4": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "correct_position": 4,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Mapped Types и Template Literal Types] Практика: выбери лучший вариант действия.\n\nТема: Mapped Types и Template Literal Types - создание типобезопасных конфигураций для роутинга и состояния",
              "var_1": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_2": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_3": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_4": "Используй window.location вместо Router.navigate, так надёжнее.",
              "correct_position": 1,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Декораторы TypeScript - понимание работы Angular декораторов и создание custom декораторов для компонентов",
          "questions": [
            {
              "question": "[Декораторы TypeScript] Какое утверждение наиболее корректно?",
              "var_1": "Декораторы TypeScript заменяет необходимость тестирования и code review.",
              "var_2": "Декораторы TypeScript гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_3": "Декораторы TypeScript: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Декораторы TypeScript используется только для серверного рендеринга и не влияет на клиентский код.",
              "correct_position": 3,
              "correct_answer": "Декораторы TypeScript: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Декораторы TypeScript] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Декораторы TypeScript - понимание работы Angular декораторов и создание custom декораторов для компонентов",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Использовать Декораторы TypeScript по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 2,
              "correct_answer": "Использовать Декораторы TypeScript по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Conditional Types - типизация перегруженных методов сервисов и обработка различных форматов API ответов",
          "questions": [
            {
              "question": "[Conditional Types] Какое утверждение наиболее корректно?",
              "var_1": "Conditional Types заменяет необходимость тестирования и code review.",
              "var_2": "Conditional Types: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Conditional Types работает только в IE11 и устарело.",
              "var_4": "Conditional Types всегда ускоряет приложение независимо от контекста и реализации.",
              "correct_position": 2,
              "correct_answer": "Conditional Types: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Conditional Types] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Conditional Types - типизация перегруженных методов сервисов и обработка различных форматов API ответов",
              "var_1": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Использовать Conditional Types по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Conditional Types по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "TypeScript Compiler Options - настройка strict режима и esModuleInterop для оптимизации проверки типов в Angular проекте",
          "questions": [
            {
              "question": "[TypeScript Compiler Options] Какое утверждение наиболее корректно?",
              "var_1": "TypeScript Compiler Options всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "TypeScript Compiler Options: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "TypeScript Compiler Options используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_4": "TypeScript Compiler Options работает только в IE11 и устарело.",
              "correct_position": 2,
              "correct_answer": "TypeScript Compiler Options: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[TypeScript Compiler Options] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: TypeScript Compiler Options - настройка strict режима и esModuleInterop для оптимизации проверки типов в Angular проекте",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Использовать TypeScript Compiler Options по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать TypeScript Compiler Options по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "ООП в TypeScript - реализация наследования и композиции для переиспользуемых компонентов Angular",
          "questions": [
            {
              "question": "[ООП в TypeScript] Какое утверждение наиболее корректно?",
              "var_1": "ООП в TypeScript запрещено использовать вместе с TypeScript strict mode.",
              "var_2": "ООП в TypeScript гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_3": "ООП в TypeScript заменяет необходимость тестирования и code review.",
              "var_4": "ООП в TypeScript: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "ООП в TypeScript: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[ООП в TypeScript] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: ООП в TypeScript - реализация наследования и композиции для переиспользуемых компонентов Angular",
              "var_1": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Использовать ООП в TypeScript по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать ООП в TypeScript по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "Принципы SOLID - применение Dependency Injection и Single Responsibility в архитектуре Angular сервисов",
          "questions": [
            {
              "question": "[Принципы SOLID] Какое утверждение наиболее корректно?",
              "var_1": "Принципы SOLID запрещено использовать вместе с TypeScript strict mode.",
              "var_2": "Принципы SOLID заменяет необходимость тестирования и code review.",
              "var_3": "Принципы SOLID всегда ускоряет приложение независимо от контекста и реализации.",
              "var_4": "Принципы SOLID: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Принципы SOLID: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Принципы SOLID] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Принципы SOLID - применение Dependency Injection и Single Responsibility в архитектуре Angular сервисов",
              "var_1": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Использовать Принципы SOLID по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Принципы SOLID по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "Инкапсуляция и модификаторы доступа - проектирование публичного API компонентов через @Input/@Output",
          "questions": [
            {
              "question": "[Инкапсуляция и модификаторы доступа] Какое утверждение наиболее корректно?",
              "var_1": "Инкапсуляция и модификаторы доступа относится только к стилям CSS и не применяется в логике приложения.",
              "var_2": "Инкапсуляция и модификаторы доступа используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Инкапсуляция и модификаторы доступа гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_4": "Инкапсуляция и модификаторы доступа: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Инкапсуляция и модификаторы доступа: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Инкапсуляция и модификаторы доступа] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Инкапсуляция и модификаторы доступа - проектирование публичного API компонентов через @Input/@Output",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Использовать Инкапсуляция и модификаторы доступа по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Инкапсуляция и модификаторы доступа по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "Паттерны проектирования - применение Observer, Strategy и Factory в контексте Angular RxJS и сервисов",
          "questions": [
            {
              "question": "[Паттерны проектирования] Выбери наиболее корректное утверждение.\n\nТема: Паттерны проектирования - применение Observer, Strategy и Factory в контексте Angular RxJS и сервисов",
              "var_1": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "var_2": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_3": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "var_4": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "correct_position": 2,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Паттерны проектирования] Практика: выбери лучший вариант действия.\n\nТема: Паттерны проектирования - применение Observer, Strategy и Factory в контексте Angular RxJS и сервисов",
              "var_1": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "var_2": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_3": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "var_4": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "correct_position": 2,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание Git",
          "theme": "Rebase - интерактивное редактирование истории коммитов перед code review",
          "questions": [
            {
              "question": "[Rebase] Выбери наиболее корректное утверждение.\n\nТема: Rebase - интерактивное редактирование истории коммитов перед code review",
              "var_1": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_2": "bisect нужен только для конфликтов слияния, а не для поиска регрессий.",
              "var_3": "rebase безопаснее merge, потому что никогда не переписывает историю.",
              "var_4": "reflog показывает только ветки на удаленном репозитории.",
              "correct_position": 1,
              "correct_answer": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Rebase] Практика: выбери лучший вариант действия.\n\nТема: Rebase - интерактивное редактирование истории коммитов перед code review",
              "var_1": "Чтобы решить конфликт, просто удали конфликтные файлы.",
              "var_2": "Если потерял коммит, единственный путь — заново написать код.",
              "var_3": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_4": "Всегда делай force-push в main после rebase — так история будет красивее.",
              "correct_position": 3,
              "correct_answer": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание Git",
          "theme": "Stash - управление незакоммиченными изменениями при переключении между задачами",
          "questions": [
            {
              "question": "[Stash] Выбери наиболее корректное утверждение.\n\nТема: Stash - управление незакоммиченными изменениями при переключении между задачами",
              "var_1": "bisect нужен только для конфликтов слияния, а не для поиска регрессий.",
              "var_2": "reflog показывает только ветки на удаленном репозитории.",
              "var_3": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_4": "rebase безопаснее merge, потому что никогда не переписывает историю.",
              "correct_position": 3,
              "correct_answer": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Stash] Практика: выбери лучший вариант действия.\n\nТема: Stash - управление незакоммиченными изменениями при переключении между задачами",
              "var_1": "Всегда делай force-push в main после rebase — так история будет красивее.",
              "var_2": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_3": "Если потерял коммит, единственный путь — заново написать код.",
              "var_4": "Чтобы решить конфликт, просто удали конфликтные файлы.",
              "correct_position": 2,
              "correct_answer": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание Git",
          "theme": "Анализ изменений - использование git diff и git blame для поиска причин багов",
          "questions": [
            {
              "question": "[Анализ изменений] Выбери наиболее корректное утверждение.\n\nТема: Анализ изменений - использование git diff и git blame для поиска причин багов",
              "var_1": "rebase безопаснее merge, потому что никогда не переписывает историю.",
              "var_2": "reflog показывает только ветки на удаленном репозитории.",
              "var_3": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_4": "bisect нужен только для конфликтов слияния, а не для поиска регрессий.",
              "correct_position": 3,
              "correct_answer": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Анализ изменений] Практика: выбери лучший вариант действия.\n\nТема: Анализ изменений - использование git diff и git blame для поиска причин багов",
              "var_1": "Чтобы решить конфликт, просто удали конфликтные файлы.",
              "var_2": "Всегда делай force-push в main после rebase — так история будет красивее.",
              "var_3": "Если потерял коммит, единственный путь — заново написать код.",
              "var_4": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "correct_position": 4,
              "correct_answer": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Формы (Template/Reactive, валидаторы)",
          "theme": "Reactive Forms API - создание переиспользуемых синхронных и асинхронных валидаторов для бизнес-логики",
          "questions": [
            {
              "question": "[Reactive Forms API] Выбери наиболее корректное утверждение.\n\nТема: Reactive Forms API - создание переиспользуемых синхронных и асинхронных валидаторов для бизнес-логики",
              "var_1": "FormArray нельзя использовать внутри FormGroup.",
              "var_2": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_3": "Template-driven формы быстрее и безопаснее Reactive, поэтому их всегда выбирают в enterprise.",
              "var_4": "Reactive Forms не поддерживают асинхронную валидацию.",
              "correct_position": 2,
              "correct_answer": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Reactive Forms API] Практика: выбери лучший вариант действия.\n\nТема: Reactive Forms API - создание переиспользуемых синхронных и асинхронных валидаторов для бизнес-логики",
              "var_1": "Проверяй уникальность email только на submit, без async validator.",
              "var_2": "Создай отдельный FormGroup на каждый input, чтобы было «модульно».",
              "var_3": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_4": "Для совпадения паролей сравнивай значения прямо в шаблоне через (input) и не трогай валидаторы.",
              "correct_position": 3,
              "correct_answer": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Формы (Template/Reactive, валидаторы)",
          "theme": "FormArray - динамическое управление вложенными структурами форм с добавлением и удалением элементов",
          "questions": [
            {
              "question": "[FormArray] Выбери наиболее корректное утверждение.\n\nТема: FormArray - динамическое управление вложенными структурами форм с добавлением и удалением элементов",
              "var_1": "Reactive Forms не поддерживают асинхронную валидацию.",
              "var_2": "FormArray нельзя использовать внутри FormGroup.",
              "var_3": "Template-driven формы быстрее и безопаснее Reactive, поэтому их всегда выбирают в enterprise.",
              "var_4": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "correct_position": 4,
              "correct_answer": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[FormArray] Практика: выбери лучший вариант действия.\n\nТема: FormArray - динамическое управление вложенными структурами форм с добавлением и удалением элементов",
              "var_1": "Проверяй уникальность email только на submit, без async validator.",
              "var_2": "Создай отдельный FormGroup на каждый input, чтобы было «модульно».",
              "var_3": "Для совпадения паролей сравнивай значения прямо в шаблоне через (input) и не трогай валидаторы.",
              "var_4": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "correct_position": 4,
              "correct_answer": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
          "theme": "Управление JWT-токенами - реализация сервиса с автоматическим refresh-механизмом и обработкой истечения сессии",
          "questions": [
            {
              "question": "[Управление JWT] Выбери наиболее корректное утверждение.\n\nТема: Управление JWT-токенами - реализация сервиса с автоматическим refresh-механизмом и обработкой истечения сессии",
              "var_1": "CSP полностью заменяет санитизацию, поэтому DomSanitizer больше не нужен.",
              "var_2": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_3": "Хранить токен в URL безопаснее, потому что его легко дебажить.",
              "var_4": "Angular не имеет защиты от XSS, поэтому нужно всегда использовать innerHTML и ручную фильтрацию.",
              "correct_position": 2,
              "correct_answer": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Управление JWT] Практика: выбери лучший вариант действия.\n\nТема: Управление JWT-токенами - реализация сервиса с автоматическим refresh-механизмом и обработкой истечения сессии",
              "var_1": "Передавай токен в query параметре при каждом запросе.",
              "var_2": "Всегда используй bypassSecurityTrustHtml для удобства отображения.",
              "var_3": "Отключи санитизацию в Angular настройках — это ускорит приложение.",
              "var_4": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "correct_position": 4,
              "correct_answer": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
          "theme": "Санитизация контента - создание кастомных директив и pipes для безопасного рендеринга HTML с настраиваемыми правилами",
          "questions": [
            {
              "question": "[Санитизация контента] Выбери наиболее корректное утверждение.\n\nТема: Санитизация контента - создание кастомных директив и pipes для безопасного рендеринга HTML с настраиваемыми правилами",
              "var_1": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "var_2": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "var_3": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "var_4": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "correct_position": 4,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Санитизация контента] Практика: выбери лучший вариант действия.\n\nТема: Санитизация контента - создание кастомных директив и pipes для безопасного рендеринга HTML с настраиваемыми правилами",
              "var_1": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "var_2": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_3": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "var_4": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "correct_position": 2,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Состояние приложения (signals services)",
          "theme": "Signal-сервисы для управления коллекциями - реализация методов добавления, удаления и модификации элементов с автоматическим пересчетом производных данных через computed",
          "questions": [
            {
              "question": "[Signal] Какое утверждение наиболее корректно?",
              "var_1": "Signal запрещено использовать вместе с TypeScript strict mode.",
              "var_2": "Signal: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Signal используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_4": "Signal гарантирует автоматическое исправление ошибок без участия разработчика.",
              "correct_position": 2,
              "correct_answer": "Signal: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Signal] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Signal-сервисы для управления коллекциями - реализация методов добавления, удаления и модификации элементов с автоматическим пересчетом производных данных через computed",
              "var_1": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_2": "Использовать Signal по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 2,
              "correct_answer": "Использовать Signal по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Состояние приложения (signals services)",
          "theme": "Синхронизация состояния signal-сервисов с API - обработка загрузки данных, кэширование ответов и управление состояниями loading/error/success",
          "questions": [
            {
              "question": "[Синхронизация состояния signal] Какое утверждение наиболее корректно?",
              "var_1": "Синхронизация состояния signal всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "Синхронизация состояния signal запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "Синхронизация состояния signal заменяет необходимость тестирования и code review.",
              "var_4": "Синхронизация состояния signal: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Синхронизация состояния signal: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Синхронизация состояния signal] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Синхронизация состояния signal-сервисов с API - обработка загрузки данных, кэширование ответов и управление состояниями loading/error/success",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Использовать Синхронизация состояния signal по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Синхронизация состояния signal по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "HTTP/интерцепторы/типизация API",
          "theme": "Кеширование HTTP-запросов - стратегии инвалидации кеша и управление TTL в интерцепторах",
          "questions": [
            {
              "question": "[Кеширование HTTP] Выбери наиболее корректное утверждение.\n\nТема: Кеширование HTTP-запросов - стратегии инвалидации кеша и управление TTL в интерцепторах",
              "var_1": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_2": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_3": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_4": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "correct_position": 2,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Кеширование HTTP] Практика: выбери лучший вариант действия.\n\nТема: Кеширование HTTP-запросов - стратегии инвалидации кеша и управление TTL в интерцепторах",
              "var_1": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_2": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_3": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_4": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "correct_position": 2,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "HTTP/интерцепторы/типизация API",
          "theme": "Централизованная обработка ошибок - маппинг HTTP-статусов на пользовательские сообщения через ErrorHandler",
          "questions": [
            {
              "question": "[Централизованная обработка ошибок] Выбери наиболее корректное утверждение.\n\nТема: Централизованная обработка ошибок - маппинг HTTP-статусов на пользовательские сообщения через ErrorHandler",
              "var_1": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_2": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_3": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_4": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "correct_position": 4,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Централизованная обработка ошибок] Практика: выбери лучший вариант действия.\n\nТема: Централизованная обработка ошибок - маппинг HTTP-статусов на пользовательские сообщения через ErrorHandler",
              "var_1": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_2": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "var_3": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_4": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "correct_position": 3,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Роутинг (standalone, guards, resolvers)",
          "theme": "Функциональные guards - реализация CanActivate и CanDeactivate с inject() для асинхронных проверок авторизации и несохраненных данных",
          "questions": [
            {
              "question": "[Функциональные guards] Выбери наиболее корректное утверждение.\n\nТема: Функциональные guards - реализация CanActivate и CanDeactivate с inject() для асинхронных проверок авторизации и несохраненных данных",
              "var_1": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_2": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_3": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "var_4": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "correct_position": 4,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Функциональные guards] Практика: выбери лучший вариант действия.\n\nТема: Функциональные guards - реализация CanActivate и CanDeactivate с inject() для асинхронных проверок авторизации и несохраненных данных",
              "var_1": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_2": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_3": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_4": "Используй window.location вместо Router.navigate, так надёжнее.",
              "correct_position": 1,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Роутинг (standalone, guards, resolvers)",
          "theme": "Resolvers - параллельная загрузка данных через forkJoin с обработкой частичных ошибок и fallback-стратегиями",
          "questions": [
            {
              "question": "[Resolvers] Выбери наиболее корректное утверждение.\n\nТема: Resolvers - параллельная загрузка данных через forkJoin с обработкой частичных ошибок и fallback-стратегиями",
              "var_1": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_2": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_3": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_4": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "correct_position": 2,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Resolvers] Практика: выбери лучший вариант действия.\n\nТема: Resolvers - параллельная загрузка данных через forkJoin с обработкой частичных ошибок и fallback-стратегиями",
              "var_1": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_2": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_3": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_4": "Используй window.location вместо Router.navigate, так надёжнее.",
              "correct_position": 3,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "RxJS (операторы, пайплайны, управление подписками)",
          "theme": "Операторы высшего порядка - использование switchMap, mergeMap и exhaustMap для управления вложенными Observable-потоками",
          "questions": [
            {
              "question": "[Операторы высшего порядка] Выбери наиболее корректное утверждение.\n\nТема: Операторы высшего порядка - использование switchMap, mergeMap и exhaustMap для управления вложенными Observable-потоками",
              "var_1": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "var_2": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_3": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "var_4": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "correct_position": 2,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Операторы высшего порядка] Практика: выбери лучший вариант действия.\n\nТема: Операторы высшего порядка - использование switchMap, mergeMap и exhaustMap для управления вложенными Observable-потоками",
              "var_1": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "var_2": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "var_3": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_4": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "correct_position": 3,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "RxJS (операторы, пайплайны, управление подписками)",
          "theme": "Управление подписками - применение Subject, takeUntil и Subscription для предотвращения утечек памяти в компонентах",
          "questions": [
            {
              "question": "[Управление подписками] Выбери наиболее корректное утверждение.\n\nТема: Управление подписками - применение Subject, takeUntil и Subscription для предотвращения утечек памяти в компонентах",
              "var_1": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "var_2": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "var_3": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "var_4": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "correct_position": 4,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Управление подписками] Практика: выбери лучший вариант действия.\n\nТема: Управление подписками - применение Subject, takeUntil и Subscription для предотвращения утечек памяти в компонентах",
              "var_1": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "var_2": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "var_3": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_4": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "correct_position": 3,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Понимание принципов работы сетевых протоколов, знание HTTP",
          "theme": "HTTP кеширование - стратегии использования Cache-Control, ETag и If-None-Match для оптимизации запросов в Angular",
          "questions": [
            {
              "question": "[HTTP кеширование] Выбери наиболее корректное утверждение.\n\nТема: HTTP кеширование - стратегии использования Cache-Control, ETag и If-None-Match для оптимизации запросов в Angular",
              "var_1": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_2": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_3": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_4": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "correct_position": 1,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[HTTP кеширование] Практика: выбери лучший вариант действия.\n\nТема: HTTP кеширование - стратегии использования Cache-Control, ETag и If-None-Match для оптимизации запросов в Angular",
              "var_1": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_2": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "var_3": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_4": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "correct_position": 3,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Понимание принципов работы сетевых протоколов, знание HTTP",
          "theme": "HTTP методы и идемпотентность - корректное применение GET, POST, PUT, DELETE и PATCH при разработке сервисов с учетом retry-логики",
          "questions": [
            {
              "question": "[HTTP методы и идемпотентность] Выбери наиболее корректное утверждение.\n\nТема: HTTP методы и идемпотентность - корректное применение GET, POST, PUT, DELETE и PATCH при разработке сервисов с учетом retry-логики",
              "var_1": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_2": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_3": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_4": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "correct_position": 2,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[HTTP методы и идемпотентность] Практика: выбери лучший вариант действия.\n\nТема: HTTP методы и идемпотентность - корректное применение GET, POST, PUT, DELETE и PATCH при разработке сервисов с учетом retry-логики",
              "var_1": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "var_2": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_3": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_4": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "correct_position": 4,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Signals API (signal/computed/effect)",
          "theme": "Computed signals - оптимизация вычислений при комбинированной фильтрации данных",
          "questions": [
            {
              "question": "[Computed signals] Какое утверждение наиболее корректно?",
              "var_1": "Computed signals: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Computed signals используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Computed signals гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_4": "Computed signals относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 1,
              "correct_answer": "Computed signals: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Computed signals] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Computed signals - оптимизация вычислений при комбинированной фильтрации данных",
              "var_1": "Использовать Computed signals по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 1,
              "correct_answer": "Использовать Computed signals по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Signals API (signal/computed/effect)",
          "theme": "Effect API - управление побочными эффектами и синхронизация с внешними источниками данных",
          "questions": [
            {
              "question": "[Effect API] Какое утверждение наиболее корректно?",
              "var_1": "Effect API гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_2": "Effect API относится только к стилям CSS и не применяется в логике приложения.",
              "var_3": "Effect API запрещено использовать вместе с TypeScript strict mode.",
              "var_4": "Effect API: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Effect API: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Effect API] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Effect API - управление побочными эффектами и синхронизация с внешними источниками данных",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Использовать Effect API по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 2,
              "correct_answer": "Использовать Effect API по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for, OnPush)",
          "theme": "Жизненный цикл компонентов - применение хуков для оптимизации работы с подписками и ресурсами в OnPush компонентах",
          "questions": [
            {
              "question": "[Жизненный цикл компонентов] Выбери наиболее корректное утверждение.\n\nТема: Жизненный цикл компонентов - применение хуков для оптимизации работы с подписками и ресурсами в OnPush компонентах",
              "var_1": "OnPush заставляет Angular пересчитывать компонент чаще, чем Default, поэтому всегда ускоряет приложение.",
              "var_2": "OnPush автоматически делает все объекты immutable и предотвращает мутации.",
              "var_3": "OnPush отключает работу async pipe и RxJS подписок.",
              "var_4": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "correct_position": 4,
              "correct_answer": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Жизненный цикл компонентов] Практика: выбери лучший вариант действия.\n\nТема: Жизненный цикл компонентов - применение хуков для оптимизации работы с подписками и ресурсами в OnPush компонентах",
              "var_1": "Оставь мутации объектов как есть — OnPush сам увидит изменения внутри вложенных полей.",
              "var_2": "Поставь setTimeout вокруг обновления, чтобы Angular «заметил» изменения.",
              "var_3": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_4": "Вызывай detectChanges() в каждом ngOnChanges без условий — так надежнее.",
              "correct_position": 3,
              "correct_answer": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for, OnPush)",
          "theme": "OnPush стратегия - реализация компонентов с immutable данными и ручным управлением change detection для списков с 1000+ элементами",
          "questions": [
            {
              "question": "[OnPush стратегия] Выбери наиболее корректное утверждение.\n\nТема: OnPush стратегия - реализация компонентов с immutable данными и ручным управлением change detection для списков с 1000+ элементами",
              "var_1": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_2": "OnPush отключает работу async pipe и RxJS подписок.",
              "var_3": "OnPush автоматически делает все объекты immutable и предотвращает мутации.",
              "var_4": "OnPush заставляет Angular пересчитывать компонент чаще, чем Default, поэтому всегда ускоряет приложение.",
              "correct_position": 1,
              "correct_answer": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[OnPush стратегия] Практика: выбери лучший вариант действия.\n\nТема: OnPush стратегия - реализация компонентов с immutable данными и ручным управлением change detection для списков с 1000+ элементами",
              "var_1": "Поставь setTimeout вокруг обновления, чтобы Angular «заметил» изменения.",
              "var_2": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_3": "Оставь мутации объектов как есть — OnPush сам увидит изменения внутри вложенных полей.",
              "var_4": "Вызывай detectChanges() в каждом ngOnChanges без условий — так надежнее.",
              "correct_position": 2,
              "correct_answer": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Архитектура Angular (DI, standalone)",
          "theme": "Dependency Injection - настройка custom провайдеров через useFactory с учетом окружения",
          "questions": [
            {
              "question": "[Dependency Injection] Выбери наиболее корректное утверждение.\n\nТема: Dependency Injection - настройка custom провайдеров через useFactory с учетом окружения",
              "var_1": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_2": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_3": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_4": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "correct_position": 3,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Dependency Injection] Практика: выбери лучший вариант действия.\n\nТема: Dependency Injection - настройка custom провайдеров через useFactory с учетом окружения",
              "var_1": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_2": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_3": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_4": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "correct_position": 1,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Архитектура Angular (DI, standalone)",
          "theme": "Standalone компоненты - миграция NgModule-структуры с сохранением иерархии провайдеров",
          "questions": [
            {
              "question": "[Standalone компоненты] Выбери наиболее корректное утверждение.\n\nТема: Standalone компоненты - миграция NgModule-структуры с сохранением иерархии провайдеров",
              "var_1": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_2": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_3": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_4": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "correct_position": 3,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Standalone компоненты] Практика: выбери лучший вариант действия.\n\nТема: Standalone компоненты - миграция NgModule-структуры с сохранением иерархии провайдеров",
              "var_1": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_2": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_3": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_4": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "correct_position": 1,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Angular CLI/сборка/конфиги",
          "theme": "Бюджеты сборки - настройка лимитов размера бандлов и оптимизация initial/lazy chunks",
          "questions": [
            {
              "question": "[Бюджеты сборки] Выбери наиболее корректное утверждение.\n\nТема: Бюджеты сборки - настройка лимитов размера бандлов и оптимизация initial/lazy chunks",
              "var_1": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_2": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_3": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_4": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "correct_position": 3,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Бюджеты сборки] Практика: выбери лучший вариант действия.\n\nТема: Бюджеты сборки - настройка лимитов размера бандлов и оптимизация initial/lazy chunks",
              "var_1": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_2": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_3": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_4": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "correct_position": 1,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Angular CLI/сборка/конфиги",
          "theme": "Lazy loading модулей - конфигурация loadChildren и preloading стратегий в роутинге",
          "questions": [
            {
              "question": "[Lazy loading модулей] Выбери наиболее корректное утверждение.\n\nТема: Lazy loading модулей - конфигурация loadChildren и preloading стратегий в роутинге",
              "var_1": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_2": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_3": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_4": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "correct_position": 3,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Lazy loading модулей] Практика: выбери лучший вариант действия.\n\nТема: Lazy loading модулей - конфигурация loadChildren и preloading стратегий в роутинге",
              "var_1": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_2": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_3": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_4": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "correct_position": 4,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Производительность (CD, trackBy, bundle анализ)",
          "theme": "Change Detection - стратегия OnPush и immutable паттерны для оптимизации рендеринга",
          "questions": [
            {
              "question": "[Change Detection] Выбери наиболее корректное утверждение.\n\nТема: Change Detection - стратегия OnPush и immutable паттерны для оптимизации рендеринга",
              "var_1": "OnPush отключает работу async pipe и RxJS подписок.",
              "var_2": "OnPush автоматически делает все объекты immutable и предотвращает мутации.",
              "var_3": "OnPush заставляет Angular пересчитывать компонент чаще, чем Default, поэтому всегда ускоряет приложение.",
              "var_4": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "correct_position": 4,
              "correct_answer": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Change Detection] Практика: выбери лучший вариант действия.\n\nТема: Change Detection - стратегия OnPush и immutable паттерны для оптимизации рендеринга",
              "var_1": "Вызывай detectChanges() в каждом ngOnChanges без условий — так надежнее.",
              "var_2": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_3": "Оставь мутации объектов как есть — OnPush сам увидит изменения внутри вложенных полей.",
              "var_4": "Поставь setTimeout вокруг обновления, чтобы Angular «заметил» изменения.",
              "correct_position": 2,
              "correct_answer": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Производительность (CD, trackBy, bundle анализ)",
          "theme": "CDK Virtual Scroll - реализация виртуального скроллинга для больших списков и таблиц",
          "questions": [
            {
              "question": "[CDK Virtual Scroll] Какое утверждение наиболее корректно?",
              "var_1": "CDK Virtual Scroll работает только в IE11 и устарело.",
              "var_2": "CDK Virtual Scroll гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_3": "CDK Virtual Scroll заменяет необходимость тестирования и code review.",
              "var_4": "CDK Virtual Scroll: это подход/механизм, который применяется в контексте «Производительность (CD, trackBy, bundle анализ)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "CDK Virtual Scroll: это подход/механизм, который применяется в контексте «Производительность (CD, trackBy, bundle анализ)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[CDK Virtual Scroll] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: CDK Virtual Scroll - реализация виртуального скроллинга для больших списков и таблиц",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Использовать CDK Virtual Scroll по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать CDK Virtual Scroll по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Навыки проведения рефакторинга и code review",
          "theme": "Рефакторинг RxJS подписок - устранение memory leaks через switchMap и combineLatest",
          "questions": [
            {
              "question": "[Рефакторинг RxJS подписок] Выбери наиболее корректное утверждение.\n\nТема: Рефакторинг RxJS подписок - устранение memory leaks через switchMap и combineLatest",
              "var_1": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_2": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "var_3": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "var_4": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "correct_position": 1,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Рефакторинг RxJS подписок] Практика: выбери лучший вариант действия.\n\nТема: Рефакторинг RxJS подписок - устранение memory leaks через switchMap и combineLatest",
              "var_1": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "var_2": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "var_3": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "var_4": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "correct_position": 4,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Навыки проведения рефакторинга и code review",
          "theme": "Рефакторинг компонентной архитектуры - разделение на smart/dumb компоненты с выносом бизнес-логики в сервисы",
          "questions": [
            {
              "question": "[Рефакторинг компонентной архитектуры] Какое утверждение наиболее корректно?",
              "var_1": "Рефакторинг компонентной архитектуры заменяет необходимость тестирования и code review.",
              "var_2": "Рефакторинг компонентной архитектуры работает только в IE11 и устарело.",
              "var_3": "Рефакторинг компонентной архитектуры: это подход/механизм, который применяется в контексте «Навыки проведения рефакторинга и code review» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Рефакторинг компонентной архитектуры относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 3,
              "correct_answer": "Рефакторинг компонентной архитектуры: это подход/механизм, который применяется в контексте «Навыки проведения рефакторинга и code review» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Рефакторинг компонентной архитектуры] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Рефакторинг компонентной архитектуры - разделение на smart/dumb компоненты с выносом бизнес-логики в сервисы",
              "var_1": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_2": "Использовать Рефакторинг компонентной архитектуры по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 2,
              "correct_answer": "Использовать Рефакторинг компонентной архитектуры по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        }
      ]
    },
    "senior": {
      "themes": [
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "CSS архитектура - проектирование масштабируемой системы стилей для микрофронтенд приложений с изолированными scope",
          "questions": [
            {
              "question": "[CSS архитектура] Какое утверждение наиболее корректно?",
              "var_1": "CSS архитектура всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "CSS архитектура: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "CSS архитектура запрещено использовать вместе с TypeScript strict mode.",
              "var_4": "CSS архитектура работает только в IE11 и устарело.",
              "correct_position": 2,
              "correct_answer": "CSS архитектура: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[CSS архитектура] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: CSS архитектура - проектирование масштабируемой системы стилей для микрофронтенд приложений с изолированными scope",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Использовать CSS архитектура по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 2,
              "correct_answer": "Использовать CSS архитектура по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "HTML5 семантика - оптимизация DOM структуры для performance и accessibility в крупных Angular приложениях",
          "questions": [
            {
              "question": "[HTML5 семантика] Какое утверждение наиболее корректно?",
              "var_1": "HTML5 семантика используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_2": "HTML5 семантика: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "HTML5 семантика всегда ускоряет приложение независимо от контекста и реализации.",
              "var_4": "HTML5 семантика запрещено использовать вместе с TypeScript strict mode.",
              "correct_position": 2,
              "correct_answer": "HTML5 семантика: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[HTML5 семантика] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: HTML5 семантика - оптимизация DOM структуры для performance и accessibility в крупных Angular приложениях",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Использовать HTML5 семантика по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 3,
              "correct_answer": "Использовать HTML5 семантика по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "CSS Custom Properties - реализация динамической темизации и переменных для Module Federation архитектуры",
          "questions": [
            {
              "question": "[CSS Custom Properties] Какое утверждение наиболее корректно?",
              "var_1": "CSS Custom Properties всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "CSS Custom Properties: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "CSS Custom Properties заменяет необходимость тестирования и code review.",
              "var_4": "CSS Custom Properties запрещено использовать вместе с TypeScript strict mode.",
              "correct_position": 2,
              "correct_answer": "CSS Custom Properties: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[CSS Custom Properties] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: CSS Custom Properties - реализация динамической темизации и переменных для Module Federation архитектуры",
              "var_1": "Использовать CSS Custom Properties по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 1,
              "correct_answer": "Использовать CSS Custom Properties по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "Tailwind CSS оптимизация - tree-shaking неиспользуемых классов и минимизация bundle size через PurgeCSS конфигурацию",
          "questions": [
            {
              "question": "[Tailwind CSS оптимизация] Какое утверждение наиболее корректно?",
              "var_1": "Tailwind CSS оптимизация: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Tailwind CSS оптимизация используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Tailwind CSS оптимизация работает только в IE11 и устарело.",
              "var_4": "Tailwind CSS оптимизация относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 1,
              "correct_answer": "Tailwind CSS оптимизация: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Tailwind CSS оптимизация] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Tailwind CSS оптимизация - tree-shaking неиспользуемых классов и минимизация bundle size через PurgeCSS конфигурацию",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Использовать Tailwind CSS оптимизация по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 2,
              "correct_answer": "Использовать Tailwind CSS оптимизация по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "CSS Grid и Flexbox - построение сложных адаптивных layout систем с минимальным использованием медиа-запросов",
          "questions": [
            {
              "question": "[CSS Grid и Flexbox] Какое утверждение наиболее корректно?",
              "var_1": "CSS Grid и Flexbox относится только к стилям CSS и не применяется в логике приложения.",
              "var_2": "CSS Grid и Flexbox работает только в IE11 и устарело.",
              "var_3": "CSS Grid и Flexbox используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_4": "CSS Grid и Flexbox: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "CSS Grid и Flexbox: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[CSS Grid и Flexbox] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: CSS Grid и Flexbox - построение сложных адаптивных layout систем с минимальным использованием медиа-запросов",
              "var_1": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_2": "Использовать CSS Grid и Flexbox по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 2,
              "correct_answer": "Использовать CSS Grid и Flexbox по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "Critical CSS - извлечение и inline встраивание критических стилей для оптимизации First Contentful Paint",
          "questions": [
            {
              "question": "[Critical CSS] Какое утверждение наиболее корректно?",
              "var_1": "Critical CSS заменяет необходимость тестирования и code review.",
              "var_2": "Critical CSS работает только в IE11 и устарело.",
              "var_3": "Critical CSS гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_4": "Critical CSS: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Critical CSS: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Critical CSS] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Critical CSS - извлечение и inline встраивание критических стилей для оптимизации First Contentful Paint",
              "var_1": "Использовать Critical CSS по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 1,
              "correct_answer": "Использовать Critical CSS по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
          "theme": "Tailwind компонентная архитектура - создание переиспользуемых utility-паттернов и custom директив для Angular компонентов",
          "questions": [
            {
              "question": "[Tailwind компонентная архитектура] Какое утверждение наиболее корректно?",
              "var_1": "Tailwind компонентная архитектура: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Tailwind компонентная архитектура всегда ускоряет приложение независимо от контекста и реализации.",
              "var_3": "Tailwind компонентная архитектура используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_4": "Tailwind компонентная архитектура работает только в IE11 и устарело.",
              "correct_position": 1,
              "correct_answer": "Tailwind компонентная архитектура: это подход/механизм, который применяется в контексте «Знание HTML5, CSS + Tailwind, умение верстки» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Tailwind компонентная архитектура] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Tailwind компонентная архитектура - создание переиспользуемых utility-паттернов и custom директив для Angular компонентов",
              "var_1": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Использовать Tailwind компонентная архитектура по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Tailwind компонентная архитектура по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Event Loop и асинхронность - механизм работы микрозадач и макрозадач для оптимизации производительности Angular приложений",
          "questions": [
            {
              "question": "[Event Loop и асинхронность] Какое утверждение наиболее корректно?",
              "var_1": "Event Loop и асинхронность гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_2": "Event Loop и асинхронность: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Event Loop и асинхронность запрещено использовать вместе с TypeScript strict mode.",
              "var_4": "Event Loop и асинхронность используется только для серверного рендеринга и не влияет на клиентский код.",
              "correct_position": 2,
              "correct_answer": "Event Loop и асинхронность: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Event Loop и асинхронность] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Event Loop и асинхронность - механизм работы микрозадач и макрозадач для оптимизации производительности Angular приложений",
              "var_1": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Использовать Event Loop и асинхронность по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Event Loop и асинхронность по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Memory Management - профилирование утечек памяти через замыкания и event listeners в долгоживущих SPA",
          "questions": [
            {
              "question": "[Memory Management] Какое утверждение наиболее корректно?",
              "var_1": "Memory Management: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Memory Management запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "Memory Management всегда ускоряет приложение независимо от контекста и реализации.",
              "var_4": "Memory Management заменяет необходимость тестирования и code review.",
              "correct_position": 1,
              "correct_answer": "Memory Management: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Memory Management] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Memory Management - профилирование утечек памяти через замыкания и event listeners в долгоживущих SPA",
              "var_1": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_2": "Использовать Memory Management по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 2,
              "correct_answer": "Использовать Memory Management по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "JavaScript модульная система - различия ES modules и CommonJS для настройки tree-shaking и code splitting",
          "questions": [
            {
              "question": "[JavaScript модульная система] Какое утверждение наиболее корректно?",
              "var_1": "JavaScript модульная система всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "JavaScript модульная система заменяет необходимость тестирования и code review.",
              "var_3": "JavaScript модульная система запрещено использовать вместе с TypeScript strict mode.",
              "var_4": "JavaScript модульная система: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "JavaScript модульная система: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[JavaScript модульная система] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: JavaScript модульная система - различия ES modules и CommonJS для настройки tree-shaking и code splitting",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Использовать JavaScript модульная система по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать JavaScript модульная система по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Proxy и Reflect API - создание реактивных систем и interceptors для кастомных facade паттернов",
          "questions": [
            {
              "question": "[Proxy и Reflect API] Выбери наиболее корректное утверждение.\n\nТема: Proxy и Reflect API - создание реактивных систем и interceptors для кастомных facade паттернов",
              "var_1": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_2": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_3": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_4": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "correct_position": 1,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Proxy и Reflect API] Практика: выбери лучший вариант действия.\n\nТема: Proxy и Reflect API - создание реактивных систем и interceptors для кастомных facade паттернов",
              "var_1": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_2": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "var_3": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_4": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "correct_position": 3,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "WeakMap и WeakSet - управление кэшированием динамически загружаемых компонентов без утечек памяти",
          "questions": [
            {
              "question": "[WeakMap и WeakSet] Какое утверждение наиболее корректно?",
              "var_1": "WeakMap и WeakSet всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "WeakMap и WeakSet работает только в IE11 и устарело.",
              "var_3": "WeakMap и WeakSet: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "WeakMap и WeakSet запрещено использовать вместе с TypeScript strict mode.",
              "correct_position": 3,
              "correct_answer": "WeakMap и WeakSet: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[WeakMap и WeakSet] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: WeakMap и WeakSet - управление кэшированием динамически загружаемых компонентов без утечек памяти",
              "var_1": "Использовать WeakMap и WeakSet по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 1,
              "correct_answer": "Использовать WeakMap и WeakSet по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Generators и итераторы - реализация ленивой загрузки данных и пагинации в enterprise приложениях",
          "questions": [
            {
              "question": "[Generators и итераторы] Какое утверждение наиболее корректно?",
              "var_1": "Generators и итераторы всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "Generators и итераторы гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_3": "Generators и итераторы используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_4": "Generators и итераторы: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Generators и итераторы: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Generators и итераторы] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Generators и итераторы - реализация ленивой загрузки данных и пагинации в enterprise приложениях",
              "var_1": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Использовать Generators и итераторы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_4": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "correct_position": 3,
              "correct_answer": "Использовать Generators и итераторы по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования JavaScript",
          "theme": "Web Workers API - вынос тяжелых вычислений из основного потока для сохранения отзывчивости UI",
          "questions": [
            {
              "question": "[Web Workers API] Какое утверждение наиболее корректно?",
              "var_1": "Web Workers API всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "Web Workers API заменяет необходимость тестирования и code review.",
              "var_3": "Web Workers API: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Web Workers API относится только к стилям CSS и не применяется в логике приложения.",
              "correct_position": 3,
              "correct_answer": "Web Workers API: это подход/механизм, который применяется в контексте «Знание языка программирования JavaScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Web Workers API] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Web Workers API - вынос тяжелых вычислений из основного потока для сохранения отзывчивости UI",
              "var_1": "Использовать Web Workers API по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 1,
              "correct_answer": "Использовать Web Workers API по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "TypeScript Strict Mode - конфигурация и применение строгих проверок типов в Angular-приложениях",
          "questions": [
            {
              "question": "[TypeScript Strict Mode] Какое утверждение наиболее корректно?",
              "var_1": "TypeScript Strict Mode всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "TypeScript Strict Mode запрещено использовать вместе с TypeScript strict mode.",
              "var_3": "TypeScript Strict Mode: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "TypeScript Strict Mode заменяет необходимость тестирования и code review.",
              "correct_position": 3,
              "correct_answer": "TypeScript Strict Mode: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[TypeScript Strict Mode] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: TypeScript Strict Mode - конфигурация и применение строгих проверок типов в Angular-приложениях",
              "var_1": "Использовать TypeScript Strict Mode по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 1,
              "correct_answer": "Использовать TypeScript Strict Mode по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Generics и Type Constraints - создание переиспользуемых типобезопасных Angular компонентов и сервисов",
          "questions": [
            {
              "question": "[Generics и Type Constraints] Какое утверждение наиболее корректно?",
              "var_1": "Generics и Type Constraints заменяет необходимость тестирования и code review.",
              "var_2": "Generics и Type Constraints относится только к стилям CSS и не применяется в логике приложения.",
              "var_3": "Generics и Type Constraints используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_4": "Generics и Type Constraints: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Generics и Type Constraints: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Generics и Type Constraints] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Generics и Type Constraints - создание переиспользуемых типобезопасных Angular компонентов и сервисов",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Использовать Generics и Type Constraints по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Generics и Type Constraints по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Декораторы TypeScript - разработка custom декораторов для метаданных и аспектно-ориентированного программирования в Angular",
          "questions": [
            {
              "question": "[Декораторы TypeScript] Какое утверждение наиболее корректно?",
              "var_1": "Декораторы TypeScript всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "Декораторы TypeScript гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_3": "Декораторы TypeScript: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Декораторы TypeScript заменяет необходимость тестирования и code review.",
              "correct_position": 3,
              "correct_answer": "Декораторы TypeScript: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Декораторы TypeScript] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Декораторы TypeScript - разработка custom декораторов для метаданных и аспектно-ориентированного программирования в Angular",
              "var_1": "Использовать Декораторы TypeScript по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_4": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "correct_position": 1,
              "correct_answer": "Использовать Декораторы TypeScript по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Type Guards и Narrowing - реализация типобезопасной обработки данных RxJS потоков в Angular приложениях",
          "questions": [
            {
              "question": "[Type Guards и Narrowing] Выбери наиболее корректное утверждение.\n\nТема: Type Guards и Narrowing - реализация типобезопасной обработки данных RxJS потоков в Angular приложениях",
              "var_1": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_2": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "var_3": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "var_4": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "correct_position": 1,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Type Guards и Narrowing] Практика: выбери лучший вариант действия.\n\nТема: Type Guards и Narrowing - реализация типобезопасной обработки данных RxJS потоков в Angular приложениях",
              "var_1": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_2": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "var_3": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "var_4": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "correct_position": 1,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Utility Types и Type Manipulation - построение сложных типовых систем для State Management и API моделей",
          "questions": [
            {
              "question": "[Utility Types и Type Manipulation] Какое утверждение наиболее корректно?",
              "var_1": "Utility Types и Type Manipulation: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Utility Types и Type Manipulation относится только к стилям CSS и не применяется в логике приложения.",
              "var_3": "Utility Types и Type Manipulation гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_4": "Utility Types и Type Manipulation всегда ускоряет приложение независимо от контекста и реализации.",
              "correct_position": 1,
              "correct_answer": "Utility Types и Type Manipulation: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Utility Types и Type Manipulation] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Utility Types и Type Manipulation - построение сложных типовых систем для State Management и API моделей",
              "var_1": "Использовать Utility Types и Type Manipulation по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 1,
              "correct_answer": "Использовать Utility Types и Type Manipulation по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "TypeScript Compiler API - автоматизация code review и статический анализ кода для соблюдения архитектурных паттернов",
          "questions": [
            {
              "question": "[TypeScript Compiler API] Какое утверждение наиболее корректно?",
              "var_1": "TypeScript Compiler API всегда ускоряет приложение независимо от контекста и реализации.",
              "var_2": "TypeScript Compiler API используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "TypeScript Compiler API: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "TypeScript Compiler API работает только в IE11 и устарело.",
              "correct_position": 3,
              "correct_answer": "TypeScript Compiler API: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[TypeScript Compiler API] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: TypeScript Compiler API - автоматизация code review и статический анализ кода для соблюдения архитектурных паттернов",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Использовать TypeScript Compiler API по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать TypeScript Compiler API по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Знание языка программирования TypeScript",
          "theme": "Intersection и Union Types - моделирование полиморфных компонентов и типизация динамических форм в Angular",
          "questions": [
            {
              "question": "[Intersection и Union Types] Какое утверждение наиболее корректно?",
              "var_1": "Intersection и Union Types работает только в IE11 и устарело.",
              "var_2": "Intersection и Union Types: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Intersection и Union Types всегда ускоряет приложение независимо от контекста и реализации.",
              "var_4": "Intersection и Union Types запрещено использовать вместе с TypeScript strict mode.",
              "correct_position": 2,
              "correct_answer": "Intersection и Union Types: это подход/механизм, который применяется в контексте «Знание языка программирования TypeScript» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Intersection и Union Types] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Intersection и Union Types - моделирование полиморфных компонентов и типизация динамических форм в Angular",
              "var_1": "Использовать Intersection и Union Types по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 1,
              "correct_answer": "Использовать Intersection и Union Types по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "ООП - применение принципов SOLID при проектировании архитектуры Angular-сервисов и модулей",
          "questions": [
            {
              "question": "[ООП] Какое утверждение наиболее корректно?",
              "var_1": "ООП заменяет необходимость тестирования и code review.",
              "var_2": "ООП: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "ООП гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_4": "ООП запрещено использовать вместе с TypeScript strict mode.",
              "correct_position": 2,
              "correct_answer": "ООП: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[ООП] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: ООП - применение принципов SOLID при проектировании архитектуры Angular-сервисов и модулей",
              "var_1": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_2": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Использовать ООП по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать ООП по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "Паттерны проектирования - реализация Singleton, Factory и Observer в Angular DI и RxJS-потоках",
          "questions": [
            {
              "question": "[Паттерны проектирования] Выбери наиболее корректное утверждение.\n\nТема: Паттерны проектирования - реализация Singleton, Factory и Observer в Angular DI и RxJS-потоках",
              "var_1": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_2": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "var_3": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "var_4": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "correct_position": 1,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Паттерны проектирования] Практика: выбери лучший вариант действия.\n\nТема: Паттерны проектирования - реализация Singleton, Factory и Observer в Angular DI и RxJS-потоках",
              "var_1": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "var_2": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "var_3": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "var_4": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "correct_position": 4,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "Инкапсуляция и абстракция - проектирование публичного API переиспользуемой UI-библиотеки компонентов",
          "questions": [
            {
              "question": "[Инкапсуляция и абстракция] Какое утверждение наиболее корректно?",
              "var_1": "Инкапсуляция и абстракция работает только в IE11 и устарело.",
              "var_2": "Инкапсуляция и абстракция относится только к стилям CSS и не применяется в логике приложения.",
              "var_3": "Инкапсуляция и абстракция гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_4": "Инкапсуляция и абстракция: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Инкапсуляция и абстракция: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Инкапсуляция и абстракция] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Инкапсуляция и абстракция - проектирование публичного API переиспользуемой UI-библиотеки компонентов",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Использовать Инкапсуляция и абстракция по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 2,
              "correct_answer": "Использовать Инкапсуляция и абстракция по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Базовая теория программирования, ООП",
          "theme": "Композиция vs наследование - выбор стратегии переиспользования кода в Angular-компонентах и директивах",
          "questions": [
            {
              "question": "[Композиция vs наследование] Какое утверждение наиболее корректно?",
              "var_1": "Композиция vs наследование заменяет необходимость тестирования и code review.",
              "var_2": "Композиция vs наследование всегда ускоряет приложение независимо от контекста и реализации.",
              "var_3": "Композиция vs наследование работает только в IE11 и устарело.",
              "var_4": "Композиция vs наследование: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Композиция vs наследование: это подход/механизм, который применяется в контексте «Базовая теория программирования, ООП» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Композиция vs наследование] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Композиция vs наследование - выбор стратегии переиспользования кода в Angular-компонентах и директивах",
              "var_1": "Использовать Композиция vs наследование по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 1,
              "correct_answer": "Использовать Композиция vs наследование по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Знание Git",
          "theme": "Git bisect - поиск коммита, вызвавшего регрессию в Angular-компонентах",
          "questions": [
            {
              "question": "[Git bisect] Выбери наиболее корректное утверждение.\n\nТема: Git bisect - поиск коммита, вызвавшего регрессию в Angular-компонентах",
              "var_1": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_2": "bisect нужен только для конфликтов слияния, а не для поиска регрессий.",
              "var_3": "reflog показывает только ветки на удаленном репозитории.",
              "var_4": "rebase безопаснее merge, потому что никогда не переписывает историю.",
              "correct_position": 1,
              "correct_answer": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Git bisect] Практика: выбери лучший вариант действия.\n\nТема: Git bisect - поиск коммита, вызвавшего регрессию в Angular-компонентах",
              "var_1": "Если потерял коммит, единственный путь — заново написать код.",
              "var_2": "Чтобы решить конфликт, просто удали конфликтные файлы.",
              "var_3": "Всегда делай force-push в main после rebase — так история будет красивее.",
              "var_4": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "correct_position": 4,
              "correct_answer": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Знание Git",
          "theme": "Git reflog - восстановление потерянных коммитов и веток после неудачного rebase",
          "questions": [
            {
              "question": "[Git reflog] Выбери наиболее корректное утверждение.\n\nТема: Git reflog - восстановление потерянных коммитов и веток после неудачного rebase",
              "var_1": "reflog показывает только ветки на удаленном репозитории.",
              "var_2": "bisect нужен только для конфликтов слияния, а не для поиска регрессий.",
              "var_3": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_4": "rebase безопаснее merge, потому что никогда не переписывает историю.",
              "correct_position": 3,
              "correct_answer": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Git reflog] Практика: выбери лучший вариант действия.\n\nТема: Git reflog - восстановление потерянных коммитов и веток после неудачного rebase",
              "var_1": "Если потерял коммит, единственный путь — заново написать код.",
              "var_2": "Всегда делай force-push в main после rebase — так история будет красивее.",
              "var_3": "Чтобы решить конфликт, просто удали конфликтные файлы.",
              "var_4": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "correct_position": 4,
              "correct_answer": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Знание Git",
          "theme": "Разрешение конфликтов слияния - стратегии для интеграции крупных feature-веток с изменениями в Angular-модулях",
          "questions": [
            {
              "question": "[Разрешение конфликтов слияния] Выбери наиболее корректное утверждение.\n\nТема: Разрешение конфликтов слияния - стратегии для интеграции крупных feature-веток с изменениями в Angular-модулях",
              "var_1": "rebase безопаснее merge, потому что никогда не переписывает историю.",
              "var_2": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_3": "bisect нужен только для конфликтов слияния, а не для поиска регрессий.",
              "var_4": "reflog показывает только ветки на удаленном репозитории.",
              "correct_position": 2,
              "correct_answer": "Git хранит историю как граф коммитов; rebase переписывает историю, merge сохраняет ветвление; reflog помогает восстановить ссылки после опасных операций.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Разрешение конфликтов слияния] Практика: выбери лучший вариант действия.\n\nТема: Разрешение конфликтов слияния - стратегии для интеграции крупных feature-веток с изменениями в Angular-модулях",
              "var_1": "Чтобы решить конфликт, просто удали конфликтные файлы.",
              "var_2": "Всегда делай force-push в main после rebase — так история будет красивее.",
              "var_3": "Если потерял коммит, единственный путь — заново написать код.",
              "var_4": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "correct_position": 4,
              "correct_answer": "Перед PR можно сделать интерактивный rebase для аккуратной истории; при ошибке после rebase восстановись через reflog, а регрессию ищи через bisect.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Формы (Template/Reactive, валидаторы)",
          "theme": "Reactive Forms - архитектура динамических форм на основе JSON-конфигурации с условным рендерингом",
          "questions": [
            {
              "question": "[Reactive Forms] Выбери наиболее корректное утверждение.\n\nТема: Reactive Forms - архитектура динамических форм на основе JSON-конфигурации с условным рендерингом",
              "var_1": "FormArray нельзя использовать внутри FormGroup.",
              "var_2": "Reactive Forms не поддерживают асинхронную валидацию.",
              "var_3": "Template-driven формы быстрее и безопаснее Reactive, поэтому их всегда выбирают в enterprise.",
              "var_4": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "correct_position": 4,
              "correct_answer": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Reactive Forms] Практика: выбери лучший вариант действия.\n\nТема: Reactive Forms - архитектура динамических форм на основе JSON-конфигурации с условным рендерингом",
              "var_1": "Создай отдельный FormGroup на каждый input, чтобы было «модульно».",
              "var_2": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_3": "Для совпадения паролей сравнивай значения прямо в шаблоне через (input) и не трогай валидаторы.",
              "var_4": "Проверяй уникальность email только на submit, без async validator.",
              "correct_position": 2,
              "correct_answer": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Формы (Template/Reactive, валидаторы)",
          "theme": "Custom валидаторы - проектирование типизированной библиотеки асинхронных и кросс-полевых валидаторов",
          "questions": [
            {
              "question": "[Custom валидаторы] Выбери наиболее корректное утверждение.\n\nТема: Custom валидаторы - проектирование типизированной библиотеки асинхронных и кросс-полевых валидаторов",
              "var_1": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_2": "Reactive Forms не поддерживают асинхронную валидацию.",
              "var_3": "Template-driven формы быстрее и безопаснее Reactive, поэтому их всегда выбирают в enterprise.",
              "var_4": "FormArray нельзя использовать внутри FormGroup.",
              "correct_position": 1,
              "correct_answer": "Reactive Forms строятся в коде через FormControl/FormGroup/FormArray и удобны для сложной логики и тестирования; Template-driven опираются на NgModel в шаблоне и подходят для простых форм.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Custom валидаторы] Практика: выбери лучший вариант действия.\n\nТема: Custom валидаторы - проектирование типизированной библиотеки асинхронных и кросс-полевых валидаторов",
              "var_1": "Для совпадения паролей сравнивай значения прямо в шаблоне через (input) и не трогай валидаторы.",
              "var_2": "Создай отдельный FormGroup на каждый input, чтобы было «модульно».",
              "var_3": "Проверяй уникальность email только на submit, без async validator.",
              "var_4": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "correct_position": 4,
              "correct_answer": "Для динамического списка полей используй FormArray; для кросс-полевой проверки (например, password/confirm) — валидатор на уровне FormGroup.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
          "theme": "Token Security - реализация advanced механизмов silent refresh и secure storage с защитой от XSS-based token theft",
          "questions": [
            {
              "question": "[Token Security] Выбери наиболее корректное утверждение.\n\nТема: Token Security - реализация advanced механизмов silent refresh и secure storage с защитой от XSS-based token theft",
              "var_1": "Хранить токен в URL безопаснее, потому что его легко дебажить.",
              "var_2": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_3": "Angular не имеет защиты от XSS, поэтому нужно всегда использовать innerHTML и ручную фильтрацию.",
              "var_4": "CSP полностью заменяет санитизацию, поэтому DomSanitizer больше не нужен.",
              "correct_position": 2,
              "correct_answer": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Token Security] Практика: выбери лучший вариант действия.\n\nТема: Token Security - реализация advanced механизмов silent refresh и secure storage с защитой от XSS-based token theft",
              "var_1": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "var_2": "Отключи санитизацию в Angular настройках — это ускорит приложение.",
              "var_3": "Всегда используй bypassSecurityTrustHtml для удобства отображения.",
              "var_4": "Передавай токен в query параметре при каждом запросе.",
              "correct_position": 1,
              "correct_answer": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
          "theme": "Angular Security Context - разработка кастомных санитайзеров и bypass-механизмов для защиты от DOM-based XSS и prototype pollution",
          "questions": [
            {
              "question": "[Angular Security Context] Выбери наиболее корректное утверждение.\n\nТема: Angular Security Context - разработка кастомных санитайзеров и bypass-механизмов для защиты от DOM-based XSS и prototype pollution",
              "var_1": "Angular не имеет защиты от XSS, поэтому нужно всегда использовать innerHTML и ручную фильтрацию.",
              "var_2": "Хранить токен в URL безопаснее, потому что его легко дебажить.",
              "var_3": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_4": "CSP полностью заменяет санитизацию, поэтому DomSanitizer больше не нужен.",
              "correct_position": 3,
              "correct_answer": "В Angular защита от XSS основана на контекстной санитизации; опасно использовать bypassSecurityTrust* без строгого контроля. CSP помогает ограничить источники скриптов. Токены нельзя утекать в URL/логи.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Angular Security Context] Практика: выбери лучший вариант действия.\n\nТема: Angular Security Context - разработка кастомных санитайзеров и bypass-механизмов для защиты от DOM-based XSS и prototype pollution",
              "var_1": "Передавай токен в query параметре при каждом запросе.",
              "var_2": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "var_3": "Всегда используй bypassSecurityTrustHtml для удобства отображения.",
              "var_4": "Отключи санитизацию в Angular настройках — это ускорит приложение.",
              "correct_position": 2,
              "correct_answer": "Не вставляй пользовательский HTML напрямую; используй безопасную интерполяцию/санитизацию. Токен добавляй через interceptor и храни так, чтобы минимизировать риск XSS (избегай небезопасных мест).",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Состояние приложения (signals services)",
          "theme": "Архитектура signal-сервисов - проектирование глобального state management с разделением на feature и shared слои",
          "questions": [
            {
              "question": "[Архитектура signal] Какое утверждение наиболее корректно?",
              "var_1": "Архитектура signal используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_2": "Архитектура signal всегда ускоряет приложение независимо от контекста и реализации.",
              "var_3": "Архитектура signal относится только к стилям CSS и не применяется в логике приложения.",
              "var_4": "Архитектура signal: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "correct_position": 4,
              "correct_answer": "Архитектура signal: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            },
            {
              "question": "[Архитектура signal] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Архитектура signal-сервисов - проектирование глобального state management с разделением на feature и shared слои",
              "var_1": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_2": "Использовать Архитектура signal по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 2,
              "correct_answer": "Использовать Архитектура signal по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Состояние приложения (signals services)",
          "theme": "Оптимизация производительности signals - применение untracked, batching и стратегий минимизации перерисовок",
          "questions": [
            {
              "question": "[Оптимизация производительности signals] Какое утверждение наиболее корректно?",
              "var_1": "Оптимизация производительности signals работает только в IE11 и устарело.",
              "var_2": "Оптимизация производительности signals гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_3": "Оптимизация производительности signals: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Оптимизация производительности signals используется только для серверного рендеринга и не влияет на клиентский код.",
              "correct_position": 3,
              "correct_answer": "Оптимизация производительности signals: это подход/механизм, который применяется в контексте «Состояние приложения (signals services)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Оптимизация производительности signals] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Оптимизация производительности signals - применение untracked, batching и стратегий минимизации перерисовок",
              "var_1": "Использовать Оптимизация производительности signals по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "correct_position": 1,
              "correct_answer": "Использовать Оптимизация производительности signals по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "HTTP/интерцепторы/типизация API",
          "theme": "HTTP Interceptors - реализация цепочки интерцепторов для retry logic, error handling и request/response transformation с типизацией",
          "questions": [
            {
              "question": "[HTTP Interceptors] Выбери наиболее корректное утверждение.\n\nТема: HTTP Interceptors - реализация цепочки интерцепторов для retry logic, error handling и request/response transformation с типизацией",
              "var_1": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_2": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_3": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_4": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "correct_position": 3,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[HTTP Interceptors] Практика: выбери лучший вариант действия.\n\nТема: HTTP Interceptors - реализация цепочки интерцепторов для retry logic, error handling и request/response transformation с типизацией",
              "var_1": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_2": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "var_3": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_4": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "correct_position": 4,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "HTTP/интерцепторы/типизация API",
          "theme": "Request Deduplication и Caching - имплементация механизмов дедупликации параллельных запросов через RxJS shareReplay и кеширования с TTL стратегиями",
          "questions": [
            {
              "question": "[Request Deduplication и Caching] Выбери наиболее корректное утверждение.\n\nТема: Request Deduplication и Caching - имплементация механизмов дедупликации параллельных запросов через RxJS shareReplay и кеширования с TTL стратегиями",
              "var_1": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_2": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_3": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_4": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "correct_position": 4,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            },
            {
              "question": "[Request Deduplication и Caching] Практика: выбери лучший вариант действия.\n\nТема: Request Deduplication и Caching - имплементация механизмов дедупликации параллельных запросов через RxJS shareReplay и кеширования с TTL стратегиями",
              "var_1": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_2": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_3": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_4": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "correct_position": 2,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Роутинг (standalone, guards, resolvers)",
          "theme": "Custom PreloadingStrategy - реализация адаптивной загрузки модулей с учетом Network Information API и приоритетов маршрутов",
          "questions": [
            {
              "question": "[Custom PreloadingStrategy] Выбери наиболее корректное утверждение.\n\nТема: Custom PreloadingStrategy - реализация адаптивной загрузки модулей с учетом Network Information API и приоритетов маршрутов",
              "var_1": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_2": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_3": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_4": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "correct_position": 2,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Custom PreloadingStrategy] Практика: выбери лучший вариант действия.\n\nТема: Custom PreloadingStrategy - реализация адаптивной загрузки модулей с учетом Network Information API и приоритетов маршрутов",
              "var_1": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_2": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_3": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_4": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "correct_position": 4,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Роутинг (standalone, guards, resolvers)",
          "theme": "Guards система - построение цепочки функциональных guards с кешированием результатов и обработкой асинхронных зависимостей",
          "questions": [
            {
              "question": "[Guards система] Выбери наиболее корректное утверждение.\n\nТема: Guards система - построение цепочки функциональных guards с кешированием результатов и обработкой асинхронных зависимостей",
              "var_1": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_2": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_3": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_4": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "correct_position": 1,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Guards система] Практика: выбери лучший вариант действия.\n\nТема: Guards система - построение цепочки функциональных guards с кешированием результатов и обработкой асинхронных зависимостей",
              "var_1": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_2": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_3": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_4": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "correct_position": 1,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "RxJS (операторы, пайплайны, управление подписками)",
          "theme": "Операторы управления конкурентностью - стратегии обработки параллельных HTTP-запросов через switchMap, mergeMap, exhaustMap и concatMap",
          "questions": [
            {
              "question": "[Операторы управления конкурентностью] Выбери наиболее корректное утверждение.\n\nТема: Операторы управления конкурентностью - стратегии обработки параллельных HTTP-запросов через switchMap, mergeMap, exhaustMap и concatMap",
              "var_1": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_2": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_3": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_4": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "correct_position": 2,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Операторы управления конкурентностью] Практика: выбери лучший вариант действия.\n\nТема: Операторы управления конкурентностью - стратегии обработки параллельных HTTP-запросов через switchMap, mergeMap, exhaustMap и concatMap",
              "var_1": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_2": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_3": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_4": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "correct_position": 1,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "RxJS (операторы, пайплайны, управление подписками)",
          "theme": "Управление подписками - паттерны автоматической отписки через takeUntil, takeWhile и кастомные операторы для предотвращения memory leaks",
          "questions": [
            {
              "question": "[Управление подписками] Выбери наиболее корректное утверждение.\n\nТема: Управление подписками - паттерны автоматической отписки через takeUntil, takeWhile и кастомные операторы для предотвращения memory leaks",
              "var_1": "switchMap объединяет все запросы параллельно и не отменяет предыдущие.",
              "var_2": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_3": "Observable выполняется один раз как Promise и не может эмитить несколько значений.",
              "var_4": "shareReplay всегда безопасен и никогда не приводит к утечкам памяти.",
              "correct_position": 2,
              "correct_answer": "RxJS — библиотека реактивных потоков: Observable описывает поток данных во времени; операторы (map/filter/switchMap и т.д.) позволяют трансформировать и управлять подписками.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Управление подписками] Практика: выбери лучший вариант действия.\n\nТема: Управление подписками - паттерны автоматической отписки через takeUntil, takeWhile и кастомные операторы для предотвращения memory leaks",
              "var_1": "Подписывайся в каждом ngOnChanges и никогда не отписывайся — Angular сам очистит.",
              "var_2": "Используй mergeMap для поиска по вводу — так ничего не отменяется и будет «точнее».",
              "var_3": "Сделай кеширование через глобальную переменную без TTL/инвалидации.",
              "var_4": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "correct_position": 4,
              "correct_answer": "Для запросов по вводу используй debounceTime + distinctUntilChanged + switchMap; для предотвращения утечек — takeUntil/DestroyRef или async pipe.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Понимание принципов работы сетевых протоколов, знание HTTP",
          "theme": "HTTP кеширование - стратегии реализации client-side кеша с использованием Cache-Control, ETag и IndexedDB для оптимизации повторных запросов",
          "questions": [
            {
              "question": "[HTTP кеширование] Выбери наиболее корректное утверждение.\n\nТема: HTTP кеширование - стратегии реализации client-side кеша с использованием Cache-Control, ETag и IndexedDB для оптимизации повторных запросов",
              "var_1": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_2": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "var_3": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_4": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "correct_position": 3,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[HTTP кеширование] Практика: выбери лучший вариант действия.\n\nТема: HTTP кеширование - стратегии реализации client-side кеша с использованием Cache-Control, ETag и IndexedDB для оптимизации повторных запросов",
              "var_1": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_2": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_3": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_4": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "correct_position": 1,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Понимание принципов работы сетевых протоколов, знание HTTP",
          "theme": "HTTP retry и error handling - проектирование backoff стратегий с экспоненциальной задержкой и circuit breaker паттерна для обработки временных сбоев сети",
          "questions": [
            {
              "question": "[HTTP retry и error handling] Выбери наиболее корректное утверждение.\n\nТема: HTTP retry и error handling - проектирование backoff стратегий с экспоненциальной задержкой и circuit breaker паттерна для обработки временных сбоев сети",
              "var_1": "HttpClient всегда делает запрос синхронно, поэтому можно сразу читать res.body после вызова.",
              "var_2": "Чтобы типизировать ответы, в Angular нужно использовать any — иначе HttpClient ломается.",
              "var_3": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_4": "Интерцепторы работают только для fetch, но не для XHR, поэтому в браузере бесполезны.",
              "correct_position": 3,
              "correct_answer": "HttpClient в Angular возвращает Observable; интерцепторы позволяют централизованно модифицировать запросы/ответы (например, добавить токен, логирование, обработку ошибок) и должны быть чистыми и предсказуемыми.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[HTTP retry и error handling] Практика: выбери лучший вариант действия.\n\nТема: HTTP retry и error handling - проектирование backoff стратегий с экспоненциальной задержкой и circuit breaker паттерна для обработки временных сбоев сети",
              "var_1": "Храни токен в localStorage и вставляй его в URL как query параметр — так проще.",
              "var_2": "Добавляй токен вручную в каждом сервисе, чтобы интерцепторы не «мешали» тестам.",
              "var_3": "При 401 всегда просто повторяй тот же запрос в цикле, пока не пройдет.",
              "var_4": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "correct_position": 4,
              "correct_answer": "Добавь HTTP interceptor, который добавляет Authorization: Bearer <token> и корректно обрабатывает 401 (например, через refresh или logout) без бесконечных циклов запросов.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Signals API (signal/computed/effect)",
          "theme": "Computed signals - оптимизация графа зависимостей для минимизации пересчётов в real-time дашбордах",
          "questions": [
            {
              "question": "[Computed signals] Какое утверждение наиболее корректно?",
              "var_1": "Computed signals: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_2": "Computed signals используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Computed signals относится только к стилям CSS и не применяется в логике приложения.",
              "var_4": "Computed signals заменяет необходимость тестирования и code review.",
              "correct_position": 1,
              "correct_answer": "Computed signals: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Computed signals] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Computed signals - оптимизация графа зависимостей для минимизации пересчётов в real-time дашбордах",
              "var_1": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "var_2": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Использовать Computed signals по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "correct_position": 4,
              "correct_answer": "Использовать Computed signals по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              }
            }
          ]
        },
        {
          "competency": "Signals API (signal/computed/effect)",
          "theme": "Signal equality functions - создание custom comparators для предотвращения лишних обновлений в сложных структурах данных",
          "questions": [
            {
              "question": "[Signal equality functions] Какое утверждение наиболее корректно?",
              "var_1": "Signal equality functions заменяет необходимость тестирования и code review.",
              "var_2": "Signal equality functions: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Signal equality functions гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_4": "Signal equality functions работает только в IE11 и устарело.",
              "correct_position": 2,
              "correct_answer": "Signal equality functions: это подход/механизм, который применяется в контексте «Signals API (signal/computed/effect)» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Signal equality functions] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Signal equality functions - создание custom comparators для предотвращения лишних обновлений в сложных структурах данных",
              "var_1": "Использовать Signal equality functions по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_3": "Сделать всё в setTimeout, чтобы «починить асинхронность», не понимая причин.",
              "var_4": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "correct_position": 1,
              "correct_answer": "Использовать Signal equality functions по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for, OnPush)",
          "theme": "Change Detection Strategy - проектирование стратегий OnPush и ручного управления detach/reattach для оптимизации рендеринга в enterprise-приложениях",
          "questions": [
            {
              "question": "[Change Detection Strategy] Выбери наиболее корректное утверждение.\n\nТема: Change Detection Strategy - проектирование стратегий OnPush и ручного управления detach/reattach для оптимизации рендеринга в enterprise-приложениях",
              "var_1": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_2": "OnPush отключает работу async pipe и RxJS подписок.",
              "var_3": "OnPush заставляет Angular пересчитывать компонент чаще, чем Default, поэтому всегда ускоряет приложение.",
              "var_4": "OnPush автоматически делает все объекты immutable и предотвращает мутации.",
              "correct_position": 1,
              "correct_answer": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Change Detection Strategy] Практика: выбери лучший вариант действия.\n\nТема: Change Detection Strategy - проектирование стратегий OnPush и ручного управления detach/reattach для оптимизации рендеринга в enterprise-приложениях",
              "var_1": "Поставь setTimeout вокруг обновления, чтобы Angular «заметил» изменения.",
              "var_2": "Оставь мутации объектов как есть — OnPush сам увидит изменения внутри вложенных полей.",
              "var_3": "Вызывай detectChanges() в каждом ngOnChanges без условий — так надежнее.",
              "var_4": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "correct_position": 4,
              "correct_answer": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for, OnPush)",
          "theme": "Жизненный цикл компонентов - глубокое использование хуков для управления динамической композицией через ViewContainerRef и ComponentRef",
          "questions": [
            {
              "question": "[Жизненный цикл компонентов] Выбери наиболее корректное утверждение.\n\nТема: Жизненный цикл компонентов - глубокое использование хуков для управления динамической композицией через ViewContainerRef и ComponentRef",
              "var_1": "OnPush заставляет Angular пересчитывать компонент чаще, чем Default, поэтому всегда ускоряет приложение.",
              "var_2": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_3": "OnPush отключает работу async pipe и RxJS подписок.",
              "var_4": "OnPush автоматически делает все объекты immutable и предотвращает мутации.",
              "correct_position": 2,
              "correct_answer": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Жизненный цикл компонентов] Практика: выбери лучший вариант действия.\n\nТема: Жизненный цикл компонентов - глубокое использование хуков для управления динамической композицией через ViewContainerRef и ComponentRef",
              "var_1": "Вызывай detectChanges() в каждом ngOnChanges без условий — так надежнее.",
              "var_2": "Поставь setTimeout вокруг обновления, чтобы Angular «заметил» изменения.",
              "var_3": "Оставь мутации объектов как есть — OnPush сам увидит изменения внутри вложенных полей.",
              "var_4": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "correct_position": 4,
              "correct_answer": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              }
            }
          ]
        },
        {
          "competency": "Архитектура Angular (DI, standalone)",
          "theme": "Dependency Injection - стратегии миграции NgModule-провайдеров на standalone-архитектуру с сохранением singleton-поведения",
          "questions": [
            {
              "question": "[Dependency Injection] Выбери наиболее корректное утверждение.\n\nТема: Dependency Injection - стратегии миграции NgModule-провайдеров на standalone-архитектуру с сохранением singleton-поведения",
              "var_1": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "var_2": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_3": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_4": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "correct_position": 3,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Dependency Injection] Практика: выбери лучший вариант действия.\n\nТема: Dependency Injection - стратегии миграции NgModule-провайдеров на standalone-архитектуру с сохранением singleton-поведения",
              "var_1": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_2": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_3": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_4": "Используй window.location вместо Router.navigate, так надёжнее.",
              "correct_position": 3,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Архитектура Angular (DI, standalone)",
          "theme": "Tree-shaking оптимизация - анализ и рефакторинг providedIn конфигураций для минимизации bundle size",
          "questions": [
            {
              "question": "[Tree] Выбери наиболее корректное утверждение.\n\nТема: Tree-shaking оптимизация - анализ и рефакторинг providedIn конфигураций для минимизации bundle size",
              "var_1": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_2": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "var_3": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_4": "Lazy loading невозможно использовать со standalone компонентами.",
              "correct_position": 3,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Tree] Практика: выбери лучший вариант действия.\n\nТема: Tree-shaking оптимизация - анализ и рефакторинг providedIn конфигураций для минимизации bundle size",
              "var_1": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_2": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_3": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_4": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "correct_position": 1,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Angular CLI/сборка/конфиги",
          "theme": "Custom Schematics - разработка генераторов кода с архитектурными шаблонами и валидацией",
          "questions": [
            {
              "question": "[Custom Schematics] Какое утверждение наиболее корректно?",
              "var_1": "Custom Schematics гарантирует автоматическое исправление ошибок без участия разработчика.",
              "var_2": "Custom Schematics: это подход/механизм, который применяется в контексте «Angular CLI/сборка/конфиги» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_3": "Custom Schematics относится только к стилям CSS и не применяется в логике приложения.",
              "var_4": "Custom Schematics всегда ускоряет приложение независимо от контекста и реализации.",
              "correct_position": 2,
              "correct_answer": "Custom Schematics: это подход/механизм, который применяется в контексте «Angular CLI/сборка/конфиги» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Custom Schematics] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Custom Schematics - разработка генераторов кода с архитектурными шаблонами и валидацией",
              "var_1": "Использовать Custom Schematics по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_2": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_3": "Отключить проверки безопасности/санитизацию ради удобства.",
              "var_4": "Использовать глобальную переменную, чтобы «быстрее», игнорируя инкапсуляцию и жизненный цикл.",
              "correct_position": 1,
              "correct_answer": "Использовать Custom Schematics по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Angular CLI/сборка/конфиги",
          "theme": "Module Federation - конфигурация динамической загрузки микрофронтендов и shared dependencies",
          "questions": [
            {
              "question": "[Module Federation] Какое утверждение наиболее корректно?",
              "var_1": "Module Federation относится только к стилям CSS и не применяется в логике приложения.",
              "var_2": "Module Federation используется только для серверного рендеринга и не влияет на клиентский код.",
              "var_3": "Module Federation: это подход/механизм, который применяется в контексте «Angular CLI/сборка/конфиги» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_4": "Module Federation запрещено использовать вместе с TypeScript strict mode.",
              "correct_position": 3,
              "correct_answer": "Module Federation: это подход/механизм, который применяется в контексте «Angular CLI/сборка/конфиги» и имеет ограничения; важно понимать условия, при которых он работает корректно.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_3_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            },
            {
              "question": "[Module Federation] Практика: что будет лучшим решением в указанной ситуации?\n\nТема: Module Federation - конфигурация динамической загрузки микрофронтендов и shared dependencies",
              "var_1": "Выбрать вариант, который выглядит короче, даже если он нарушает типизацию и обработку ошибок.",
              "var_2": "Использовать Module Federation по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_3": "Обновлять DOM напрямую через innerHTML вместо шаблона/привязок.",
              "var_4": "Отключить проверки безопасности/санитизацию ради удобства.",
              "correct_position": 2,
              "correct_answer": "Использовать Module Federation по назначению: соблюсти контракт, обработать крайние случаи и не ломать безопасность/типизацию.",
              "var_1_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_2_info": {
                "reason": "Это соответствует назначению темы и не содержит ложных обещаний «всегда/автоматически», учитывает ограничения и контекст."
              },
              "var_3_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              },
              "var_4_info": {
                "reason": "Звучит правдоподобно, но это либо слишком обобщённо, либо нарушает базовые принципы (безопасность/типизация/контекст применения)."
              }
            }
          ]
        },
        {
          "competency": "Производительность (CD, trackBy, bundle анализ)",
          "theme": "Change Detection стратегии - архитектурный рефакторинг legacy приложений с массовым внедрением OnPush",
          "questions": [
            {
              "question": "[Change Detection стратегии] Выбери наиболее корректное утверждение.\n\nТема: Change Detection стратегии - архитектурный рефакторинг legacy приложений с массовым внедрением OnPush",
              "var_1": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_2": "OnPush отключает работу async pipe и RxJS подписок.",
              "var_3": "OnPush заставляет Angular пересчитывать компонент чаще, чем Default, поэтому всегда ускоряет приложение.",
              "var_4": "OnPush автоматически делает все объекты immutable и предотвращает мутации.",
              "correct_position": 1,
              "correct_answer": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Change Detection стратегии] Практика: выбери лучший вариант действия.\n\nТема: Change Detection стратегии - архитектурный рефакторинг legacy приложений с массовым внедрением OnPush",
              "var_1": "Поставь setTimeout вокруг обновления, чтобы Angular «заметил» изменения.",
              "var_2": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_3": "Оставь мутации объектов как есть — OnPush сам увидит изменения внутри вложенных полей.",
              "var_4": "Вызывай detectChanges() в каждом ngOnChanges без условий — так надежнее.",
              "correct_position": 2,
              "correct_answer": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Производительность (CD, trackBy, bundle анализ)",
          "theme": "Bundle optimization - проектирование code-splitting архитектуры с lazy loading и preloading стратегиями",
          "questions": [
            {
              "question": "[Bundle optimization] Выбери наиболее корректное утверждение.\n\nТема: Bundle optimization - проектирование code-splitting архитектуры с lazy loading и preloading стратегиями",
              "var_1": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_2": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_3": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "var_4": "Lazy loading невозможно использовать со standalone компонентами.",
              "correct_position": 1,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Bundle optimization] Практика: выбери лучший вариант действия.\n\nТема: Bundle optimization - проектирование code-splitting архитектуры с lazy loading и preloading стратегиями",
              "var_1": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_2": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "var_3": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_4": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "correct_position": 3,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Навыки проведения рефакторинга и code review",
          "theme": "Рефакторинг архитектуры модулей - стратегия миграции монолитного модуля в lazy-loaded feature modules с управлением зависимостями",
          "questions": [
            {
              "question": "[Рефакторинг архитектуры модулей] Выбери наиболее корректное утверждение.\n\nТема: Рефакторинг архитектуры модулей - стратегия миграции монолитного модуля в lazy-loaded feature modules с управлением зависимостями",
              "var_1": "Guards нужны только для серверного рендеринга и не работают в SPA.",
              "var_2": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_3": "Lazy loading невозможно использовать со standalone компонентами.",
              "var_4": "Resolvers запускаются после отображения компонента, поэтому на загрузку данных не влияют.",
              "correct_position": 2,
              "correct_answer": "Angular Router поддерживает lazy loading, guards (canActivate/canMatch и т.д.) и resolvers для подготовки данных до активации маршрута; standalone-компоненты можно роутить без NgModule.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_3_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Рефакторинг архитектуры модулей] Практика: выбери лучший вариант действия.\n\nТема: Рефакторинг архитектуры модулей - стратегия миграции монолитного модуля в lazy-loaded feature modules с управлением зависимостями",
              "var_1": "Используй window.location вместо Router.navigate, так надёжнее.",
              "var_2": "Грузи все модули сразу, чтобы не было лишних запросов.",
              "var_3": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_4": "Проверяй авторизацию только на кнопке «Войти», guard не нужен.",
              "correct_position": 3,
              "correct_answer": "Ограничь доступ через guard (canMatch/canActivate), а тяжелые данные загружай через resolver или в компоненте с обработкой ошибок/лоадера.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        },
        {
          "competency": "Навыки проведения рефакторинга и code review",
          "theme": "Code review производительности приложения - анализ Change Detection стратегий и выявление bottlenecks через профилирование",
          "questions": [
            {
              "question": "[Code review производительности приложения] Выбери наиболее корректное утверждение.\n\nТема: Code review производительности приложения - анализ Change Detection стратегий и выявление bottlenecks через профилирование",
              "var_1": "OnPush отключает работу async pipe и RxJS подписок.",
              "var_2": "OnPush автоматически делает все объекты immutable и предотвращает мутации.",
              "var_3": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_4": "OnPush заставляет Angular пересчитывать компонент чаще, чем Default, поэтому всегда ускоряет приложение.",
              "correct_position": 3,
              "correct_answer": "В Angular OnPush означает, что компонент проверяется на изменения только при изменении входных @Input по ссылке, при событии в шаблоне, через async pipe или после явного markForCheck/detectChanges.",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            },
            {
              "question": "[Code review производительности приложения] Практика: выбери лучший вариант действия.\n\nТема: Code review производительности приложения - анализ Change Detection стратегий и выявление bottlenecks через профилирование",
              "var_1": "Поставь setTimeout вокруг обновления, чтобы Angular «заметил» изменения.",
              "var_2": "Оставь мутации объектов как есть — OnPush сам увидит изменения внутри вложенных полей.",
              "var_3": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_4": "Вызывай detectChanges() в каждом ngOnChanges без условий — так надежнее.",
              "correct_position": 3,
              "correct_answer": "Переведи компонент на OnPush и обеспечь неизменяемые (immutable) обновления входных данных; при ручных обновлениях используй ChangeDetectorRef.markForCheck().",
              "var_1_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_2_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              },
              "var_3_info": {
                "reason": "Верно: соответствует механике/контракту технологии и отражает реальные ограничения."
              },
              "var_4_info": {
                "reason": "Неверно: содержит типичную ловушку (слишком общее утверждение, подмена понятий или небезопасная практика)."
              }
            }
          ]
        }
      ]
    }
  },
  "generated_at": "2025-12-18T11:41:05.263520Z",
  "source_file": "SA_Frontend_themes.json"
}